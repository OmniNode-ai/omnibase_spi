#!/usr/bin/env python3
"""
MCP Subsystem Client Protocol - ONEX SPI Interface.

Protocol definition for MCP subsystem client integration.
Enables subsystems to register with and interact with the central MCP registry.

Domain: MCP subsystem integration and client-side operations
"""

from typing import Any, Callable, Optional, Protocol, runtime_checkable
from uuid import UUID

from omnibase_spi.protocols.types.protocol_core_types import ContextValue
from omnibase_spi.protocols.types.protocol_mcp_types import (
    LiteralMCPConnectionStatus,
    LiteralMCPLifecycleState,
    ProtocolMCPHealthCheck,
    ProtocolMCPSubsystemMetadata,
    ProtocolMCPSubsystemRegistration,
    ProtocolMCPToolDefinition,
    ProtocolMCPToolExecution,
)
from omnibase_spi.protocols.validation.protocol_validation import (
    ProtocolValidationResult,
)


@runtime_checkable
class ProtocolMCPSubsystemConfig(Protocol):
    """Protocol for MCP subsystem configuration."""

    subsystem_metadata: ProtocolMCPSubsystemMetadata
    registry_url: str
    api_key: str
    heartbeat_interval: int
    tool_definitions: list[ProtocolMCPToolDefinition]
    auto_register: bool
    retry_count: int
    timeout_seconds: int
    health_check_endpoint: str
    configuration: dict[str, ContextValue]


@runtime_checkable
class ProtocolMCPSubsystemClient(Protocol):
    """
    MCP subsystem client protocol for registry integration.

    Provides the client-side interface for subsystems to register with
    and interact with the central MCP registry infrastructure.

    Key Features:
        - **Automatic Registration**: Register subsystem and tools with central registry
        - **Heartbeat Management**: Maintain connection with periodic health updates
        - **Tool Handler Registration**: Register local handlers for tool execution
        - **Health Monitoring**: Perform local health checks and report status
        - **Configuration Validation**: Validate subsystem configuration before registration
        - **Error Recovery**: Handle connection failures and retry logic
        - **Lifecycle Management**: Manage subsystem lifecycle states
    """

    @property
    def config(self) -> ProtocolMCPSubsystemConfig: ...
    @property
    def registration_id(self) -> Optional[str]:
        """Get current registration ID with the registry."""
        ...

    @property
    def lifecycle_state(self) -> LiteralMCPLifecycleState:
        """Get current subsystem lifecycle state."""
        ...

    @property
    async def connection_status(self) -> LiteralMCPConnectionStatus:
        """Get current connection status to registry."""
        ...

    async def register_subsystem(self) -> str:
        """
        Register this subsystem with the central MCP registry.

        Returns:
            Registration ID assigned by the registry

        Raises:
            ValueError: If configuration is invalid
            RuntimeError: If registration fails
        """
        ...

    async def unregister_subsystem(self) -> bool:
        """
        Unregister this subsystem from the registry.

        Returns:
            True if unregistration successful
        """
        ...

    async def start_heartbeat(self, interval: Optional[int]) -> bool:
        """
        Start periodic heartbeat to maintain registration.

        Args:
            interval: Optional heartbeat interval override

        Returns:
            True if heartbeat started successfully
        """
        ...

    async def stop_heartbeat(self) -> bool:
        """
        Stop periodic heartbeat.

        Returns:
            True if heartbeat stopped successfully
        """
        ...

    async def send_heartbeat(
        self,
        health_status: Optional[str],
        metadata: Optional[dict[str, ContextValue]],
    ) -> bool:
        """
        Send immediate heartbeat to registry.

        Args:
            health_status: Optional health status override
            metadata: Optional metadata to include

        Returns:
            True if heartbeat sent successfully
        """
        ...

    async def register_tool_handler(
        self,
        tool_name: str,
        handler: Callable[[dict[str, ContextValue]], dict[str, Any]],
    ) -> bool:
        """
        Register a handler function for a tool.

        Args:
            tool_name: Name of the tool
            handler: Async function to handle tool execution

        Returns:
            True if handler registered successfully

        Raises:
            ValueError: If tool not found in configuration
        """
        ...

    async def unregister_tool_handler(self, tool_name: str) -> bool:
        """
        Unregister a tool handler.

        Args:
            tool_name: Name of the tool

        Returns:
            True if handler unregistered successfully
        """
        ...

    async def get_registered_tools(self) -> list[str]:
        """
        Get list of tools with registered handlers.

        Returns:
            List of tool names with active handlers
        """
        ...

    async def execute_tool_locally(
        self,
        tool_name: str,
        parameters: dict[str, ContextValue],
        execution_id: str,
        correlation_id: UUID,
    ) -> dict[str, Any]:
        """
        Execute a tool using local handler.

        Args:
            tool_name: Name of the tool to execute
            parameters: Tool execution parameters
            execution_id: Unique execution identifier
            correlation_id: Request correlation ID

        Returns:
            Tool execution result

        Raises:
            ValueError: If tool handler not found or parameters invalid
            RuntimeError: If execution fails
        """
        ...

    async def validate_configuration(self) -> ProtocolValidationResult:
        """
        Validate subsystem configuration.

        Returns:
            Validation result with any errors or warnings
        """
        ...

    async def validate_tool_parameters(
        self,
        tool_name: str,
        parameters: dict[str, ContextValue],
    ) -> ProtocolValidationResult:
        """
        Validate tool execution parameters.

        Args:
            tool_name: Name of the tool
            parameters: Parameters to validate

        Returns:
            Validation result
        """
        ...

    async def perform_local_health_check(self) -> ProtocolMCPHealthCheck:
        """
        Perform local health check of the subsystem.

        Returns:
            Health check result
        """
        ...

    async def get_subsystem_status(self) -> dict[str, Any]:
        """
        Get current subsystem status and metrics.

        Returns:
            Status information including health, performance, and statistics
        """
        ...

    async def update_configuration(
        self, configuration: dict[str, ContextValue]
    ) -> bool:
        """
        Update subsystem configuration dynamically.

        Args:
            configuration: New configuration values

        Returns:
            True if configuration updated successfully
        """
        ...

    async def get_registration_info(self) -> Optional[ProtocolMCPSubsystemRegistration]:
        """
        Get current registration information from registry.

        Returns:
            Registration information or None if not registered
        """
        ...

    async def test_registry_connection(self) -> bool:
        """
        Test connectivity to the MCP registry.

        Returns:
            True if registry is reachable and responding
        """
        ...

    async def get_tool_execution_history(
        self, tool_name: Optional[str], limit: int
    ) -> list[ProtocolMCPToolExecution]:
        """
        Get local tool execution history.

        Args:
            tool_name: Optional filter by tool name
            limit: Maximum number of results

        Returns:
            List of tool executions handled by this subsystem
        """
        ...

    async def shutdown_gracefully(self, timeout_seconds: int) -> bool:
        """
        Perform graceful shutdown of the subsystem.

        Args:
            timeout_seconds: Maximum time to wait for clean shutdown

        Returns:
            True if shutdown completed successfully
        """
        ...
