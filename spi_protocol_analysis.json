{
  "analysis": {
    "exact_duplicates": {},
    "name_conflicts": {},
    "distribution_analysis": {
      "file_handling": {
        "count": 5,
        "protocols": [
          "ProtocolFileReader",
          "ProtocolStampOptions",
          "ProtocolValidationOptions",
          "ProtocolFileTypeHandler",
          "ProtocolHandlerDiscovery"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 3,
          "property_only": 2
        },
        "avg_properties": 1.2,
        "avg_methods": 4.4
      },
      "types": {
        "count": 155,
        "protocols": [
          "ProtocolWorkflowValue",
          "ProtocolWorkflowStringValue",
          "ProtocolWorkflowStringListValue",
          "ProtocolWorkflowStringDictValue",
          "ProtocolWorkflowNumericValue",
          "ProtocolWorkflowStructuredValue",
          "ProtocolTypedWorkflowData",
          "ProtocolWorkflowMetadata",
          "ProtocolRetryConfiguration",
          "ProtocolTimeoutConfiguration",
          "ProtocolTaskDependency",
          "ProtocolWorkflowContext",
          "ProtocolTaskConfiguration",
          "ProtocolWorkflowEvent",
          "ProtocolWorkflowSnapshot",
          "ProtocolTaskResult",
          "ProtocolCompensationAction",
          "ProtocolWorkflowDefinition",
          "ProtocolNodeCapability",
          "ProtocolWorkflowServiceInstance",
          "ProtocolRecoveryPoint",
          "ProtocolReplayStrategy",
          "ProtocolEventStream",
          "ProtocolEventProjection",
          "ProtocolSemVer",
          "ProtocolContextValue",
          "ProtocolContextStringValue",
          "ProtocolContextNumericValue",
          "ProtocolContextBooleanValue",
          "ProtocolContextStringListValue",
          "ProtocolContextStringDictValue",
          "ProtocolSupportedMetadataType",
          "ProtocolConfigValue",
          "ProtocolLogContext",
          "ProtocolLogEntry",
          "ProtocolSerializationResult",
          "ProtocolNodeMetadata",
          "ProtocolCacheStatistics",
          "ProtocolMetadata",
          "ProtocolMetadataOperations",
          "ProtocolActionPayload",
          "ProtocolAction",
          "ProtocolState",
          "ProtocolNodeMetadataBlock",
          "ProtocolSchemaObject",
          "ProtocolErrorInfo",
          "ProtocolSystemEvent",
          "ProtocolNodeResult",
          "ProtocolServiceMetadata",
          "ProtocolServiceInstance",
          "ProtocolServiceHealthStatus",
          "ProtocolCheckpointData",
          "ProtocolStorageCredentials",
          "ProtocolStorageConfiguration",
          "ProtocolStorageResult",
          "ProtocolStorageListResult",
          "ProtocolStorageHealthStatus",
          "ProtocolErrorContext",
          "ProtocolRecoveryAction",
          "ProtocolErrorResult",
          "ProtocolVersionInfo",
          "ProtocolCompatibilityCheck",
          "ProtocolNodeInfoLike",
          "ProtocolSupportedPropertyValue",
          "ProtocolHealthMetrics",
          "ProtocolHealthCheck",
          "ProtocolHealthMonitoring",
          "ProtocolMetricsPoint",
          "ProtocolTraceSpan",
          "ProtocolAuditEvent",
          "ProtocolSerializable",
          "ProtocolIdentifiable",
          "ProtocolNameable",
          "ProtocolConfigurable",
          "ProtocolExecutable",
          "ProtocolMetadataProvider",
          "ProtocolRetryConfig",
          "ProtocolRetryPolicy",
          "ProtocolRetryAttempt",
          "ProtocolRetryResult",
          "ProtocolTimeBased",
          "ProtocolTimeout",
          "ProtocolDuration",
          "ProtocolAnalyticsMetric",
          "ProtocolAnalyticsProvider",
          "ProtocolAnalyticsSummary",
          "ProtocolPerformanceMetric",
          "ProtocolPerformanceMetrics",
          "ProtocolConnectionConfig",
          "ProtocolConnectionStatus",
          "ProtocolValidatable",
          "ProtocolFileContent",
          "ProtocolStringFileContent",
          "ProtocolBinaryFileContent",
          "ProtocolFileMetadata",
          "ProtocolFileInfo",
          "ProtocolFileContentObject",
          "ProtocolProcessingResult",
          "ProtocolFileFilter",
          "ProtocolFileTypeResult",
          "ProtocolHandlerMatch",
          "ProtocolCanHandleResult",
          "ProtocolHandlerMetadata",
          "ProtocolExtractedBlock",
          "ProtocolSerializedBlock",
          "ProtocolResultData",
          "ProtocolOnexResult",
          "ProtocolFileMetadataOperations",
          "ProtocolResultOperations",
          "ProtocolContainer",
          "ProtocolDependencySpec",
          "ProtocolContainerServiceInstance",
          "ProtocolRegistryWrapper",
          "ProtocolContainerResult",
          "ProtocolContainerToolInstance",
          "ProtocolContainerFactory",
          "ProtocolContainerServiceFactory",
          "ProtocolContainerConfiguration",
          "ProtocolEventData",
          "ProtocolEventStringData",
          "ProtocolEventStringListData",
          "ProtocolEventStringDictData",
          "ProtocolEvent",
          "ProtocolEventResult",
          "ProtocolSecurityContext",
          "ProtocolEventSubscription",
          "ProtocolOnexEvent",
          "ProtocolEventBusConnectionCredentials",
          "ProtocolEventHeaders",
          "ProtocolEventMessage",
          "ProtocolCompletionData",
          "ProtocolCapabilityValue",
          "ProtocolCapabilityStringValue",
          "ProtocolCapabilityNumericValue",
          "ProtocolCapabilityBooleanValue",
          "ProtocolCapabilityStringListValue",
          "ProtocolHandlerCapability",
          "ProtocolDiscoveryNodeInfo",
          "ProtocolDiscoveryQuery",
          "ProtocolDiscoveryResult",
          "ProtocolHandlerRegistration",
          "ProtocolMCPToolParameter",
          "ProtocolMCPToolDefinition",
          "ProtocolMCPSubsystemMetadata",
          "ProtocolMCPSubsystemRegistration",
          "ProtocolMCPToolExecution",
          "ProtocolMCPRegistryMetrics",
          "ProtocolMCPRegistryStatus",
          "ProtocolMCPRegistryConfig",
          "ProtocolMCPHealthCheck",
          "ProtocolMCPDiscoveryInfo",
          "ProtocolMCPValidationError",
          "ProtocolMCPValidationResult",
          "ProtocolToolClass",
          "ProtocolToolInstance"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 118,
          "property_only": 37
        },
        "avg_properties": 4.825806451612904,
        "avg_methods": 1.5096774193548388
      },
      "core": {
        "count": 76,
        "protocols": [
          "ProtocolHttpRequestBuilder",
          "ProtocolHttpStreamingResponse",
          "ProtocolHttpExtendedClient",
          "ProtocolAnalyticsDataProvider",
          "ProtocolMetricsCollector",
          "ProtocolDistributedTracing",
          "ProtocolAuditLogger",
          "ProtocolKafkaClient",
          "ProtocolKafkaClientProvider",
          "ProtocolUtilsNodeConfiguration",
          "ProtocolOnexEnvelope",
          "ProtocolHealthDetails",
          "ProtocolOnexReply",
          "ProtocolPerformanceMetricsCollector",
          "ProtocolConnectionManageable",
          "ProtocolHttpResponse",
          "ProtocolHttpClient",
          "ProtocolHttpClientProvider",
          "ProtocolVersionManager",
          "ProtocolKafkaMessage",
          "ProtocolKafkaConsumer",
          "ProtocolKafkaBatchProducer",
          "ProtocolKafkaTransactionalProducer",
          "ProtocolKafkaExtendedClient",
          "ProtocolHealthMonitor",
          "ProtocolLogger",
          "ProtocolStorageBackend",
          "ProtocolStorageBackendFactory",
          "ProtocolInputValidator",
          "ProtocolSchemaLoader",
          "ProtocolConfigurationManager",
          "ProtocolConfigurationManagerFactory",
          "ProtocolTimeBasedOperations",
          "ProtocolWorkflow",
          "ProtocolWorkflowReducer",
          "ProtocolValidationRule",
          "ProtocolValidationRuleSet",
          "ProtocolValidationSession",
          "ProtocolValidationProvider",
          "ProtocolRetryable",
          "ProtocolNodeConfiguration",
          "ProtocolNodeConfigurationProvider",
          "ProtocolConfigurationError",
          "ProtocolCacheService",
          "ProtocolCacheServiceProvider",
          "ProtocolNodeChangeCallback",
          "ProtocolWatchHandle",
          "ProtocolNodeRegistryConfig",
          "ProtocolNodeInfo",
          "ProtocolNodeRegistry",
          "ProtocolErrorHandler",
          "ProtocolServiceDiscovery",
          "ProtocolOnexNode",
          "ProtocolContractService",
          "ProtocolErrorSanitizer",
          "ProtocolErrorSanitizerFactory",
          "ProtocolCircuitBreakerConfig",
          "ProtocolCircuitBreakerMetrics",
          "ProtocolCircuitBreaker",
          "ProtocolCircuitBreakerFactory",
          "ProtocolHttpClientConfig",
          "ProtocolHttpAuthConfig",
          "ProtocolKafkaClientConfig",
          "ProtocolKafkaProducerConfig",
          "ProtocolKafkaConsumerConfig",
          "ProtocolClientConfigProvider",
          "ProtocolCanonicalSerializer",
          "ProtocolWorkflowManageable",
          "ProtocolOnexContractData",
          "ProtocolOnexSecurityContext",
          "ProtocolOnexMetadata",
          "ProtocolOnexSchema",
          "ProtocolOnexValidationReport",
          "ProtocolOnexValidationResult",
          "ProtocolOnexValidation",
          "ProtocolNodeDiscoveryRegistry"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 58,
          "property_only": 16,
          "mixin": 2
        },
        "avg_properties": 2.1052631578947367,
        "avg_methods": 6.565789473684211
      },
      "memory": {
        "count": 95,
        "protocols": [
          "ProtocolMemoryResponse",
          "ProtocolMemoryStoreResponse",
          "ProtocolMemoryRetrieveResponse",
          "ProtocolMemoryListResponse",
          "ProtocolBatchOperationResult",
          "ProtocolBatchMemoryStoreResponse",
          "ProtocolBatchMemoryRetrieveResponse",
          "ProtocolSemanticSearchResponse",
          "ProtocolPatternAnalysisResponse",
          "ProtocolEmbeddingResponse",
          "ProtocolConsolidationResponse",
          "ProtocolAggregationResponse",
          "ProtocolWorkflowExecutionResponse",
          "ProtocolAgentCoordinationResponse",
          "ProtocolPaginationResponse",
          "ProtocolMemoryMetrics",
          "ProtocolMemoryMetricsResponse",
          "ProtocolStreamingMemoryResponse",
          "ProtocolStreamingRetrieveResponse",
          "ProtocolKeyValueStore",
          "ProtocolMemoryMetadata",
          "ProtocolWorkflowConfiguration",
          "ProtocolAnalysisParameters",
          "ProtocolAggregationCriteria",
          "ProtocolCoordinationMetadata",
          "ProtocolAnalysisResults",
          "ProtocolAggregatedData",
          "ProtocolMemoryErrorContext",
          "ProtocolPageInfo",
          "ProtocolCustomMetrics",
          "ProtocolAggregationSummary",
          "ProtocolMemoryRecord",
          "ProtocolSearchResult",
          "ProtocolSearchFilters",
          "ProtocolAgentStatusMap",
          "ProtocolAgentResponseMap",
          "ProtocolErrorCategoryMap",
          "ProtocolWorkflowManager",
          "ProtocolAgentCoordinator",
          "ProtocolClusterCoordinator",
          "ProtocolLifecycleManager",
          "ProtocolMemoryOrchestrator",
          "ProtocolComputeNodeComposite",
          "ProtocolMemoryRequest",
          "ProtocolMemoryStoreRequest",
          "ProtocolMemoryRetrieveRequest",
          "ProtocolMemoryListRequest",
          "ProtocolBatchMemoryStoreRequest",
          "ProtocolBatchMemoryRetrieveRequest",
          "ProtocolSemanticSearchRequest",
          "ProtocolPatternAnalysisRequest",
          "ProtocolEmbeddingRequest",
          "ProtocolConsolidationRequest",
          "ProtocolAggregationRequest",
          "ProtocolWorkflowExecutionRequest",
          "ProtocolAgentCoordinationRequest",
          "ProtocolPaginationRequest",
          "ProtocolMemoryMetricsRequest",
          "ProtocolStreamingMemoryRequest",
          "ProtocolStreamingRetrieveRequest",
          "ProtocolMemoryEffectNode",
          "ProtocolMemoryComputeNode",
          "ProtocolMemoryReducerNode",
          "ProtocolMemoryOrchestratorNode",
          "ProtocolMemoryHealthNode",
          "ProtocolMemoryError",
          "ProtocolMemoryErrorResponse",
          "ProtocolMemoryValidationError",
          "ProtocolMemoryAuthorizationError",
          "ProtocolMemoryNotFoundError",
          "ProtocolMemoryTimeoutError",
          "ProtocolMemoryCapacityError",
          "ProtocolMemoryCorruptionError",
          "ProtocolErrorRecoveryStrategy",
          "ProtocolMemoryErrorRecoveryResponse",
          "ProtocolBatchErrorSummary",
          "ProtocolBatchErrorResponse",
          "ProtocolErrorCategory",
          "ProtocolMemoryRetryPolicy",
          "ProtocolMemoryCompensationAction",
          "ProtocolOperationContext",
          "ProtocolMemoryErrorHandler",
          "ProtocolMemoryHealthMonitor",
          "ProtocolStreamingChunk",
          "ProtocolStreamingConfig",
          "ProtocolCursorPagination",
          "ProtocolStreamingMemoryNode",
          "ProtocolMemoryCache",
          "ProtocolPerformanceOptimization",
          "ProtocolMemorySecurityContext",
          "ProtocolAuditTrail",
          "ProtocolRateLimitConfig",
          "ProtocolInputValidation",
          "ProtocolMemorySecurityNode",
          "ProtocolMemoryComplianceNode"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 81,
          "property_only": 10,
          "mixin": 4
        },
        "avg_properties": 1.831578947368421,
        "avg_methods": 2.8842105263157896
      },
      "unknown": {
        "count": 1,
        "protocols": [
          "ProtocolHandlerInfo"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "property_only": 1
        },
        "avg_properties": 7.0,
        "avg_methods": 0.0
      },
      "mcp": {
        "count": 15,
        "protocols": [
          "ProtocolMCPToolRouter",
          "ProtocolMCPToolExecutor",
          "ProtocolMCPToolProxy",
          "ProtocolMCPRegistry",
          "ProtocolMCPRegistryAdmin",
          "ProtocolMCPRegistryMetricsOperations",
          "ProtocolMCPHealthMonitor",
          "ProtocolMCPMonitor",
          "ProtocolMCPSubsystemConfig",
          "ProtocolMCPSubsystemClient",
          "ProtocolMCPServiceDiscovery",
          "ProtocolMCPDiscovery",
          "ProtocolMCPToolValidator",
          "ProtocolMCPValidator",
          "ProtocolToolDiscoveryService"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 14,
          "property_only": 1
        },
        "avg_properties": 0.6666666666666666,
        "avg_methods": 8.8
      },
      "container": {
        "count": 16,
        "protocols": [
          "ProtocolServiceRegistrationMetadata",
          "ProtocolServiceDependency",
          "ProtocolServiceRegistration",
          "ProtocolRegistryServiceInstance",
          "ProtocolDependencyGraph",
          "ProtocolInjectionContext",
          "ProtocolServiceRegistryStatus",
          "ProtocolServiceValidator",
          "ProtocolServiceFactory",
          "ProtocolServiceRegistryConfig",
          "ProtocolServiceRegistry",
          "ProtocolContainerService",
          "ProtocolArtifactMetadata",
          "ProtocolArtifactInfo",
          "ProtocolArtifactContainerStatus",
          "ProtocolArtifactContainer"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "property_only": 8,
          "functional": 8
        },
        "avg_properties": 5.9375,
        "avg_methods": 2.8125
      },
      "workflow": {
        "count": 16,
        "protocols": [
          "ProtocolWorkQueue",
          "ProtocolWorkflowEventMessage",
          "ProtocolWorkflowEventHandler",
          "ProtocolLiteralWorkflowStateProjection",
          "ProtocolWorkflowEventBus",
          "ProtocolWorkflowNodeCapability",
          "ProtocolWorkflowNodeInfo",
          "ProtocolTaskSchedulingCriteria",
          "ProtocolNodeSchedulingResult",
          "ProtocolWorkflowNodeRegistry",
          "ProtocolEventStoreTransaction",
          "ProtocolEventQueryOptions",
          "ProtocolEventStoreResult",
          "ProtocolEventStore",
          "ProtocolSnapshotStore",
          "ProtocolLiteralWorkflowStateStore"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 10,
          "property_only": 6
        },
        "avg_properties": 4.625,
        "avg_methods": 4.4375
      },
      "validation": {
        "count": 24,
        "protocols": [
          "ProtocolValidationError",
          "ProtocolValidationResult",
          "ProtocolValidator",
          "ProtocolValidationDecorator",
          "ProtocolQualityMetrics",
          "ProtocolQualityIssue",
          "ProtocolQualityStandards",
          "ProtocolQualityReport",
          "ProtocolQualityValidator",
          "ProtocolValidationScope",
          "ProtocolValidationWorkflow",
          "ProtocolValidationMetrics",
          "ProtocolValidationSummary",
          "ProtocolValidationReport",
          "ProtocolValidationOrchestrator",
          "ProtocolComplianceRule",
          "ProtocolComplianceViolation",
          "ProtocolONEXStandards",
          "ProtocolArchitectureCompliance",
          "ProtocolComplianceReport",
          "ProtocolComplianceValidator",
          "ProtocolImportValidationConfig",
          "ProtocolImportAnalysis",
          "ProtocolImportValidator"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 24
        },
        "avg_properties": 5.041666666666667,
        "avg_methods": 3.125
      },
      "events": {
        "count": 17,
        "protocols": [
          "ProtocolEventBusContextManager",
          "ProtocolRedpandaAdapter",
          "ProtocolEventBusBase",
          "ProtocolSyncEventBus",
          "ProtocolAsyncEventBus",
          "ProtocolRegistryWithBus",
          "ProtocolLogEmitter",
          "ProtocolEventBusInMemory",
          "ProtocolEventBusHeaders",
          "ProtocolKafkaEventBusAdapter",
          "ProtocolEventBus",
          "ProtocolEventBusService",
          "ProtocolHttpEventBusAdapter",
          "ProtocolEventBusCredentials",
          "ProtocolEventPubSub",
          "ProtocolKafkaConfig",
          "ProtocolKafkaAdapter"
        ],
        "runtime_checkable_ratio": 1.0,
        "type_distribution": {
          "functional": 12,
          "mixin": 4,
          "property_only": 1
        },
        "avg_properties": 1.0,
        "avg_methods": 4.0
      }
    },
    "total_protocols": 420,
    "protocols_by_domain": {
      "file_handling": [
        "ProtocolInfo(name='ProtocolFileReader', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_reader.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_reader', methods=['async read_text(path: str) -> str', 'async read_yaml(path: str, data_class: type[T]) -> T', 'async exists(path: str) -> bool'], signature_hash='1d2eb7ed112b2022', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'typing.Any'], line_number=17, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for reading file contents.\\n\\n    This abstraction allows for different implementations:\\n    - FileSystemFileReader: Reads from actual filesystem\\n    - MockFileReader: Returns predefined content for testing\\n    - RemoteFileReader: Could read from S3, HTTP, etc.\\n    ')",
        "ProtocolInfo(name='ProtocolStampOptions', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=[], signature_hash='dfe48240f02973a1', line_count=3, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=18, is_runtime_checkable=True, domain='file_handling', properties=['force: bool', 'backup: bool', 'dry_run: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for stamping operation options.')",
        "ProtocolInfo(name='ProtocolValidationOptions', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=[], signature_hash='6d8d3f94e2047c7e', line_count=3, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=27, is_runtime_checkable=True, domain='file_handling', properties=['strict: bool', 'verbose: bool', 'check_syntax: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for validation operation options.')",
        "ProtocolInfo(name='ProtocolFileTypeHandler', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=['metadata() -> ProtocolNodeMetadata', 'node_name() -> str', 'node_version() -> ProtocolSemVer', 'node_author() -> str', 'node_description() -> str', 'supported_extensions() -> list[str]', 'supported_filenames() -> list[str]', 'node_priority() -> int', 'requires_content_analysis() -> bool', 'async can_handle(path: str, content: str) -> ProtocolCanHandleResult', 'async extract_block(path: str, content: str) -> ProtocolExtractedBlock', \"serialize_block(meta: 'ProtocolExtractedBlock') -> ProtocolSerializedBlock\", 'normalize_rest(rest: str) -> str', \"async stamp(path: str, content: str, options: 'ProtocolStampOptions') -> ProtocolOnexResult\", \"async pre_validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult | None\", \"async post_validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult | None\", \"async validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult\"], signature_hash='6a3eb9d463b5522b', line_count=17, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=36, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for file type nodes in the ONEX stamper engine.\\n    All methods and metadata must use canonical result models per typing_and_protocols rule.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class NodePythonFileProcessor:\\n            @property\\n            def metadata(self) -> ProtocolNodeMetadata:\\n                # Implementation would return configured metadata\\n                ...\\n\\n            @property\\n            def node_name(self) -> str:\\n                # Implementation returns node identifier\\n                ...\\n\\n            def can_handle(self, path: str, content: str) -> ProtocolCanHandleResult:\\n                # Implementation determines if file can be processed\\n                ...\\n\\n            def extract_block(self, path: str, content: str) -> ProtocolExtractedBlock:\\n                # Implementation extracts structured block from file content\\n                ...\\n\\n            def stamp(self, path: str, content: str, options: \"ProtocolStampOptions\") -> ProtocolOnexResult:\\n                # Implementation adds metadata stamp to file\\n                ...\\n\\n            def validate(self, path: str, content: str, options: \"ProtocolValidationOptions\") -> ProtocolOnexResult:\\n                # Implementation validates file content and metadata\\n                ...\\n\\n        # Usage in application\\n        node: \"ProtocolFileTypeHandler\" = NodePythonFileProcessor()\\n\\n        # Check if node can process a file\\n        result = node.can_handle(\"example.py\", \"file_content\")\\n        if result.can_handle:\\n            # Extract, stamp, and validate file\\n            block = node.extract_block(\"example.py\", \"file_content\")\\n            # ... implementation handles file operations\\n        ```\\n\\n    Node Implementation Patterns:\\n        - File type detection: Extension-based, content-based, and heuristic analysis\\n        - Metadata extraction: Language-specific parsing (AST, regex, etc.)\\n        - Stamping workflow: Extract \u2192 Serialize \u2192 Inject \u2192 Validate\\n        - Validation modes: Syntax checking, metadata compliance, strict requirements\\n        - Error handling: Graceful degradation with detailed error messages\\n    ')",
        "ProtocolInfo(name='ProtocolHandlerDiscovery', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[\"async discover_nodes() -> list['ProtocolHandlerInfo']\", 'get_source_name() -> str'], signature_hash='9536b27500805286', line_count=2, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=53, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for discovering file type nodes.\\n\\n    Implementations of this protocol can discover nodes from various sources\\n    (entry points, configuration files, environment variables, etc.) without\\n    requiring hardcoded imports in the core registry.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class EntryPointNodeDiscovery:\\n            @property\\n            def group_name(self) -> str: ...\\n\\n            @property\\n            def discovered_nodes(self) -> list[Any]: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from Python entry points\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        class ConfigFileNodeDiscovery:\\n            @property\\n            def config_path(self) -> Any: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from configuration file\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        class EnvironmentNodeDiscovery:\\n            @property\\n            def env_prefix(self) -> str: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from environment variables\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        # Usage in application\\n        registry: \"ProtocolNodeDiscoveryRegistry\" = NodeDiscoveryRegistryImpl()\\n\\n        # Register multiple discovery sources\\n        entry_point_discovery: \"ProtocolHandlerDiscovery\" = EntryPointNodeDiscovery(group_name=\"your.entry.point.group\")\\n        config_discovery: \"ProtocolHandlerDiscovery\" = ConfigFileNodeDiscovery(config_path=\"path/to/config.yaml\")\\n        env_discovery: \"ProtocolHandlerDiscovery\" = EnvironmentNodeDiscovery(env_prefix=\"YOUR_NODE_PREFIX_\")\\n\\n        registry.register_discovery_source(entry_point_discovery)\\n        registry.register_discovery_source(config_discovery)\\n        registry.register_discovery_source(env_discovery)\\n\\n        # Discover and register all nodes\\n        registry.discover_and_register_nodes()\\n\\n        # Print discovered nodes\\n        ...\\n        ```\\n\\n    Discovery Implementation Patterns:\\n        - Entry Points: Use setuptools entry points for plugin architecture\\n        - Configuration Files: YAML/JSON configuration with dynamic imports\\n        - Environment Variables: Runtime node registration via env vars\\n        - Directory Scanning: Automatic discovery from node directories\\n        - Metadata Caching: Cache node metadata for performance\\n        - Error Handling: Graceful fallback when nodes fail to load\\n    ')"
      ],
      "types": [
        "ProtocolInfo(name='ProtocolWorkflowValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['serialize() -> dict[str, object]', 'validate() -> bool', 'get_type_info() -> str'], signature_hash='c4b3bc95f22f76cb', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=19, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow data values supporting serialization and validation.')",
        "ProtocolInfo(name='ProtocolWorkflowStringValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_string_length() -> int', 'is_empty_string() -> bool'], signature_hash='c4a42f1002217fbb', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=36, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string-based workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_list_length() -> int', 'is_empty_list() -> bool'], signature_hash='84e779c9ee10ed41', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=51, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string list workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowStringDictValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_dict_keys() -> list[str]', 'has_key(key: str) -> bool'], signature_hash='7ae62284b213aff8', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=66, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string dictionary workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['is_integer() -> bool', 'is_positive() -> bool'], signature_hash='7983be3306b397b2', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=81, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for numeric workflow values (int or float).')",
        "ProtocolInfo(name='ProtocolWorkflowStructuredValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_structure_depth() -> int', \"flatten_structure() -> dict[str, 'ContextValue']\"], signature_hash='9e2728b3c18fd043', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=96, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for structured workflow values with context data.')",
        "ProtocolInfo(name='ProtocolTypedWorkflowData', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_type_name() -> str', 'serialize_typed() -> dict[str, Any]'], signature_hash='82fb853101ff2c45', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=114, is_runtime_checkable=True, domain='types', properties=['value: T_WorkflowValue'], base_protocols=['Generic[T_WorkflowValue]'], protocol_type='functional', docstring='Protocol for strongly typed workflow data values.')",
        "ProtocolInfo(name='ProtocolWorkflowMetadata', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_metadata() -> bool', 'is_complete() -> bool'], signature_hash='5ce24225c795cb57', line_count=11, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=186, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'created_by: str', 'environment: str', 'group: str', \"version: 'ProtocolSemVer'\", \"tags: dict[str, 'ContextValue']\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow metadata objects.')",
        "ProtocolInfo(name='ProtocolRetryConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_retry_config() -> bool', 'is_valid_policy() -> bool'], signature_hash='a4a11450acb7c879', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=209, is_runtime_checkable=True, domain='types', properties=['policy: LiteralRetryPolicy', 'max_attempts: int', 'initial_delay_seconds: float', 'max_delay_seconds: float', 'backoff_multiplier: float', 'jitter_enabled: bool', 'retryable_errors: list[str]', 'non_retryable_errors: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry configuration objects.')",
        "ProtocolInfo(name='ProtocolTimeoutConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_timeout_config() -> bool', 'is_reasonable() -> bool'], signature_hash='bbf6d0a83382de76', line_count=7, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=231, is_runtime_checkable=True, domain='types', properties=['timeout_type: LiteralTimeoutType', 'timeout_seconds: int', 'warning_seconds: int | None', 'grace_period_seconds: int | None', 'escalation_policy: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for timeout configuration objects.')",
        "ProtocolInfo(name='ProtocolTaskDependency', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_dependency() -> bool', 'is_conditional() -> bool'], signature_hash='00c25e5cfedd29c5', line_count=6, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=250, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', \"dependency_type: Literal['hard', 'soft', 'conditional']\", 'condition: str | None', 'timeout_seconds: int | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for task dependency objects.')",
        "ProtocolInfo(name='ProtocolWorkflowContext', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_context() -> bool', 'has_required_data() -> bool'], signature_hash='bbb01ee9c1aaeb81', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=268, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'isolation_level: LiteralIsolationLevel', \"data: dict[str, 'ProtocolWorkflowValue']\", \"secrets: dict[str, 'ContextValue']\", 'capabilities: list[str]', 'resource_limits: dict[str, int]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow context objects with isolation.')",
        "ProtocolInfo(name='ProtocolTaskConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_task() -> bool', 'has_valid_dependencies() -> bool'], signature_hash='b3b881ef5fbd80ba', line_count=13, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=290, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', 'task_name: str', 'task_type: LiteralTaskType', 'node_type: LiteralNodeType', 'execution_semantics: LiteralExecutionSemantics', 'priority: LiteralTaskPriority', \"dependencies: list['ProtocolTaskDependency']\", \"retry_config: 'ProtocolRetryConfiguration'\", \"timeout_config: 'ProtocolTimeoutConfiguration'\", 'resource_requirements: dict[str, Any]', \"annotations: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for task configuration objects.')",
        "ProtocolInfo(name='ProtocolWorkflowEvent', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_event() -> bool', 'is_valid_sequence() -> bool'], signature_hash='0d6d6652329cbbb9', line_count=15, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=315, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: LiteralWorkflowEventType', 'workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'sequence_number: int', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'idempotency_key: str', \"payload: dict[str, 'ProtocolWorkflowValue']\", \"metadata: dict[str, 'ContextValue']\", 'causation_id: UUID | None', 'correlation_chain: list[UUID]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow event objects with event sourcing.')",
        "ProtocolInfo(name='ProtocolWorkflowSnapshot', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_snapshot() -> bool', 'is_consistent() -> bool'], signature_hash='a5d5c4124e3b1302', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=342, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'sequence_number: int', 'state: LiteralWorkflowState', \"context: 'ProtocolWorkflowContext'\", \"tasks: list['ProtocolTaskConfiguration']\", \"created_at: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow snapshot objects.')",
        "ProtocolInfo(name='ProtocolTaskResult', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_result() -> bool', 'is_success() -> bool'], signature_hash='cabe5d5ca139f1ba', line_count=13, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=364, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', 'execution_id: UUID', 'state: LiteralTaskState', \"result_data: dict[str, 'ProtocolWorkflowValue']\", 'error_message: str | None', 'error_code: str | None', 'retry_count: int', 'execution_time_seconds: float', 'resource_usage: dict[str, float]', 'output_artifacts: list[str]', \"events_emitted: list['ProtocolWorkflowEvent']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for task execution results.')",
        "ProtocolInfo(name='ProtocolCompensationAction', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_compensation() -> bool', 'can_execute() -> bool'], signature_hash='a022da442c9efbf9', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=389, is_runtime_checkable=True, domain='types', properties=['compensation_id: UUID', 'task_id: UUID', \"action_type: Literal['rollback', 'cleanup', 'notify', 'custom']\", \"action_data: dict[str, 'ProtocolWorkflowValue']\", 'timeout_seconds: int', \"retry_config: 'ProtocolRetryConfiguration'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for compensation action objects.')",
        "ProtocolInfo(name='ProtocolWorkflowDefinition', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_definition() -> bool', 'is_valid_schema() -> bool'], signature_hash='391c89c69066c78e', line_count=12, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=409, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', \"version: 'ProtocolSemVer'\", 'name: str', 'description: str', \"tasks: list['ProtocolTaskConfiguration']\", \"default_retry_config: 'ProtocolRetryConfiguration'\", \"default_timeout_config: 'ProtocolTimeoutConfiguration'\", \"compensation_actions: list['ProtocolCompensationAction']\", 'validation_rules: dict[str, Any]', 'schema: dict[str, Any]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow definition objects.')",
        "ProtocolInfo(name='ProtocolNodeCapability', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_capability() -> bool', 'is_supported() -> bool'], signature_hash='c4bddf7c3983665e', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=433, is_runtime_checkable=True, domain='types', properties=['capability_name: str', \"version: 'ProtocolSemVer'\", 'node_types: list[LiteralNodeType]', 'resource_requirements: dict[str, Any]', 'configuration_schema: dict[str, Any]', 'supported_task_types: list[LiteralTaskType]'], base_protocols=[], protocol_type='functional', docstring='Protocol for node capability objects.')",
        "ProtocolInfo(name='ProtocolWorkflowServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_service_instance() -> bool', 'is_healthy() -> bool'], signature_hash='a8ecd65a95f2b5c5', line_count=9, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=453, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'service_type: str', 'endpoint: str', 'health_check_url: str', \"metadata: dict[str, 'ContextValue']\", \"capabilities: list['ProtocolNodeCapability']\", \"last_heartbeat: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for discovered service instance objects in workflow orchestration.')",
        "ProtocolInfo(name='ProtocolRecoveryPoint', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_recovery_point() -> bool', 'is_restorable() -> bool'], signature_hash='455ffeb61ad39ec7', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=474, is_runtime_checkable=True, domain='types', properties=['recovery_id: UUID', 'workflow_type: str', 'instance_id: UUID', 'sequence_number: int', 'state: LiteralWorkflowState', \"recovery_type: Literal['checkpoint', 'savepoint', 'snapshot']\", \"created_at: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for recovery point objects.')",
        "ProtocolInfo(name='ProtocolReplayStrategy', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_replay_strategy() -> bool', 'is_executable() -> bool'], signature_hash='e50a68b5275cc63c', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=496, is_runtime_checkable=True, domain='types', properties=[\"strategy_type: Literal['full', 'partial', 'from_checkpoint', 'from_sequence']\", 'start_sequence: int | None', 'end_sequence: int | None', 'event_filters: list[str]', 'skip_failed_events: bool', 'validate_state: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for replay strategy objects.')",
        "ProtocolInfo(name='ProtocolEventStream', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_stream() -> bool', 'is_complete_stream() -> bool'], signature_hash='809e8fbe551f11ca', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=516, is_runtime_checkable=True, domain='types', properties=['stream_id: str', 'workflow_type: str', 'instance_id: UUID', 'start_sequence: int', 'end_sequence: int', \"events: list['ProtocolWorkflowEvent']\", 'is_complete: bool', 'next_token: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for event stream objects.')",
        "ProtocolInfo(name='ProtocolEventProjection', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_projection() -> bool', 'is_up_to_date() -> bool'], signature_hash='7f08a3e32620b07b', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=538, is_runtime_checkable=True, domain='types', properties=['projection_name: str', 'workflow_type: str', 'last_processed_sequence: int', \"projection_data: dict[str, 'ProtocolWorkflowValue']\", \"created_at: 'ProtocolDateTime'\", \"updated_at: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for event projection objects.')",
        "ProtocolInfo(name='ProtocolSemVer', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['__str__() -> str'], signature_hash='cc48dac04fbba2e2', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=13, is_runtime_checkable=True, domain='types', properties=['major: int', 'minor: int', 'patch: int'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for semantic version objects following SemVer specification.\\n\\n    Provides a structured approach to versioning with major, minor, and patch\\n    components. Used throughout ONEX for protocol versioning, dependency\\n    management, and compatibility checking.\\n\\n    Key Features:\\n        - Major version: Breaking changes\\n        - Minor version: Backward-compatible additions\\n        - Patch version: Backward-compatible fixes\\n        - String representation: \"major.minor.patch\" format\\n\\n    Usage:\\n        version = some_protocol_object.version\\n        if version.major >= 2:\\n            # Use new API features\\n        compatibility_string = str(version)  # \"2.1.3\"\\n    ')",
        "ProtocolInfo(name='ProtocolContextValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_for_context() -> bool', 'serialize_for_context() -> dict[str, object]', 'get_context_type_hint() -> str'], signature_hash='6b1f8bd6d2df4d1a', line_count=3, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=65, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for context data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolContextStringValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='849d56803e0c596f', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=82, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string-based context values (text data, identifiers, messages).')",
        "ProtocolInfo(name='ProtocolContextNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='f89fcc3cfbe329af', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=89, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for numeric context values (identifiers, counts, measurements, scores).')",
        "ProtocolInfo(name='ProtocolContextBooleanValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='cb088428d962237a', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=96, is_runtime_checkable=True, domain='types', properties=['value: bool'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for boolean context values (flags, status indicators).')",
        "ProtocolInfo(name='ProtocolContextStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='a291abcb24786518', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=103, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string list context values (identifiers, tags, categories).')",
        "ProtocolInfo(name='ProtocolContextStringDictValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='2c654b3c5a930766', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=110, is_runtime_checkable=True, domain='types', properties=['value: dict[str, str]'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string dictionary context values (key-value mappings, structured data).')",
        "ProtocolInfo(name='ProtocolSupportedMetadataType', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['__str__() -> str', 'validate_for_metadata() -> bool'], signature_hash='28773c15fb1950dd', line_count=3, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=120, is_runtime_checkable=True, domain='types', properties=['__omnibase_metadata_type_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for types that can be stored in ONEX metadata systems.\\n\\n    This marker protocol defines the contract for objects that can be safely\\n    stored, serialized, and retrieved from metadata storage systems. Objects\\n    implementing this protocol guarantee string convertibility for persistence.\\n\\n    Key Features:\\n        - Marker interface for metadata compatibility\\n        - String conversion guarantee\\n        - Runtime type checking support\\n        - Safe for serialization/deserialization\\n\\n    Usage:\\n        def store_metadata(key: str, value: \"ProtocolSupportedMetadataType\"):\\n            metadata_store[key] = str(value)\\n    ')",
        "ProtocolInfo(name='ProtocolConfigValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_config_value() -> bool', 'has_valid_default() -> bool'], signature_hash='8bc54144e93051ca', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=151, is_runtime_checkable=True, domain='types', properties=['key: str', 'value: ContextValue', \"config_type: Literal['string', 'int', 'float', 'bool', 'list']\", 'default_value: ContextValue | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for type-safe configuration values in ONEX systems.\\n\\n    Provides structured configuration management with type enforcement,\\n    default value handling, and validation support. Used for service\\n    configuration, node parameters, and runtime settings.\\n\\n    Key Features:\\n        - Typed configuration values (string, int, float, bool, list)\\n        - Default value support for fallback behavior\\n        - Key-value structure for configuration management\\n        - Type validation and conversion support\\n\\n    Usage:\\n        config = ProtocolConfigValue(\\n            key=\"max_retries\",\\n            value=3,\\n            config_type=\"int\",\\n            default_value=1\\n        )\\n    ')",
        "ProtocolInfo(name='ProtocolLogContext', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[\"to_dict() -> dict[str, 'ContextValue']\"], signature_hash='048198a88f2f3bf7', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=189, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured logging context objects.\\n\\n    Provides standardized context information for distributed logging\\n    across ONEX services. Context objects carry metadata, correlation\\n    IDs, and structured data for observability and debugging.\\n\\n    Key Features:\\n        - Structured context data with type safety\\n        - Dictionary conversion for serialization\\n        - Compatible with typed ContextValue constraints\\n        - Supports distributed tracing and correlation\\n\\n    Usage:\\n        context = create_log_context()\\n        logger.info(\"Operation completed\", context=context.to_dict())\\n    ')",
        "ProtocolInfo(name='ProtocolLogEntry', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_log_entry() -> bool', 'is_complete() -> bool'], signature_hash='feb28e942088e7f9', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=220, is_runtime_checkable=True, domain='types', properties=['level: LiteralLogLevel', 'message: str', 'correlation_id: UUID', \"timestamp: 'ProtocolDateTime'\", \"context: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured log entry objects in ONEX systems.\\n\\n    Standardizes log entries across all ONEX services with consistent\\n    structure for level, messaging, correlation tracking, and context.\\n    Essential for distributed system observability and debugging.\\n\\n    Key Features:\\n        - Standardized log levels (TRACE through FATAL)\\n        - Correlation ID for distributed tracing\\n        - Structured context with type safety\\n        - Timestamp for chronological ordering\\n\\n    Usage:\\n        entry = create_log_entry(\\n            level=\"INFO\",\\n            message=\"User authenticated successfully\",\\n            correlation_id=request.correlation_id,\\n            context={\"user_id\": user.id, \"action\": \"login\"}\\n        )\\n    ')",
        "ProtocolInfo(name='ProtocolSerializationResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_serialization() -> bool', 'has_data() -> bool'], signature_hash='8a4f553033958959', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=259, is_runtime_checkable=True, domain='types', properties=['success: bool', 'data: str', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for serialization operation results.\\n\\n    Provides standardized results for serialization operations across\\n    ONEX services, including success status, serialized data, and\\n    error handling information.\\n\\n    Key Features:\\n        - Success/failure indication\\n        - Serialized data as string format\\n        - Detailed error messages for debugging\\n        - Consistent result structure across services\\n\\n    Usage:\\n        result = serializer.serialize(data)\\n        if result.success:\\n            send_data(result.data)\\n        else:\\n            logger.error(f\"Serialization failed: {result.error_message}\")\\n    ')",
        "ProtocolInfo(name='ProtocolNodeMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_node_metadata() -> bool', 'is_complete() -> bool'], signature_hash='495b508622cf3cd0', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=295, is_runtime_checkable=True, domain='types', properties=['node_id: str', 'node_type: str', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX node metadata objects.\\n\\n    Defines the essential metadata structure for nodes in the ONEX\\n    distributed system, including identification, type classification,\\n    and extensible metadata storage.\\n\\n    Key Features:\\n        - Unique node identification\\n        - Node type classification (COMPUTE, EFFECT, REDUCER, ORCHESTRATOR)\\n        - Extensible metadata dictionary with type safety\\n        - Runtime node introspection support\\n\\n    Usage:\\n        metadata = node.get_metadata()\\n        if metadata.node_type == \"COMPUTE\":\\n            schedule_computation_task(metadata.node_id)\\n    ')",
        "ProtocolInfo(name='ProtocolCacheStatistics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_statistics() -> bool', 'is_current() -> bool'], signature_hash='2f5e903e3ce6e823', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=329, is_runtime_checkable=True, domain='types', properties=['hit_count: int', 'miss_count: int', 'total_requests: int', 'hit_ratio: float', 'memory_usage_bytes: int', 'entry_count: int', 'eviction_count: int', 'last_accessed: datetime | None', 'cache_size_limit: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive cache service statistics.\\n\\n    Provides detailed performance and usage metrics for cache services\\n    across ONEX systems. Used for monitoring, optimization, and capacity\\n    planning of distributed caching infrastructure.\\n\\n    Key Features:\\n        - Performance metrics (hits, misses, ratios)\\n        - Resource usage tracking (memory, entry counts)\\n        - Operational statistics (evictions, access patterns)\\n        - Capacity management information\\n\\n    Metrics Description:\\n        - hit_count: Number of successful cache retrievals\\n        - miss_count: Number of cache misses requiring data source access\\n        - hit_ratio: Efficiency ratio (hits / total_requests)\\n        - memory_usage_bytes: Current memory consumption\\n        - entry_count: Number of cached entries\\n        - eviction_count: Number of entries removed due to capacity limits\\n        - last_accessed: Timestamp of most recent cache access\\n        - cache_size_limit: Maximum cache capacity (if configured)\\n\\n    Usage:\\n        stats = cache_service.get_statistics()\\n        if stats.hit_ratio < 0.8:\\n            logger.warning(f\"Low cache hit ratio: {stats.hit_ratio:.2%}\")\\n    ')",
        "ProtocolInfo(name='ProtocolMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metadata() -> bool', 'is_up_to_date() -> bool'], signature_hash='245034e1e7cc70b8', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=393, is_runtime_checkable=True, domain='types', properties=[\"data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", \"created_at: 'ProtocolDateTime'\", \"updated_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for structured metadata - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolMetadataOperations', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['get_value(key: str) -> ContextValue', 'has_key(key: str) -> bool', 'keys() -> list[str]', 'update_value(key: str, value: ContextValue) -> None'], signature_hash='82b986211bb98771', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=411, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for metadata operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolActionPayload', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_payload() -> bool', 'has_valid_parameters() -> bool'], signature_hash='cb730f6304cd7ba4', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=424, is_runtime_checkable=True, domain='types', properties=['target_id: str', 'operation: str', \"parameters: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for action payload with specific data.')",
        "ProtocolInfo(name='ProtocolAction', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_action() -> bool', 'is_executable() -> bool'], signature_hash='832a76a2dd18acc1', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=441, is_runtime_checkable=True, domain='types', properties=['type: str', \"payload: 'ProtocolActionPayload'\", \"timestamp: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for reducer actions.')",
        "ProtocolInfo(name='ProtocolState', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_state() -> bool', 'is_consistent() -> bool'], signature_hash='0279e1f59cf90550', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=458, is_runtime_checkable=True, domain='types', properties=[\"metadata: 'ProtocolMetadata'\", 'version: int', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for reducer state.')",
        "ProtocolInfo(name='ProtocolNodeMetadataBlock', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metadata_block() -> bool', 'is_complete() -> bool'], signature_hash='77307ca8a8909125', line_count=12, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=475, is_runtime_checkable=True, domain='types', properties=['uuid: str', 'name: str', 'description: str', \"version: 'ProtocolSemVer'\", \"metadata_version: 'ProtocolSemVer'\", 'namespace: str', \"created_at: 'ProtocolDateTime'\", \"last_modified_at: 'ProtocolDateTime'\", 'lifecycle: str', \"protocol_version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for node metadata block objects.')",
        "ProtocolInfo(name='ProtocolSchemaObject', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_schema() -> bool', 'is_valid_schema() -> bool'], signature_hash='31995d0b18265d88', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=499, is_runtime_checkable=True, domain='types', properties=['schema_id: str', 'schema_type: str', \"schema_data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", 'is_valid: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for schema data objects.')",
        "ProtocolInfo(name='ProtocolErrorInfo', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error_info() -> bool', 'is_retryable() -> bool'], signature_hash='680155ab21f6d6c1', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=518, is_runtime_checkable=True, domain='types', properties=['error_type: str', 'message: str', 'trace: str | None', 'retryable: bool', 'backoff_strategy: str | None', 'max_attempts: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive error information in workflow results.\\n\\n    Provides detailed error context for workflow operations, including\\n    recovery strategies and retry configuration. Essential for resilient\\n    distributed system operation and automated error recovery.\\n\\n    Key Features:\\n        - Error type classification for automated handling\\n        - Human-readable error messages\\n        - Stack trace information for debugging\\n        - Retry configuration and backoff strategies\\n\\n    Usage:\\n        error_info = ProtocolErrorInfo(\\n            error_type=\"TimeoutError\",\\n            message=\"Operation timed out after 30 seconds\",\\n            trace=traceback.format_exc(),\\n            retryable=True,\\n            backoff_strategy=\"exponential\",\\n            max_attempts=3\\n        )\\n\\n        if error_info.retryable:\\n            schedule_retry(operation, error_info.backoff_strategy)\\n    ')",
        "ProtocolInfo(name='ProtocolSystemEvent', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_system_event() -> bool', 'is_well_formed() -> bool'], signature_hash='b752fe1c319e9dea', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=563, is_runtime_checkable=True, domain='types', properties=['type: str', \"payload: dict[str, 'ContextValue']\", 'timestamp: float', 'source: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for system events.')",
        "ProtocolInfo(name='ProtocolNodeResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_result() -> bool', 'is_successful() -> bool'], signature_hash='a62b9df48dec3712', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=581, is_runtime_checkable=True, domain='types', properties=['value: ContextValue | None', 'is_success: bool', 'is_failure: bool', \"error: 'ProtocolErrorInfo | None'\", 'trust_score: float', 'provenance: list[str]', \"metadata: dict[str, 'ContextValue']\", \"events: list['ProtocolSystemEvent']\", \"state_delta: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive node processing results with monadic composition.\\n\\n    Provides rich result information for ONEX node operations, including\\n    success/failure indication, error details, trust scores, provenance\\n    tracking, and state changes. Enables sophisticated result composition\\n    and error handling in distributed workflows.\\n\\n    Key Features:\\n        - Monadic success/failure patterns\\n        - Trust scoring for result confidence\\n        - Provenance tracking for data lineage\\n        - Event emission for observability\\n        - State delta tracking for reducers\\n\\n    Usage:\\n        result = node.process(input_data)\\n\\n        # Monadic composition patterns\\n        if result.is_success:\\n            next_result = next_node.process(result.value)\\n        else:\\n            handle_error(result.error)\\n\\n        # Trust evaluation\\n        if result.trust_score > 0.8:\\n            accept_result(result.value)\\n\\n        # State management\\n        for key, value in result.state_delta.items():\\n            state_manager.update(key, value)\\n    ')",
        "ProtocolInfo(name='ProtocolServiceMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_service_metadata() -> bool', 'has_capabilities() -> bool'], signature_hash='b1aee76ad9021d1c', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=635, is_runtime_checkable=True, domain='types', properties=[\"data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", 'capabilities: list[str]', 'tags: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for service metadata.')",
        "ProtocolInfo(name='ProtocolServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_service_instance() -> bool', 'is_available() -> bool'], signature_hash='73baf0b1e58c6c4a', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=653, is_runtime_checkable=True, domain='types', properties=['service_id: str', 'service_name: str', 'host: str', 'port: int', \"metadata: 'ProtocolServiceMetadata'\", \"health_status: 'LiteralHealthStatus'\", \"last_seen: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service instance information.')",
        "ProtocolInfo(name='ProtocolServiceHealthStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_status() -> bool', 'is_healthy() -> bool'], signature_hash='42b56f0e9021ed60', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=674, is_runtime_checkable=True, domain='types', properties=['service_id: str', \"status: 'LiteralHealthStatus'\", \"last_check: 'ProtocolDateTime'\", \"details: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service health status.')",
        "ProtocolInfo(name='ProtocolCheckpointData', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_checkpoint() -> bool', 'is_restorable() -> bool'], signature_hash='7223da7f1490789d', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=692, is_runtime_checkable=True, domain='types', properties=['checkpoint_id: str', 'workflow_id: str', \"data: dict[str, 'ContextValue']\", \"timestamp: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for checkpoint data.')",
        "ProtocolInfo(name='ProtocolStorageCredentials', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_credentials() -> bool', 'is_secure() -> bool'], signature_hash='51b10e3d705e58a8', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=711, is_runtime_checkable=True, domain='types', properties=['credential_type: str', \"data: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for storage credentials.')",
        "ProtocolInfo(name='ProtocolStorageConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_configuration() -> bool', 'is_connectable() -> bool'], signature_hash='7d97bead057300b5', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=727, is_runtime_checkable=True, domain='types', properties=['backend_type: str', 'connection_string: str', \"options: dict[str, 'ContextValue']\", 'timeout_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage configuration.')",
        "ProtocolInfo(name='ProtocolStorageResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_storage_result() -> bool', 'is_successful() -> bool'], signature_hash='6c3fdcd9705c8c1e', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=745, is_runtime_checkable=True, domain='types', properties=['success: bool', \"data: dict[str, 'ContextValue'] | None\", 'error_message: str | None', 'operation_id: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage operation results.')",
        "ProtocolInfo(name='ProtocolStorageListResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_list_result() -> bool', 'has_items() -> bool'], signature_hash='44dc4baf79fa61e8', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=763, is_runtime_checkable=True, domain='types', properties=['success: bool', \"items: list[dict[str, 'ContextValue']]\", 'total_count: int', 'has_more: bool', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage list operation results.')",
        "ProtocolInfo(name='ProtocolStorageHealthStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_status() -> bool', 'is_available() -> bool'], signature_hash='0f17075a95e52338', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=782, is_runtime_checkable=True, domain='types', properties=['is_healthy: bool', \"status_details: dict[str, 'ContextValue']\", 'capacity_info: dict[str, int] | None', \"last_check: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for storage health status.')",
        "ProtocolInfo(name='ProtocolErrorContext', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error_context() -> bool', 'has_trace() -> bool'], signature_hash='fc1a9aeb45cd278f', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=806, is_runtime_checkable=True, domain='types', properties=['correlation_id: UUID', 'operation_name: str', \"timestamp: 'ProtocolDateTime'\", \"context_data: dict[str, 'ContextValue']\", 'stack_trace: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for error context information.')",
        "ProtocolInfo(name='ProtocolRecoveryAction', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_recovery_action() -> bool', 'is_applicable() -> bool'], signature_hash='b4dd10f32844736f', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=825, is_runtime_checkable=True, domain='types', properties=['action_type: LiteralErrorRecoveryStrategy', 'max_attempts: int', 'backoff_multiplier: float', 'timeout_seconds: int', 'fallback_value: ContextValue | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery action information.')",
        "ProtocolInfo(name='ProtocolErrorResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error() -> bool', 'is_retryable() -> bool'], signature_hash='f43b00e5185a7d46', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=844, is_runtime_checkable=True, domain='types', properties=['error_id: UUID', 'error_type: str', 'message: str', 'severity: LiteralErrorSeverity', 'retryable: bool', \"recovery_action: 'ProtocolRecoveryAction | None'\", \"context: 'ProtocolErrorContext'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized error results.')",
        "ProtocolInfo(name='ProtocolVersionInfo', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_version_info() -> bool', 'is_compatible() -> bool'], signature_hash='782e1803abae123e', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=865, is_runtime_checkable=True, domain='types', properties=['protocol_name: str', \"version: 'ProtocolSemVer'\", \"compatibility_version: 'ProtocolSemVer'\", \"retirement_date: 'ProtocolDateTime | None'\", 'migration_guide_url: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for version metadata.')",
        "ProtocolInfo(name='ProtocolCompatibilityCheck', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_compatibility() -> bool'], signature_hash='28b79d0845287353', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=884, is_runtime_checkable=True, domain='types', properties=['is_compatible: bool', \"required_version: 'ProtocolSemVer'\", \"current_version: 'ProtocolSemVer'\", 'breaking_changes: list[str]', 'migration_required: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for compatibility checking results.')",
        "ProtocolInfo(name='ProtocolNodeInfoLike', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='d5989275e9c8cfce', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=908, is_runtime_checkable=True, domain='types', properties=['__omnibase_node_info_marker__: Literal[True]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for objects that can provide ONEX node information.\\n\\n    This marker protocol defines the minimal interface that objects\\n    must implement to be compatible with node metadata processing\\n    and discovery systems. Objects implementing this protocol can be\\n    safely converted to ModelNodeMetadataInfo instances.\\n\\n    Key Features:\\n        - Marker interface for node information compatibility\\n        - Runtime type checking with sentinel attribute\\n        - Safe conversion to node metadata structures\\n        - Compatibility with node discovery and registry systems\\n\\n    Usage:\\n        def process_node_info(info: \"ProtocolNodeInfoLike\"):\\n            if isinstance(info, ProtocolNodeInfoLike):\\n                metadata = convert_to_node_metadata(info)\\n                register_node(metadata)\\n\\n    This is a marker interface with a sentinel attribute for runtime checks.\\n    ')",
        "ProtocolInfo(name='ProtocolSupportedPropertyValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_for_property() -> bool'], signature_hash='f90b560449c5709f', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=936, is_runtime_checkable=True, domain='types', properties=['__omnibase_property_value_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for values that can be stored as ONEX property values.\\n\\n    This marker protocol defines the minimal interface that property values\\n    must implement to be compatible with the ONEX property system.\\n    Properties are used for node configuration, service parameters,\\n    and dynamic system settings.\\n\\n    Key Features:\\n        - Marker interface for property value compatibility\\n        - Runtime type checking with sentinel attribute\\n        - Safe storage in property management systems\\n        - Compatible with configuration and parameter systems\\n\\n    Usage:\\n        def set_property(key: str, value: \"ProtocolSupportedPropertyValue\"):\\n            if isinstance(value, ProtocolSupportedPropertyValue):\\n                property_store[key] = value\\n            else:\\n                raise TypeError(\"Value not compatible with property system\")\\n\\n    This is a marker interface with a sentinel attribute for runtime checks.\\n    ')",
        "ProtocolInfo(name='ProtocolHealthMetrics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metrics() -> bool', 'is_within_thresholds() -> bool'], signature_hash='65d6c20642b0b242', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=969, is_runtime_checkable=True, domain='types', properties=['response_time_ms: float', 'cpu_usage_percent: float', 'memory_usage_percent: float', 'disk_usage_percent: float', 'connection_count: int', 'error_rate_percent: float', 'throughput_per_second: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for health check metrics.')",
        "ProtocolInfo(name='ProtocolHealthCheck', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_check() -> bool', 'is_passing() -> bool'], signature_hash='8b43a942cb928a1d', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=990, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'check_level: LiteralHealthCheckLevel', 'dimensions_checked: list[LiteralHealthDimension]', \"overall_status: 'LiteralHealthStatus'\", \"individual_checks: dict[str, 'LiteralHealthStatus']\", \"metrics: 'ProtocolHealthMetrics'\", 'check_duration_ms: float', \"timestamp: 'ProtocolDateTime'\", 'recommendations: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized health checks.')",
        "ProtocolInfo(name='ProtocolHealthMonitoring', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_monitoring_config() -> bool', 'is_reasonable() -> bool'], signature_hash='61110f258afbd769', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1013, is_runtime_checkable=True, domain='types', properties=['check_interval_seconds: int', 'timeout_seconds: int', 'failure_threshold: int', 'recovery_threshold: int', \"alert_on_status: list['LiteralHealthStatus']\", \"escalation_rules: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for health monitoring configuration.')",
        "ProtocolInfo(name='ProtocolMetricsPoint', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metrics_point() -> bool', 'is_valid_measurement() -> bool'], signature_hash='729bb73a03d389d3', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1033, is_runtime_checkable=True, domain='types', properties=['metric_name: str', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", \"tags: dict[str, 'ContextValue']\", \"dimensions: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual metrics points.')",
        "ProtocolInfo(name='ProtocolTraceSpan', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_trace_span() -> bool', 'is_complete() -> bool'], signature_hash='bc372986e988c520', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1053, is_runtime_checkable=True, domain='types', properties=['span_id: UUID', 'trace_id: UUID', 'parent_span_id: UUID | None', 'operation_name: str', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'status: LiteralOperationStatus', \"tags: dict[str, 'ContextValue']\", \"logs: list[dict[str, 'ContextValue']]\"], base_protocols=[], protocol_type='functional', docstring='Protocol for distributed tracing spans.')",
        "ProtocolInfo(name='ProtocolAuditEvent', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_audit_event() -> bool', 'is_complete() -> bool'], signature_hash='eefbfe460bf98aab', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1076, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: str', 'actor: str', 'resource: str', 'action: str', \"timestamp: 'ProtocolDateTime'\", 'outcome: LiteralOperationStatus', \"metadata: dict[str, 'ContextValue']\", \"sensitivity_level: Literal['public', 'internal', 'confidential', 'restricted']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for audit events.')",
        "ProtocolInfo(name='ProtocolSerializable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['model_dump() -> dict[str, str | int | float | bool | list[str | int | float | bool] | dict[str, str | int | float | bool]]'], signature_hash='2194795f8f448463', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1099, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for objects that can be serialized to dictionary format.\\n\\n    Provides standardized serialization contract for ONEX objects that need\\n    to be persisted, transmitted, or cached. The model_dump method ensures\\n    consistent serialization across all ONEX services.\\n\\n    Key Features:\\n        - Standardized serialization interface\\n        - Type-safe dictionary output\\n        - Compatible with JSON serialization\\n        - Consistent across all ONEX services\\n\\n    Usage:\\n        class MyDataObject(ProtocolSerializable):\\n            def model_dump(self) -> dict[str, Any]:\\n                return {\\n                    \"id\": self.id,\\n                    \"name\": self.name,\\n                    \"active\": self.is_active\\n                }\\n\\n        # Serialize for storage\\n        obj = MyDataObject()\\n        serialized = obj.model_dump()\\n        json.dumps(serialized)  # Safe for JSON\\n    ')",
        "ProtocolInfo(name='ProtocolIdentifiable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['id() -> str'], signature_hash='4ade353d3e18ab35', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1144, is_runtime_checkable=True, domain='types', properties=['__omnibase_identifiable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that have an ID.')",
        "ProtocolInfo(name='ProtocolNameable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['name() -> str'], signature_hash='d09ed77d70c89dfa', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1156, is_runtime_checkable=True, domain='types', properties=['__omnibase_nameable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that have a name.')",
        "ProtocolInfo(name='ProtocolConfigurable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['configure() -> None'], signature_hash='e5ad392e3eda865c', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1168, is_runtime_checkable=True, domain='types', properties=['__omnibase_configurable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that can be configured.')",
        "ProtocolInfo(name='ProtocolExecutable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['async execute() -> object'], signature_hash='ad183ce51a769d3c', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1179, is_runtime_checkable=True, domain='types', properties=['__omnibase_executable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that can be executed.')",
        "ProtocolInfo(name='ProtocolMetadataProvider', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['get_metadata() -> dict[str, str | int | bool | float]'], signature_hash='09e352a679bc8db7', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1190, is_runtime_checkable=True, domain='types', properties=['__omnibase_metadata_provider_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that provide metadata.')",
        "ProtocolInfo(name='ProtocolRetryConfig', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_config() -> bool', 'is_reasonable() -> bool'], signature_hash='83505052f95cfc1f', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1209, is_runtime_checkable=True, domain='types', properties=['max_attempts: int', 'backoff_strategy: LiteralRetryBackoffStrategy', 'base_delay_ms: int', 'max_delay_ms: int', 'timeout_ms: int', 'jitter_factor: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry configuration.')",
        "ProtocolInfo(name='ProtocolRetryPolicy', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_policy() -> bool', 'is_applicable() -> bool'], signature_hash='ee495f9df144b7bf', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1229, is_runtime_checkable=True, domain='types', properties=[\"default_config: 'ProtocolRetryConfig'\", \"error_specific_configs: dict[str, 'ProtocolRetryConfig']\", 'retry_conditions: list[LiteralRetryCondition]', 'retry_budget_limit: int', 'budget_window_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry policy configuration.')",
        "ProtocolInfo(name='ProtocolRetryAttempt', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_attempt() -> bool', 'is_valid_attempt() -> bool'], signature_hash='373a45903ee26931', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1248, is_runtime_checkable=True, domain='types', properties=['attempt_number: int', \"timestamp: 'ProtocolDateTime'\", 'duration_ms: int', 'error_type: str | None', 'success: bool', 'backoff_applied_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry attempt records.')",
        "ProtocolInfo(name='ProtocolRetryResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_result() -> bool', 'is_final() -> bool'], signature_hash='df2341715f633f5e', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1268, is_runtime_checkable=True, domain='types', properties=['success: bool', 'final_attempt_number: int', 'total_duration_ms: int', 'result: ContextValue | None', 'final_error: Exception | None', \"attempts: list['ProtocolRetryAttempt']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for retry operation results.')",
        "ProtocolInfo(name='ProtocolTimeBased', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_time_based() -> bool', 'is_valid_timing() -> bool'], signature_hash='da50e80e208aaa84', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1291, is_runtime_checkable=True, domain='types', properties=['type: LiteralTimeBasedType', \"start_time: 'ProtocolDateTime | None'\", \"end_time: 'ProtocolDateTime | None'\", 'duration_ms: int | None', 'is_active: bool', 'has_expired: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for time-based operations and measurements.')",
        "ProtocolInfo(name='ProtocolTimeout', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_timeout() -> bool', 'is_reasonable() -> bool'], signature_hash='4722c52e37708b1b', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1311, is_runtime_checkable=True, domain='types', properties=['timeout_ms: int', \"start_time: 'ProtocolDateTime'\", 'warning_threshold_ms: int | None', 'is_expired: bool', 'time_remaining_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for timeout configuration and tracking.')",
        "ProtocolInfo(name='ProtocolDuration', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_duration() -> bool', 'is_measurable() -> bool'], signature_hash='860389bc949e5ae4', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1330, is_runtime_checkable=True, domain='types', properties=[\"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'duration_ms: int', 'is_completed: bool', 'can_measure: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for duration measurement and tracking.')",
        "ProtocolInfo(name='ProtocolAnalyticsMetric', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metric() -> bool', 'is_valid_measurement() -> bool'], signature_hash='0f4df50ca3878e9b', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1355, is_runtime_checkable=True, domain='types', properties=['name: str', 'type: LiteralAnalyticsMetricType', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", \"tags: dict[str, 'ContextValue']\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual analytics metrics.')",
        "ProtocolInfo(name='ProtocolAnalyticsProvider', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_provider() -> bool', 'is_available() -> bool'], signature_hash='261c94c68e2d6f26', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1376, is_runtime_checkable=True, domain='types', properties=['provider_id: str', 'provider_type: str', 'data_sources: list[str]', 'supported_metrics: list[str]', 'time_windows: list[LiteralAnalyticsTimeWindow]', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for analytics data providers.')",
        "ProtocolInfo(name='ProtocolAnalyticsSummary', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_summary() -> bool', 'is_complete() -> bool'], signature_hash='a69462ab685daa89', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1396, is_runtime_checkable=True, domain='types', properties=['time_window: LiteralAnalyticsTimeWindow', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime'\", \"metrics: list['ProtocolAnalyticsMetric']\", 'insights: list[str]', 'recommendations: list[str]', 'confidence_score: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for analytics summary reports.')",
        "ProtocolInfo(name='ProtocolPerformanceMetric', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_performance_metric() -> bool', 'is_valid() -> bool'], signature_hash='a46f75708493b11f', line_count=10, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1422, is_runtime_checkable=True, domain='types', properties=['metric_name: str', 'category: LiteralPerformanceCategory', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'threshold_warning: float | None', 'threshold_critical: float | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for performance metric data points.')",
        "ProtocolInfo(name='ProtocolPerformanceMetrics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_performance_metrics() -> bool', 'is_healthy() -> bool'], signature_hash='d9eedd7e0fa176f0', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1444, is_runtime_checkable=True, domain='types', properties=['service_name: str', \"collection_timestamp: 'ProtocolDateTime'\", \"metrics: list['ProtocolPerformanceMetric']\", 'overall_health_score: float', 'performance_trends: dict[str, float]', 'recommendations: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for performance metrics collection.')",
        "ProtocolInfo(name='ProtocolConnectionConfig', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_connection_config() -> bool', 'is_connectable() -> bool'], signature_hash='6483622eaad6a92f', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1469, is_runtime_checkable=True, domain='types', properties=['host: str', 'port: int', 'timeout_ms: int', 'max_retries: int', 'ssl_enabled: bool', 'connection_pool_size: int', 'keep_alive_interval_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for connection configuration.')",
        "ProtocolInfo(name='ProtocolConnectionStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_connection_status() -> bool', 'is_connected() -> bool'], signature_hash='6ba7394d00462afc', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1490, is_runtime_checkable=True, domain='types', properties=['state: LiteralConnectionState', \"connected_at: 'ProtocolDateTime | None'\", \"last_activity: 'ProtocolDateTime | None'\", 'error_count: int', 'bytes_sent: int', 'bytes_received: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for connection status tracking.')",
        "ProtocolInfo(name='ProtocolValidatable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[\"async get_validation_context() -> dict[str, 'ContextValue']\", 'get_validation_id() -> str'], signature_hash='c1b954e7dcd3b2dc', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1516, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Base protocol for objects that can be validated.\\n\\n    This protocol defines the minimal interface that validation targets\\n    should implement to provide context and metadata for validation\\n    operations. By implementing this protocol, objects become compatible\\n    with the ONEX validation framework while maintaining type safety.\\n\\n    Key Features:\\n        - Validation context extraction for rule applicability\\n        - Object identification for validation reporting\\n        - Type safety for validation operations\\n        - Minimal interface requirements for broad compatibility\\n\\n    Usage:\\n        class ConfigurationData(ProtocolValidatable):\\n            def get_validation_context(self) -> dict[str, \"ContextValue\"]:\\n                return {\"type\": \"config\", \"version\": self.version}\\n\\n            def get_validation_id(self) -> str:\\n                return f\"config_{self.name}\"\\n    ')",
        "ProtocolInfo(name='ProtocolFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=['validate_for_file() -> bool', 'serialize_for_file() -> dict[str, object]', 'get_file_content_type_hint() -> str'], signature_hash='7f2329c2fed359c2', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=22, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for file content values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolStringFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='d48ec186b880a7f3', line_count=1, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=39, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolFileContent'], protocol_type='property_only', docstring='Protocol for string-based file content (text files).')",
        "ProtocolInfo(name='ProtocolBinaryFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='933dbdd6f8a0690f', line_count=1, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=46, is_runtime_checkable=True, domain='types', properties=['value: bytes'], base_protocols=['ProtocolFileContent'], protocol_type='property_only', docstring='Protocol for binary file content (binary files).')",
        "ProtocolInfo(name='ProtocolFileMetadata', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='1386e3589dd98a83', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=56, is_runtime_checkable=True, domain='types', properties=['size: int', 'mime_type: str', 'encoding: str | None', 'created_at: float', 'modified_at: float'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file metadata - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolFileInfo', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='1d2b137c5c4ad9cc', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=67, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'file_size: int', 'file_type: str', 'mime_type: str', 'last_modified: float', 'status: LiteralFileStatus'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file information objects.')",
        "ProtocolInfo(name='ProtocolFileContentObject', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='aaa61a009ae95ffc', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=79, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'content: FileContent', 'encoding: str | None', 'content_hash: str', 'is_binary: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file content objects.')",
        "ProtocolInfo(name='ProtocolProcessingResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='5ef9fc17d9046c1c', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=90, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'operation: LiteralFileOperation', 'status: ProcessingStatus', 'processing_time: float', 'error_message: str | None', \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for file processing results.')",
        "ProtocolInfo(name='ProtocolFileFilter', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='9440bb39f7e39995', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=102, is_runtime_checkable=True, domain='types', properties=['include_extensions: list[str]', 'exclude_extensions: list[str]', 'min_size: int | None', 'max_size: int | None', 'modified_after: float | None', 'modified_before: float | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file filtering criteria.')",
        "ProtocolInfo(name='ProtocolFileTypeResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='c70a1bc55236d023', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=114, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'detected_type: str', 'confidence: float', 'mime_type: str', 'is_supported: bool', 'error_message: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file type detection results.')",
        "ProtocolInfo(name='ProtocolHandlerMatch', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='3505eb9894143073', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=126, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'node_name: str', 'match_confidence: float', 'can_handle: bool', 'required_capabilities: list[str]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node matching results.')",
        "ProtocolInfo(name='ProtocolCanHandleResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='505ca7a6523b5787', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=137, is_runtime_checkable=True, domain='types', properties=['can_handle: bool', 'confidence: float', 'reason: str', \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for can handle determination results.')",
        "ProtocolInfo(name='ProtocolHandlerMetadata', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='15d5b4dbccf23ec9', line_count=8, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=147, is_runtime_checkable=True, domain='types', properties=['name: str', \"version: 'ProtocolSemVer'\", 'author: str', 'description: str', 'supported_extensions: list[str]', 'supported_filenames: list[str]', 'priority: int', 'requires_content_analysis: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node metadata.')",
        "ProtocolInfo(name='ProtocolExtractedBlock', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='8111b64e4c7627a4', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=161, is_runtime_checkable=True, domain='types', properties=['content: str', \"file_metadata: 'ProtocolFileMetadata'\", 'block_type: str', 'start_line: int | None', 'end_line: int | None', 'path: str'], base_protocols=[], protocol_type='property_only', docstring='Protocol for extracted block data.')",
        "ProtocolInfo(name='ProtocolSerializedBlock', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='513ac8a7aa3f7e25', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=173, is_runtime_checkable=True, domain='types', properties=['serialized_data: str', 'format: str', \"version: 'ProtocolSemVer'\", \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for serialized block data.')",
        "ProtocolInfo(name='ProtocolResultData', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='14bdc784ff71a3f1', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=183, is_runtime_checkable=True, domain='types', properties=['output_path: str | None', 'processed_files: list[str]', 'metrics: dict[str, float]', 'warnings: list[str]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for operation result data - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolOnexResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='0509105a0b315a66', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=193, is_runtime_checkable=True, domain='types', properties=['success: bool', 'message: str', \"result_data: 'ProtocolResultData | None'\", 'error_code: str | None', \"timestamp: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for ONEX operation results.')",
        "ProtocolInfo(name='ProtocolFileMetadataOperations', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[\"async validate_metadata(metadata: 'ProtocolFileMetadata') -> bool\", \"async serialize_metadata(metadata: 'ProtocolFileMetadata') -> str\", \"async compare_metadata(meta1: 'ProtocolFileMetadata', meta2: 'ProtocolFileMetadata') -> bool\"], signature_hash='eec733a0b369c2e4', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=204, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for file metadata operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolResultOperations', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[\"format_result(result: 'ProtocolOnexResult') -> str\", \"async merge_results(results: list['ProtocolOnexResult']) -> ProtocolOnexResult\", \"validate_result(result: 'ProtocolOnexResult') -> bool\"], signature_hash='3cefd1ede740f3b8', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=217, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for result operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolContainer', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['register(service_key: str, service_instance: object) -> None', 'get_service(service_key: str) -> object', 'has_service(service_key: str) -> bool', 'dispose() -> None'], signature_hash='f53b72d6a9e7fef6', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=26, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection containers.')",
        "ProtocolInfo(name='ProtocolDependencySpec', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='3195e6b9e7bf37c8', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['service_key: str', 'module_path: str', 'class_name: str', 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralDependencyScope', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency specification objects.')",
        "ProtocolInfo(name='ProtocolContainerServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['validate_service_instance() -> bool', 'is_ready_for_use() -> bool'], signature_hash='43bdde0bfbbebbfb', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=59, is_runtime_checkable=True, domain='types', properties=['service_key: str', 'instance_type: type', 'lifecycle: LiteralServiceLifecycle', 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection container service instance objects.')",
        "ProtocolInfo(name='ProtocolRegistryWrapper', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['get_service(service_key: str) -> object', 'get_node_version() -> ProtocolSemVer', 'list_services() -> list[str]'], signature_hash='d9bf89630dc42783', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=77, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for registry wrapper objects.')",
        "ProtocolInfo(name='ProtocolContainerResult', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='4bb61c3e67e30d67', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=94, is_runtime_checkable=True, domain='types', properties=[\"container: 'ProtocolContainer'\", \"registry: 'ProtocolRegistryWrapper'\", 'status: LiteralContainerStatus', 'error_message: str | None', 'services_registered: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for container creation results.')",
        "ProtocolInfo(name='ProtocolContainerToolInstance', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[\"async process(input_data: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\"], signature_hash='9d79cf2677f705f7', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=107, is_runtime_checkable=True, domain='types', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool instance objects in dependency injection container context.')",
        "ProtocolInfo(name='ProtocolContainerFactory', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['create_container() -> ProtocolContainer', \"create_registry_wrapper(container: 'ProtocolContainer') -> ProtocolRegistryWrapper\"], signature_hash='3124664c5a8a4eb0', line_count=2, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=123, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for container factory objects.')",
        "ProtocolInfo(name='ProtocolContainerServiceFactory', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[\"create_service(dependency_spec: 'ProtocolDependencySpec') -> ProtocolContainerServiceInstance\", \"validate_dependency(dependency_spec: 'ProtocolDependencySpec') -> bool\"], signature_hash='f1b3666a303a4196', line_count=2, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=138, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection container service factory objects.')",
        "ProtocolInfo(name='ProtocolContainerConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='e621ac1de983f2a9', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=155, is_runtime_checkable=True, domain='types', properties=['auto_registration: bool', 'lazy_loading: bool', 'validation_enabled: bool', 'cache_services: bool', \"configuration_overrides: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for container configuration objects.')",
        "ProtocolInfo(name='ProtocolEventData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_for_transport() -> bool', 'serialize_for_event() -> dict[str, object]', 'get_event_type_hint() -> str'], signature_hash='80e8597bc3304a1a', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=23, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for event data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolEventStringData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='25c2bb16e4c3b685', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string-based event data.')",
        "ProtocolInfo(name='ProtocolEventStringListData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='09a65ef82fdc01e5', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string list event data.')",
        "ProtocolInfo(name='ProtocolEventStringDictData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='5c565bc2260a5009', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=54, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string dictionary event data.')",
        "ProtocolInfo(name='ProtocolEvent', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_event() -> bool', 'has_required_fields() -> bool'], signature_hash='4ac8fbcb6e22c7d0', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=67, is_runtime_checkable=True, domain='types', properties=['event_type: str', \"event_data: dict[str, 'ProtocolEventData']\", 'correlation_id: UUID', \"timestamp: 'ProtocolDateTime'\", 'source: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for event objects.')",
        "ProtocolInfo(name='ProtocolEventResult', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_result() -> bool', 'is_successful() -> bool'], signature_hash='b414cd82a3bdd8ab', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=86, is_runtime_checkable=True, domain='types', properties=['success: bool', 'event_id: UUID', 'processing_time: float', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for event processing results.')",
        "ProtocolInfo(name='ProtocolSecurityContext', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_security_context() -> bool', 'is_authenticated() -> bool'], signature_hash='b589855d2da23fef', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=104, is_runtime_checkable=True, domain='types', properties=['user_id: str | None', 'permissions: list[str]', 'auth_status: LiteralAuthStatus', \"token_expires_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for security context objects.')",
        "ProtocolInfo(name='ProtocolEventSubscription', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_subscription() -> bool'], signature_hash='669b50dad05ec621', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=122, is_runtime_checkable=True, domain='types', properties=['event_type: str', 'subscriber_id: str', \"filter_criteria: dict[str, 'ContextValue']\", 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for event subscriptions.')",
        "ProtocolInfo(name='ProtocolOnexEvent', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_onex_event() -> bool', 'is_well_formed() -> bool'], signature_hash='6ed608742f7bba97', line_count=9, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=137, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: str', \"timestamp: 'ProtocolDateTime'\", 'source: str', \"payload: dict[str, 'ProtocolEventData']\", 'correlation_id: UUID', \"metadata: dict[str, 'ProtocolEventData']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for ONEX system events.')",
        "ProtocolInfo(name='ProtocolEventBusConnectionCredentials', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='885c82e8d507f54a', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=158, is_runtime_checkable=True, domain='types', properties=['username: str', 'password: str', 'host: str', 'port: int', 'virtual_host: str | None', 'connection_timeout: int', 'heartbeat: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for event bus connection credential models with connection parameters.')",
        "ProtocolInfo(name='ProtocolEventHeaders', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_headers() -> bool', 'has_required_headers() -> bool'], signature_hash='2ca7bb15f053696c', line_count=20, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=171, is_runtime_checkable=True, domain='types', properties=['content_type: str', 'correlation_id: UUID', 'message_id: UUID', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'event_type: str', \"schema_version: 'ProtocolSemVer'\", 'destination: str | None', 'trace_id: str | None', 'span_id: str | None', 'parent_span_id: str | None', 'operation_name: str | None', \"priority: 'LiteralEventPriority | None'\", 'routing_key: str | None', 'partition_key: str | None', 'retry_count: int | None', 'max_retries: int | None', 'ttl_seconds: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX event bus message headers.\\n\\n    Standardized headers for ONEX event bus messages ensuring strict\\n    interoperability across all agents and preventing integration failures.\\n    ')",
        "ProtocolInfo(name='ProtocolEventMessage', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['async ack() -> None'], signature_hash='2b90dec2a599d7b5', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=211, is_runtime_checkable=True, domain='types', properties=['topic: str', 'key: MessageKey', 'value: bytes', \"headers: 'ProtocolEventHeaders'\", 'offset: str | None', 'partition: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX event bus message objects.\\n\\n    Defines the contract that all event message implementations must satisfy\\n    for Kafka/RedPanda compatibility following ONEX Messaging Design.\\n    ')",
        "ProtocolInfo(name='ProtocolCompletionData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['to_event_kwargs() -> dict[str, str | bool | int | list[str]]'], signature_hash='f5258530ffbadf95', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=232, is_runtime_checkable=True, domain='types', properties=['message: str | None', 'success: bool | None', 'code: int | None', 'tags: list[str] | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for completion event data following ONEX naming conventions.\\n\\n    Defines structure for completion event payloads with optional fields\\n    so producers can send only relevant data.\\n    ')",
        "ProtocolInfo(name='ProtocolCapabilityValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=['validate_for_capability() -> bool', 'serialize_for_capability() -> dict[str, object]', 'get_capability_type_hint() -> str'], signature_hash='a077087a2f380033', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=23, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for capability data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolCapabilityStringValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='c6b84a9b85a93955', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for string-based capability values (names, descriptions, IDs).')",
        "ProtocolInfo(name='ProtocolCapabilityNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='e4a8a368d64912e6', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for numeric capability values (counts, measurements, scores).')",
        "ProtocolInfo(name='ProtocolCapabilityBooleanValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='c14c2e6d820cb529', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=54, is_runtime_checkable=True, domain='types', properties=['value: bool'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for boolean capability values (flags, enabled/disabled).')",
        "ProtocolInfo(name='ProtocolCapabilityStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='54fa72aabd9bd7ce', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=61, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for string list capability values (tags, categories, identifiers).')",
        "ProtocolInfo(name='ProtocolHandlerCapability', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='50104c43c7094989', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=73, is_runtime_checkable=True, domain='types', properties=['capability_name: str', 'capability_value: CapabilityValue', 'is_required: bool', \"version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for node capability objects.')",
        "ProtocolInfo(name='ProtocolDiscoveryNodeInfo', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='5a4555469d01eb80', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=83, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'node_name: str', 'node_type: str', 'status: LiteralHandlerStatus', 'capabilities: list[str]', 'metadata: dict[str, CapabilityValue]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery node information objects with handler status.')",
        "ProtocolInfo(name='ProtocolDiscoveryQuery', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='7f110fa56adaeb96', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=95, is_runtime_checkable=True, domain='types', properties=['query_id: UUID', 'target_type: str', 'required_capabilities: list[str]', \"filters: dict[str, 'ContextValue']\", 'timeout_seconds: float'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery query objects.')",
        "ProtocolInfo(name='ProtocolDiscoveryResult', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='2b5dcd7ef927ab51', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=106, is_runtime_checkable=True, domain='types', properties=['query_id: UUID', 'status: LiteralDiscoveryStatus', 'nodes_found: int', 'discovery_time: float', 'error_message: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery result objects.')",
        "ProtocolInfo(name='ProtocolHandlerRegistration', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='7a56cae8338755f4', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=118, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'registration_data: dict[str, CapabilityValue]', 'registration_time: float', 'expires_at: float | None', 'is_active: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node registration objects.')",
        "ProtocolInfo(name='ProtocolMCPToolParameter', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_parameter() -> bool', 'is_required_parameter() -> bool'], signature_hash='afe6844a9d8627e8', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=35, is_runtime_checkable=True, domain='types', properties=['name: str', 'parameter_type: LiteralMCPParameterType', 'description: str', 'required: bool', 'default_value: ContextValue | None', 'schema: dict[str, Any] | None', \"constraints: dict[str, 'ContextValue']\", 'examples: list[ContextValue]'], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool parameter definition.')",
        "ProtocolInfo(name='ProtocolMCPToolDefinition', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_tool_definition() -> bool', 'is_complete() -> bool'], signature_hash='cf455d00c4634ecf', line_count=14, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=57, is_runtime_checkable=True, domain='types', properties=['name: str', 'tool_type: LiteralMCPToolType', 'description: str', \"version: 'ProtocolSemVer'\", \"parameters: list['ProtocolMCPToolParameter']\", 'return_schema: dict[str, Any] | None', 'execution_endpoint: str', 'timeout_seconds: int', 'retry_count: int', 'requires_auth: bool', 'tags: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool definition.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemMetadata', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_metadata() -> bool', 'has_required_fields() -> bool'], signature_hash='0814cae989ff0c68', line_count=16, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=83, is_runtime_checkable=True, domain='types', properties=['subsystem_id: str', 'name: str', 'subsystem_type: LiteralMCPSubsystemType', \"version: 'ProtocolSemVer'\", 'description: str', 'base_url: str', 'health_endpoint: str', 'documentation_url: str | None', 'repository_url: str | None', 'maintainer: str | None', 'tags: list[str]', 'capabilities: list[str]', 'dependencies: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem metadata.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemRegistration', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_registration() -> bool', 'is_active() -> bool'], signature_hash='df3249a25e7496d6', line_count=18, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=111, is_runtime_checkable=True, domain='types', properties=['registration_id: str', \"subsystem_metadata: 'ProtocolMCPSubsystemMetadata'\", \"tools: list['ProtocolMCPToolDefinition']\", 'api_key: str', 'registration_status: LiteralOperationStatus', 'lifecycle_state: LiteralMCPLifecycleState', 'connection_status: LiteralMCPConnectionStatus', \"health_status: 'LiteralHealthStatus'\", \"registered_at: 'ProtocolDateTime'\", \"last_heartbeat: 'ProtocolDateTime | None'\", 'heartbeat_interval_seconds: int', 'ttl_seconds: int', 'access_count: int', 'error_count: int', 'last_error: str | None', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem registration information.')",
        "ProtocolInfo(name='ProtocolMCPToolExecution', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_execution() -> bool', 'is_completed() -> bool'], signature_hash='a0b268b4eed20527', line_count=15, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=141, is_runtime_checkable=True, domain='types', properties=['execution_id: str', 'tool_name: str', 'subsystem_id: str', \"parameters: dict[str, 'ContextValue']\", 'execution_status: LiteralMCPExecutionStatus', \"started_at: 'ProtocolDateTime'\", \"completed_at: 'ProtocolDateTime | None'\", 'duration_ms: int | None', 'result: dict[str, Any] | None', 'error_message: str | None', 'retry_count: int', 'correlation_id: UUID', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool execution tracking.')",
        "ProtocolInfo(name='ProtocolMCPRegistryMetrics', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_metrics() -> bool', 'is_healthy() -> bool'], signature_hash='4ff5226298b7b8b9', line_count=18, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=168, is_runtime_checkable=True, domain='types', properties=['total_subsystems: int', 'active_subsystems: int', 'failed_subsystems: int', 'total_tools: int', 'active_tools: int', 'total_executions: int', 'successful_executions: int', 'failed_executions: int', 'average_execution_time_ms: float', 'peak_concurrent_executions: int', 'registry_uptime_seconds: int', \"last_cleanup_at: 'ProtocolDateTime | None'\", 'subsystem_type_distribution: dict[LiteralMCPSubsystemType, int]', 'tool_type_distribution: dict[LiteralMCPToolType, int]', 'health_status_distribution: dict[LiteralHealthStatus, int]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP registry metrics and statistics.')",
        "ProtocolInfo(name='ProtocolMCPRegistryStatus', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_status() -> bool', 'is_operational() -> bool'], signature_hash='7f1f877ff09b8bde', line_count=13, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=198, is_runtime_checkable=True, domain='types', properties=['registry_id: str', 'status: LiteralOperationStatus', 'message: str', \"version: 'ProtocolSemVer'\", \"started_at: 'ProtocolDateTime'\", \"last_updated: 'ProtocolDateTime'\", \"metrics: 'ProtocolMCPRegistryMetrics'\", 'active_connections: int', \"configuration: dict[str, 'ContextValue']\", 'features_enabled: list[str]', 'maintenance_mode: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for overall MCP registry status.')",
        "ProtocolInfo(name='ProtocolMCPRegistryConfig', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_config() -> bool', 'is_valid_configuration() -> bool'], signature_hash='0df4d8d83e718181', line_count=17, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=223, is_runtime_checkable=True, domain='types', properties=['registry_name: str', 'max_subsystems: int', 'max_tools_per_subsystem: int', 'default_heartbeat_interval: int', 'default_ttl_seconds: int', 'cleanup_interval_seconds: int', 'max_concurrent_executions: int', 'tool_execution_timeout: int', 'health_check_timeout: int', 'require_api_key: bool', 'enable_metrics: bool', 'enable_tracing: bool', 'log_level: str', 'maintenance_mode: bool', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP registry configuration.')",
        "ProtocolInfo(name='ProtocolMCPHealthCheck', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_health_check() -> bool', 'is_passing() -> bool'], signature_hash='b2bea3b70834c4b6', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=252, is_runtime_checkable=True, domain='types', properties=['subsystem_id: str', \"check_time: 'ProtocolDateTime'\", \"health_status: 'LiteralHealthStatus'\", 'response_time_ms: int', 'status_code: int | None', 'status_message: str', 'checks: dict[str, bool]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem health check result.')",
        "ProtocolInfo(name='ProtocolMCPDiscoveryInfo', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_discovery_info() -> bool', 'is_available() -> bool'], signature_hash='3685610f0465bd06', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=274, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'service_url: str', 'service_type: LiteralMCPSubsystemType', 'available_tools: list[str]', \"health_status: 'LiteralHealthStatus'\", \"last_seen: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP service discovery information.')",
        "ProtocolInfo(name='ProtocolMCPValidationError', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_error() -> bool', 'is_critical() -> bool'], signature_hash='dabe39b02ff7c59e', line_count=8, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=295, is_runtime_checkable=True, domain='types', properties=['error_type: str', 'field_name: str', 'error_message: str', 'invalid_value: ContextValue | None', 'suggested_fix: str | None', 'severity: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP validation errors.')",
        "ProtocolInfo(name='ProtocolMCPValidationResult', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_validation_result() -> bool', 'has_errors() -> bool'], signature_hash='9144ee698272fdaa', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=315, is_runtime_checkable=True, domain='types', properties=['is_valid: bool', \"errors: list['ProtocolMCPValidationError']\", \"warnings: list['ProtocolMCPValidationError']\", \"validation_time: 'ProtocolDateTime'\", \"validation_version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP validation results.')",
        "ProtocolInfo(name='ProtocolToolClass', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=[\"__call__() -> 'ProtocolToolInstance'\"], signature_hash='a35747994ffec9a9', line_count=3, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=334, is_runtime_checkable=True, domain='types', properties=['__name__: str', '__module__: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool class objects in MCP systems.')",
        "ProtocolInfo(name='ProtocolToolInstance', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=[\"async execute(parameters: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\", \"async validate_parameters(parameters: dict[str, 'ContextValue']) -> ProtocolMCPValidationResult\", \"health_check() -> dict[str, 'ContextValue']\"], signature_hash='7602719b3f2b89ce', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=346, is_runtime_checkable=True, domain='types', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", 'tool_type: LiteralMCPToolType', 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool instance objects in MCP systems.')"
      ],
      "core": [
        "ProtocolInfo(name='ProtocolHttpRequestBuilder', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=[\"url(url: str) -> 'ProtocolHttpRequestBuilder'\", \"async with_query_params(params: dict[str, 'ContextValue']) -> 'ProtocolHttpRequestBuilder'\", \"with_form_data(data: dict[str, 'ContextValue']) -> 'ProtocolHttpRequestBuilder'\", \"async with_file_upload(files: dict[str, bytes]) -> 'ProtocolHttpRequestBuilder'\", \"with_json(data: dict[str, str | int | float | bool]) -> 'ProtocolHttpRequestBuilder'\", \"with_bearer_token(token: str) -> 'ProtocolHttpRequestBuilder'\", \"with_basic_auth(username: str, password: str) -> 'ProtocolHttpRequestBuilder'\", \"with_header(name: str, value: str) -> 'ProtocolHttpRequestBuilder'\", \"with_timeout(timeout_seconds: int) -> 'ProtocolHttpRequestBuilder'\", \"async get() -> 'ProtocolHttpResponse'\", \"async post() -> 'ProtocolHttpResponse'\", \"async put() -> 'ProtocolHttpResponse'\", \"async delete() -> 'ProtocolHttpResponse'\"], signature_hash='927b916221876cef', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=15, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for building complex HTTP requests with fluent interface.\\n\\n    Supports query parameters, form data, file uploads, authentication,\\n    and other advanced HTTP features through method chaining.\\n\\n    Example:\\n        ```python\\n        builder: \"ProtocolHttpRequestBuilder\" = get_request_builder()\\n        response = await builder.url(\"https://api.example.com/upload\")             .with_query_params({\"version\": \"2.0\", \"format\": \"json\"})             .with_bearer_token(\"token123\")             .with_file_upload({\"document\": file_bytes})             .post()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpStreamingResponse', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=['async stream_content(chunk_size: int) -> bytes', 'async stream_json_lines() -> dict[str, str | int | float | bool]', 'async stream_text_lines(encoding: str) -> str', 'async get_full_content() -> bytes'], signature_hash='9d4549d3a6e7ce49', line_count=7, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=199, is_runtime_checkable=True, domain='core', properties=['status_code: int', \"headers: dict[str, 'ContextValue']\", 'url: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for handling streaming HTTP responses.\\n\\n    Supports streaming content, JSON lines, and chunked responses\\n    for efficient processing of large data sets.\\n\\n    Example:\\n        ```python\\n        response: \"ProtocolHttpStreamingResponse\" = await client.stream_get(url)\\n\\n        # Stream raw content\\n        async for chunk in response.stream_content():\\n            process_chunk(chunk)\\n\\n        # Stream JSON lines\\n        async for json_obj in response.stream_json_lines():\\n            process_json_object(json_obj)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpExtendedClient', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=['async create_request_builder() -> ProtocolHttpRequestBuilder', \"async stream_request(method: str, url: str, headers: dict[str, 'ContextValue'] | None) -> ProtocolHttpStreamingResponse\", 'async health_check() -> bool', 'async close() -> None'], signature_hash='21632795b22e5df5', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=282, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for extended HTTP client with advanced features.\\n\\n    Provides request builders, streaming responses, connection pooling,\\n    and advanced configuration options for production HTTP clients.\\n\\n    Example:\\n        ```python\\n        client: \"ProtocolHttpExtendedClient\" = get_extended_http_client()\\n\\n        # Use request builder\\n        builder = client.create_request_builder()\\n        response = await builder.url(\"https://api.example.com\")             .with_bearer_token(\"token\")             .get()\\n\\n        # Stream large responses\\n        stream_response = await client.stream_request(\"GET\", \"https://api.example.com/large-data\")\\n        async for chunk in stream_response.stream_content():\\n            process(chunk)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolAnalyticsDataProvider', file_path='src/omnibase_spi/protocols/core/protocol_analytics_provider.py', module_path='omnibase_spi.protocols.core.protocol_analytics_provider', methods=[\"async configure_analytics_provider(provider_config: 'ProtocolAnalyticsProvider') -> bool\", \"async get_analytics_provider_info() -> 'ProtocolAnalyticsProvider'\", \"async collect_metric(metric: 'ProtocolAnalyticsMetric') -> bool\", \"async collect_metrics_batch(metrics: list['ProtocolAnalyticsMetric']) -> int\", \"async query_metrics(metric_names: list[str], time_window: 'LiteralAnalyticsTimeWindow', start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime') -> list['ProtocolAnalyticsMetric']\", \"async generate_analytics_summary(time_window: 'LiteralAnalyticsTimeWindow', data_sources: list[str] | None, metric_types: list['LiteralAnalyticsMetricType'] | None) -> 'ProtocolAnalyticsSummary'\", 'get_supported_metrics() -> list[str]', \"get_supported_time_windows() -> list['LiteralAnalyticsTimeWindow']\", 'async add_data_source(source_name: str, source_config: dict[str, str | int | bool]) -> bool', 'async remove_data_source(source_name: str) -> bool', \"async get_analytics_health() -> dict[str, 'ContextValue']\", \"async create_custom_metric(metric_name: str, metric_type: 'LiteralAnalyticsMetricType', unit: str, description: str) -> bool\", 'async delete_custom_metric(metric_name: str) -> bool', 'set_metric_threshold(metric_name: str, warning_threshold: float, critical_threshold: float) -> bool', 'get_metric_thresholds(metric_name: str) -> dict[str, float] | None', \"generate_insights(summary: 'ProtocolAnalyticsSummary') -> list[str]\", \"generate_recommendations(summary: 'ProtocolAnalyticsSummary') -> list[str]\", \"async export_analytics_data(format_type: str, time_range: tuple['ProtocolDateTime', 'ProtocolDateTime'], metric_filter: list[str] | None) -> bytes | str\"], signature_hash='5f681bcacc13fc6b', line_count=18, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralAnalyticsMetricType', 'omnibase_spi.protocols.types.protocol_core_types.LiteralAnalyticsTimeWindow', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsMetric', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsProvider', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsSummary', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime'], line_number=23, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for analytics data providers and collection systems.\\n\\n    Provides consistent analytics patterns, metric collection, aggregation,\\n    and reporting for comprehensive system monitoring and business intelligence.\\n\\n    Key Features:\\n        - Multi-source data collection and aggregation\\n        - Time-windowed analytics with multiple granularities\\n        - Metric type classification (counter, gauge, histogram, summary)\\n        - Real-time and batch analytics processing\\n        - Insight generation and recommendation systems\\n        - Analytics pipeline management and data quality\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class AnalyticsProviderImpl:\\n            def collect_metrics(self, data_sources, time_window):\\n                metrics = []\\n                for source in data_sources:\\n                    raw_data = self._fetch_data(source, time_window)\\n                    processed_metrics = self._process_metrics(raw_data)\\n                    metrics.extend(processed_metrics)\\n\\n                return self._aggregate_metrics(metrics, time_window)\\n\\n            def generate_insights(self, summary):\\n                insights = []\\n                for metric in summary.metrics:\\n                    if metric.value > self._get_threshold(metric.name):\\n                        insights.append(f\"High {metric.name} detected\")\\n\\n                return insights\\n\\n        # Usage in application code\\n        analytics: \"ProtocolAnalyticsDataProvider\" = AnalyticsProviderImpl()\\n\\n        # Configure analytics collection\\n        provider_config = analytics.configure_analytics_provider(\\n            provider_id=\"service_metrics\",\\n            data_sources=[\"database\", \"api\", \"cache\"],\\n            supported_metrics=[\"response_time\", \"error_rate\", \"throughput\"]\\n        )\\n\\n        # Collect and analyze metrics\\n        summary = analytics.generate_analytics_summary(\\n            time_window=\"hourly\",\\n            data_sources=[\"database\", \"api\"]\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolMetricsCollector', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"record_counter(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_gauge(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_histogram(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_timer(name: str, duration_seconds: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_metrics_batch(metrics: list['ProtocolMetricsPoint']) -> None\", \"async create_metrics_context(default_tags: dict[str, 'ContextValue']) -> 'ProtocolMetricsCollector'\"], signature_hash='36ae202f85df3dea', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=24, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for metrics collection and reporting.\\n\\n    Provides standardized metrics collection interface for monitoring\\n    service performance, health, and business metrics.\\n\\n    Key Features:\\n        - Counter, gauge, histogram, and timer metrics\\n        - Multi-dimensional metrics with tags\\n        - Batch metrics submission for performance\\n        - Custom metric types and aggregation\\n        - Integration with monitoring systems\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class MetricsCollectorImpl:\\n            def record_counter(self, name, value, tags):\\n                point = MetricsPoint(\\n                    metric_name=name,\\n                    value=value,\\n                    tags=tags,\\n                    timestamp=datetime.utcnow()\\n                )\\n                self._send_to_backend(point)\\n\\n        # Usage in application code\\n        metrics: \"ProtocolMetricsCollector\" = MetricsCollectorImpl()\\n\\n        metrics.record_counter(\\n            name=\"requests_total\",\\n            value=1,\\n            tags={\"endpoint\": \"/api/users\", \"status\": \"200\"}\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolDistributedTracing', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"async start_span(operation_name: str, parent_span_id: 'UUID | None', trace_id: 'UUID | None') -> 'ProtocolTraceSpan'\", \"finish_span(span_id: 'UUID', status: 'LiteralOperationStatus') -> None\", \"add_span_tag(span_id: 'UUID', key: str, value: str) -> None\", \"add_span_log(span_id: 'UUID', message: str, fields: dict[str, object] | None) -> None\", \"extract_trace_context(headers: dict[str, 'ContextValue']) -> tuple['UUID', 'UUID']\", \"inject_trace_context(trace_id: 'UUID', span_id: 'UUID', headers: dict[str, 'ContextValue']) -> None\", \"get_current_span() -> 'ProtocolTraceSpan | None'\"], signature_hash='8f82cb690ddd02bf', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=163, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for distributed tracing across services.\\n\\n    Provides standardized distributed tracing interface for request\\n    flow visibility and performance analysis in microservices.\\n\\n    Key Features:\\n        - Span creation and lifecycle management\\n        - Parent-child span relationships\\n        - Cross-service trace propagation\\n        - Custom span tags and logs\\n        - Integration with tracing systems\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class TracingImpl:\\n            async def start_span(self, operation_name, parent_span_id=None):\\n                span = TraceSpan(\\n                    span_id=uuid.uuid4(),\\n                    operation_name=operation_name,\\n                    parent_span_id=parent_span_id,\\n                    start_time=datetime.utcnow()\\n                )\\n                return span\\n\\n        # Usage in application code\\n        tracing: \"ProtocolDistributedTracing\" = TracingImpl()\\n\\n        span = tracing.start_span(\\n            operation_name=\"process_user_request\",\\n            parent_span_id=request.trace_context.span_id\\n        )\\n\\n        try:\\n            result = process_request()\\n            tracing.finish_span(span.span_id, \"success\")\\n        except Exception as e:\\n            tracing.add_span_tag(span.span_id, \"error\", str(e))\\n            tracing.finish_span(span.span_id, \"failed\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolAuditLogger', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"log_audit_event(event_type: str, actor: str, resource: str, action: str, outcome: 'LiteralOperationStatus', metadata: dict[str, object] | None, sensitivity_level: str) -> 'ProtocolAuditEvent'\", \"async query_audit_events(start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime', filters: dict[str, 'ContextValue'] | None) -> list['ProtocolAuditEvent']\", 'get_audit_statistics(time_window_hours: int) -> dict[str, object]', \"archive_audit_events(before_date: 'ProtocolDateTime', archive_location: str) -> int\"], signature_hash='e1e1edef990a15fd', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=329, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for audit event logging.\\n\\n    Provides standardized audit logging interface for security,\\n    compliance, and operational event tracking.\\n\\n    Key Features:\\n        - Structured audit event recording\\n        - Sensitivity level classification\\n        - Actor and resource tracking\\n        - Outcome and metadata capture\\n        - Compliance and security integration\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class AuditLoggerImpl:\\n            def log_audit_event(self, event):\\n                if event.sensitivity_level in [\"confidential\", \"restricted\"]:\\n                    self._encrypt_before_storage(event)\\n                self._store_audit_event(event)\\n\\n        # Usage in application code\\n        audit_logger: \"ProtocolAuditLogger\" = AuditLoggerImpl()\\n\\n        audit_logger.log_audit_event(\\n            event_type=\"user_access\",\\n            actor=\"user123\",\\n            resource=\"/api/sensitive-data\",\\n            action=\"read\",\\n            outcome=\"success\",\\n            metadata={\"ip_address\": \"192.168.1.1\"},\\n            sensitivity_level=\"confidential\"\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClient', file_path='src/omnibase_spi/protocols/core/protocol_kafka_client.py', module_path='omnibase_spi.protocols.core.protocol_kafka_client', methods=['async start() -> None', 'async stop() -> None', 'async send_and_wait(topic: str, value: bytes, key: bytes | None) -> None', 'bootstrap_servers() -> list[str]'], signature_hash='bae797905510773b', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=12, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Kafka client implementations.\\n\\n    Provides standardized interface for Kafka producer/consumer operations\\n    that can be implemented by different Kafka client libraries.\\n\\n    Example:\\n        ```python\\n        # Basic usage\\n        kafka_client: \"ProtocolKafkaClient\" = get_kafka_client()\\n        await kafka_client.start()\\n\\n        # Send messages\\n        message_data = b\\'{\"event\": \"user_created\", \"user_id\": 123}\\'\\n        await kafka_client.send_and_wait(\"user-events\", message_data, key=b\"user:123\")\\n\\n        # Get configuration\\n        servers = kafka_client.bootstrap_servers()\\n        print(f\"Connected to: {servers}\")\\n\\n        # Cleanup\\n        await kafka_client.stop()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClientProvider', file_path='src/omnibase_spi/protocols/core/protocol_kafka_client.py', module_path='omnibase_spi.protocols.core.protocol_kafka_client', methods=['async create_kafka_client() -> ProtocolKafkaClient', 'async get_kafka_configuration() -> dict[str, str | int | float | bool]'], signature_hash='1db909234119f467', line_count=2, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=95, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for Kafka client provider.')",
        "ProtocolInfo(name='ProtocolUtilsNodeConfiguration', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration_utils.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration_utils', methods=['get_configuration() -> ProtocolNodeConfiguration', 'get_timeout_ms(timeout_type: str, default_ms: int | None) -> int', 'get_security_config(key: str, default: ContextValue | None) -> ContextValue', 'get_performance_config(key: str, default: ContextValue | None) -> ContextValue', 'get_business_logic_config(key: str, default: ContextValue | None) -> ContextValue', 'async validate_correlation_id(correlation_id: str) -> bool'], signature_hash='6685bf56ab0aff23', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_node_configuration.ProtocolNodeConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node configuration utility operations.\\n\\n    Provides standardized configuration access patterns that nodes\\n    can use without coupling to specific utility implementations.\\n    ')",
        "ProtocolInfo(name='ProtocolOnexEnvelope', file_path='src/omnibase_spi/protocols/core/protocol_onex_envelope.py', module_path='omnibase_spi.protocols.core.protocol_onex_envelope', methods=[\"async create_envelope(payload: 'Any', correlation_id: UUID | None, security_context: 'ProtocolOnexSecurityContext | None', metadata: 'ProtocolOnexMetadata | None') -> 'Any'\", \"async extract_payload(envelope: 'Any') -> 'Any'\", \"get_correlation_id(envelope: 'Any') -> UUID | None\", \"get_security_context(envelope: 'Any') -> 'ProtocolOnexSecurityContext | None'\", \"get_metadata(envelope: 'Any') -> 'ProtocolOnexMetadata | None'\", \"async validate_envelope(envelope: 'Any') -> bool\", \"get_timestamp(envelope: 'Any') -> datetime\", \"get_source_tool(envelope: 'Any') -> str | None\", \"get_target_tool(envelope: 'Any') -> str | None\", \"with_metadata(envelope: 'Any', metadata: 'ProtocolOnexMetadata') -> 'Any'\", \"is_onex_compliant(envelope: 'Any') -> bool\"], signature_hash='1bc06b9eaa0c2231', line_count=11, imports=['datetime.datetime', 'typing.TYPE_CHECKING', 'typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexMetadata', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexSecurityContext'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex envelope pattern.\\n\\n    All ONEX tools must implement this protocol for request envelope handling.\\n    Provides standardized request wrapping with metadata and security context.\\n    ')",
        "ProtocolInfo(name='ProtocolHealthDetails', file_path='src/omnibase_spi/protocols/core/protocol_health_details.py', module_path='omnibase_spi.protocols.core.protocol_health_details', methods=[\"get_health_status() -> 'LiteralHealthStatus'\", 'is_healthy() -> bool', 'get_health_summary() -> str'], signature_hash='f15bbd4281cd96f9', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service-specific health details with self-assessment capability.\\n\\n    This protocol defines the interface for health detail models that can:\\n    - Assess their own health status based on service-specific metrics\\n    - Provide boolean health indicators\\n    - Generate human-readable health summaries\\n\\n    Designed to work with the existing ProtocolHealthCheck and ProtocolHealthMonitor\\n    protocols, allowing service-specific models to contribute to overall health assessment.\\n\\n    Key Features:\\n        - Service-specific health logic encapsulation\\n        - Consistent interface across all health detail models\\n        - Self-contained health assessment capability\\n        - Human-readable status reporting\\n        - Integration with existing health monitoring infrastructure\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ModelPostgresHealthDetails(BaseModel):\\n            postgres_connection_count: int | None\\n            postgres_last_error: str | None\\n            max_connections: int | None\\n\\n            def get_health_status(self) -> \"LiteralHealthStatus\":\\n                if self.postgres_last_error:\\n                    return \"unhealthy\"\\n                if self.postgres_connection_count and self.max_connections:\\n                    if self.postgres_connection_count > (self.max_connections * 0.9):\\n                        return \"warning\"\\n                return \"healthy\"\\n\\n            def is_healthy(self) -> bool:\\n                return self.get_health_status() == \"healthy\"\\n\\n            def get_health_summary(self) -> str:\\n                status = self.get_health_status()\\n                if status == \"unhealthy\":\\n                    return f\"PostgreSQL Error: {self.postgres_last_error}\"\\n                return \"PostgreSQL connections healthy\"\\n        ```\\n\\n    Integration with Health Monitoring:\\n        ```python\\n        async def create_health_check(details: \"ProtocolHealthDetails\") -> ProtocolHealthCheck:\\n            return HealthCheckImpl(\\n                service_name=details.__class__.__name__,\\n                overall_status=details.get_health_status(),\\n                individual_checks={\"service\": details.get_health_status()},\\n                summary=details.get_health_summary()\\n            )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolOnexReply', file_path='src/omnibase_spi/protocols/core/protocol_onex_reply.py', module_path='omnibase_spi.protocols.core.protocol_onex_reply', methods=[\"async create_success_reply(data: Any, correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", \"async create_error_reply(error_message: str, error_code: str | None, error_details: str | None, correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", \"async create_validation_error_reply(validation_errors: list[str], correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", 'extract_data(reply: Any) -> Any | None', \"get_status(reply: Any) -> 'LiteralOnexReplyStatus'\", 'get_error_message(reply: Any) -> str | None', 'get_error_code(reply: Any) -> str | None', 'get_error_details(reply: Any) -> str | None', 'get_correlation_id(reply: Any) -> UUID | None', 'get_metadata(reply: Any) -> ProtocolOnexMetadata | None', 'is_success(reply: Any) -> bool', 'is_error(reply: Any) -> bool', 'get_timestamp(reply: Any) -> ProtocolDateTime', 'async get_processing_time(reply: Any) -> float | None', \"with_metadata(reply: Any, metadata: 'ProtocolOnexMetadata') -> Any\", 'is_onex_compliant(reply: Any) -> bool', 'async validate_reply(reply: Any) -> bool'], signature_hash='64b9fd0903fed960', line_count=17, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex reply pattern.\\n\\n    All ONEX tools must implement this protocol for response reply handling.\\n    Provides standardized response wrapping with status and error information.\\n    ')",
        "ProtocolInfo(name='ProtocolPerformanceMetricsCollector', file_path='src/omnibase_spi/protocols/core/protocol_performance_metrics.py', module_path='omnibase_spi.protocols.core.protocol_performance_metrics', methods=[\"async collect_performance_metrics(service_name: str) -> 'ProtocolPerformanceMetrics'\", \"async collect_category_metrics(service_name: str, categories: list['LiteralPerformanceCategory']) -> list['ProtocolPerformanceMetric']\", \"async record_performance_metric(metric: 'ProtocolPerformanceMetric') -> bool\", \"async record_performance_metrics_batch(metrics: list['ProtocolPerformanceMetric']) -> int\", 'set_performance_threshold(metric_name: str, warning_threshold: float | None, critical_threshold: float | None) -> bool', 'get_performance_thresholds(metric_name: str) -> dict[str, float | None]', \"async check_performance_thresholds(metrics: 'ProtocolPerformanceMetrics') -> list[dict[str, 'ProtocolContextValue']]\", \"async analyze_performance_trends(service_name: str, hours_back: int, categories: list['LiteralPerformanceCategory'] | None) -> dict[str, dict[str, float]]\", 'async get_performance_baseline(service_name: str, metric_name: str) -> dict[str, float]', 'async establish_performance_baseline(service_name: str, metric_name: str, baseline_period_hours: int) -> bool', \"async compare_to_baseline(current_metrics: 'ProtocolPerformanceMetrics', baseline_deviation_threshold: float) -> dict[str, dict[str, 'ProtocolContextValue']]\", \"get_performance_recommendations(service_name: str, performance_issues: list[dict[str, 'ProtocolContextValue']]) -> list[str]\", \"async export_performance_report(service_name: str, start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime', categories: list['LiteralPerformanceCategory'] | None) -> dict[str, 'ProtocolContextValue']\", 'async start_real_time_monitoring(service_name: str, collection_interval_seconds: int, alert_callback: Callable[..., Any] | None) -> str', 'async stop_real_time_monitoring(monitoring_session_id: str) -> bool', \"async get_monitoring_sessions() -> list[dict[str, 'ProtocolContextValue']]\", 'async correlate_cross_service_performance(service_names: list[str], correlation_window_minutes: int) -> dict[str, dict[str, float]]', \"async identify_performance_bottlenecks(service_name: str, analysis_period_hours: int) -> list[dict[str, 'ProtocolContextValue']]\", \"async predict_performance_issues(service_name: str, prediction_horizon_hours: int) -> list[dict[str, 'ProtocolContextValue']]\", \"async get_performance_summary(service_names: list[str], summary_period_hours: int) -> dict[str, 'ProtocolContextValue']\"], signature_hash='e0f6ec9343e79215', line_count=20, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralPerformanceCategory', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolPerformanceMetric', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolPerformanceMetrics'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for performance metrics collection and monitoring.\\n\\n    Provides standardized performance measurement interface for tracking\\n    system health, identifying bottlenecks, and enabling proactive\\n    optimization across ONEX distributed services.\\n\\n    Key Features:\\n        - Multi-category performance metrics (latency, throughput, resource, etc.)\\n        - Real-time and historical performance tracking\\n        - Configurable alerting thresholds and notifications\\n        - Performance trend analysis and baseline management\\n        - Cross-service performance correlation\\n        - Automated performance recommendations\\n\\n    Usage Example:\\n\\n        .. code-block:: python\\n\\n            # Implementation example (not part of SPI)\\n            class PerformanceMetricsImpl:\\n                def collect_performance_metrics(self, service_name):\\n                    metrics = []\\n\\n                    # Collect latency metrics\\n                    response_time = self._measure_response_time()\\n                    metrics.append(PerformanceMetric(\\n                        metric_name=\"response_time\",\\n                        category=\"latency\",\\n                        value=response_time,\\n                        unit=\"ms\"\\n                    ))\\n\\n                    # Collect throughput metrics\\n                    rps = self._calculate_requests_per_second()\\n                    metrics.append(PerformanceMetric(\\n                        metric_name=\"requests_per_second\",\\n                        category=\"throughput\",\\n                        value=rps,\\n                        unit=\"req/s\"\\n                    ))\\n\\n                    return PerformanceMetrics(\\n                        service_name=service_name,\\n                        metrics=metrics,\\n                        overall_health_score=self._calculate_health_score(metrics)\\n                    )\\n\\n            # Usage in application code\\n            perf_collector: \"ProtocolPerformanceMetricsCollector\" = PerformanceMetricsImpl()\\n\\n            # Collect current performance metrics\\n            current_metrics = perf_collector.collect_performance_metrics(\\n                service_name=\"user-service\"\\n            )\\n\\n            # Set performance thresholds\\n            perf_collector.set_performance_threshold(\\n                metric_name=\"response_time\",\\n                warning_threshold=500.0,\\n                critical_threshold=1000.0\\n            )\\n\\n            # Analyze performance trends\\n            trends = perf_collector.analyze_performance_trends(\\n                service_name=\"user-service\",\\n                hours_back=24,\\n                categories=[\"latency\", \"throughput\"]\\n            )\\n    ')",
        "ProtocolInfo(name='ProtocolConnectionManageable', file_path='src/omnibase_spi/protocols/core/protocol_connection_manageable.py', module_path='omnibase_spi.protocols.core.protocol_connection_manageable', methods=['async establish_connection() -> bool', 'async close_connection() -> bool', 'async disconnect() -> bool', 'async reconnect_immediate() -> bool', \"async reconnect_with_strategy(retry_config: 'ProtocolRetryConfig') -> bool\", 'async recover_connection() -> bool', 'async perform_health_check() -> bool', \"async perform_deep_health_check() -> dict[str, 'ContextValue']\", \"async get_connection_state() -> 'LiteralConnectionState'\", \"async get_connection_status() -> 'ProtocolConnectionStatus'\", \"async get_connection_metrics() -> dict[str, 'ContextValue']\", \"async update_connection_config(new_config: 'ProtocolConnectionConfig') -> bool\", 'async enable_auto_reconnect() -> bool', 'async disable_auto_reconnect() -> bool', 'async is_connected() -> bool', 'async is_connecting() -> bool', 'can_recover() -> bool', 'get_last_error() -> str | None', 'async get_connection_uptime() -> int', 'get_idle_time() -> int', 'reset_error_count() -> bool', 'async set_connection_timeout(timeout_ms: int) -> bool', \"async get_connection_pool_stats() -> dict[str, 'ContextValue'] | None\", \"async validate_connection_config(config: 'ProtocolConnectionConfig') -> bool\", \"async test_connection_config(config: 'ProtocolConnectionConfig') -> dict[str, 'ContextValue']\", 'get_supported_features() -> list[str]', 'is_feature_available(feature_name: str) -> bool'], signature_hash='756d4309409bed83', line_count=32, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralConnectionState', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolConnectionConfig', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolConnectionStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryConfig'], line_number=22, is_runtime_checkable=True, domain='core', properties=['connection_id: str', \"config: 'ProtocolConnectionConfig'\", \"status: 'ProtocolConnectionStatus'\", 'can_reconnect: bool', 'auto_reconnect_enabled: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive connection management across ONEX services.\\n\\n    Provides consistent connection lifecycle management, health monitoring,\\n    reconnection strategies, and resilient connection handling for distributed\\n    system reliability and fault tolerance.\\n\\n    Key Features:\\n        - Connection lifecycle management (connect, disconnect, close)\\n        - Real-time connection status monitoring and health checks\\n        - Automatic reconnection with configurable retry strategies\\n        - Connection pool management and resource optimization\\n        - Graceful degradation and circuit breaker patterns\\n        - Connection metrics collection and performance monitoring\\n        - Event-driven connection state notifications\\n        - SSL/TLS security configuration and validation\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class DatabaseConnectionManager:\\n            @property\\n            async def connection_id(self) -> str:\\n                return self._connection_id\\n\\n            @property\\n            def config(self) -> \"ProtocolConnectionConfig\":\\n                return self._config\\n\\n            @property\\n            def status(self) -> \"ProtocolConnectionStatus\":\\n                return self._status\\n\\n            @property\\n            async def can_reconnect(self) -> bool:\\n                return self._can_reconnect\\n\\n            @property\\n            async def auto_reconnect_enabled(self) -> bool:\\n                return self._auto_reconnect_enabled\\n\\n            async def establish_connection(self) -> bool:\\n                try:\\n                    self._status.state = \"connecting\"\\n                    self._connection = await create_db_connection(self._config)\\n                    self._status.state = \"connected\"\\n                    self._status.connected_at = datetime.utcnow()\\n                    return True\\n                except Exception:\\n                    self._status.state = \"failed\"\\n                    self._status.error_count += 1\\n                    return False\\n\\n            async def perform_health_check(self) -> bool:\\n                if not self._connection:\\n                    return False\\n                try:\\n                    await self._connection.ping()\\n                    return True\\n                except Exception:\\n                    self._status.error_count += 1\\n                    return False\\n\\n        # Usage in application code\\n        connection_mgr: \"ProtocolConnectionManageable\" = DatabaseConnectionManager()\\n\\n        # Establish connection with retry\\n        success = await connection_mgr.establish_connection()\\n        if not success:\\n            await connection_mgr.reconnect_with_strategy(retry_config)\\n\\n        # Monitor connection health\\n        if await connection_mgr.perform_health_check():\\n            # Connection is healthy, proceed with operations\\n            pass\\n        else:\\n            # Connection unhealthy, trigger recovery\\n            await connection_mgr.recover_connection()\\n        ```\\n\\n    Connection States:\\n        - disconnected: No active connection established\\n        - connecting: In process of establishing connection\\n        - connected: Active connection ready for operations\\n        - reconnecting: Attempting to restore lost connection\\n        - failed: Connection failed and requires intervention\\n        - closing: Gracefully shutting down connection\\n\\n    Reconnection Strategies:\\n        - immediate: Attempt reconnection without delay\\n        - exponential_backoff: Exponentially increasing delays between attempts\\n        - linear_backoff: Linear delay increases for predictable retry timing\\n        - circuit_breaker: Temporary connection suspension after failure threshold\\n        - manual: Require explicit reconnection request (no auto-retry)\\n\\n    Health Check Levels:\\n        - ping: Basic connectivity test (fastest)\\n        - shallow: Basic query or lightweight operation\\n        - deep: Comprehensive connection validation and feature check\\n        - diagnostic: Full connection diagnostics with performance metrics\\n    ')",
        "ProtocolInfo(name='ProtocolHttpResponse', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=[], signature_hash='42dea24884283805', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['status_code: int', \"headers: dict[str, 'ContextValue']\", 'body: str | bytes | dict[str, str | int | float | bool]', 'url: str'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol representing an HTTP response.\\n\\n    Provides structured response data with status, headers, and body content.\\n    ')",
        "ProtocolInfo(name='ProtocolHttpClient', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=[\"async request(method: str, url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async get(url: str, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async post(url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async put(url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async delete(url: str, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\"], signature_hash='9169b86eeb023c10', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=28, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for HTTP client operations.\\n\\n    Generic HTTP client supporting standard HTTP methods with configurable\\n    timeouts, headers, and request/response handling. Implementations can\\n    use aiohttp, httpx, or other HTTP client backends.\\n\\n    Example:\\n        ```python\\n        # GET request\\n        client: \"ProtocolHttpClient\" = get_http_client()\\n        response = await client.request(\"GET\", \"https://api.example.com/users\")\\n        print(f\"Status: {response.status_code}\")\\n        print(f\"Data: {response.body}\")\\n\\n        # POST with JSON payload\\n        payload = {\"name\": \"John\", \"email\": \"john@example.com\"}\\n        headers = {\"Content-Type\": \"application/json\"}\\n        response = await client.request(\\n            \"POST\",\\n            \"https://api.example.com/users\",\\n            json=payload,\\n            headers=headers,\\n            timeout=30\\n        )\\n\\n        # Webhook delivery\\n        webhook_data = {\"event\": \"user.created\", \"user_id\": 123}\\n        response = await client.request(\\n            \"POST\",\\n            \"https://webhook.example.com/events\",\\n            json=webhook_data,\\n            headers={\"X-Event-Type\": \"user.created\"},\\n            timeout=10\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpClientProvider', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=['async create_http_client() -> ProtocolHttpClient', 'get_http_configuration() -> dict[str, str | int | float | bool]'], signature_hash='6502dea088020590', line_count=2, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=175, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for HTTP client provider.')",
        "ProtocolInfo(name='ProtocolVersionManager', file_path='src/omnibase_spi/protocols/core/protocol_version_manager.py', module_path='omnibase_spi.protocols.core.protocol_version_manager', methods=[\"get_protocol_version_info(protocol_name: str) -> 'ProtocolVersionInfo'\", \"async register_protocol_version(protocol_name: str, version: 'ProtocolSemVer', compatibility_version: 'ProtocolSemVer', migration_guide_url: str | None) -> bool\", \"async check_compatibility(protocol_name: str, required_version: 'ProtocolSemVer', current_version: 'ProtocolSemVer') -> 'ProtocolCompatibilityCheck'\", \"get_breaking_changes(protocol_name: str, from_version: 'ProtocolSemVer', to_version: 'ProtocolSemVer') -> list[str]\", \"schedule_retirement(protocol_name: str, version: 'ProtocolSemVer', retirement_date: 'ProtocolDateTime', replacement_version: 'ProtocolSemVer | None') -> bool\", \"get_retired_versions(protocol_name: str) -> list['ProtocolVersionInfo']\", \"is_version_retired(protocol_name: str, version: 'ProtocolSemVer') -> bool\", \"get_recommended_version(protocol_name: str, current_version: 'ProtocolSemVer') -> 'ProtocolSemVer'\", \"generate_migration_plan(protocol_name: str, from_version: 'ProtocolSemVer', to_version: 'ProtocolSemVer') -> dict[str, object]\", \"async validate_version_usage(protocol_name: str, version: 'ProtocolSemVer') -> list[str]\", 'get_version_statistics(time_window_days: int) -> dict[str, object]'], signature_hash='cb230c0c71b8b776', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCompatibilityCheck', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolVersionInfo'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for version management and compatibility checking.\\n\\n    Provides version metadata management, compatibility verification,\\n    and migration guidance for evolving protocol interfaces.\\n\\n    Key Features:\\n        - Semantic version management for protocols\\n        - Backward and forward compatibility checking\\n        - Breaking change detection and migration guidance\\n        - Deprecation lifecycle management\\n        - Version negotiation for service communication\\n        - Migration path documentation and automation\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class VersionManagerImpl:\\n            async def check_compatibility(self, required, current):\\n                if current.major != required.major:\\n                    return CompatibilityCheck(\\n                        is_compatible=False,\\n                        breaking_changes=[\"Major version mismatch\"],\\n                        migration_required=True\\n                    )\\n                return CompatibilityCheck(is_compatible=True)\\n\\n        # Usage in application code\\n        version_manager: \"ProtocolVersionManager\" = VersionManagerImpl()\\n\\n        compatibility = version_manager.check_compatibility(\\n            required_version=SemVer(2, 1, 0),\\n            current_version=SemVer(2, 0, 5)\\n        )\\n\\n        if not compatibility.is_compatible:\\n            raise VersionError(compatibility.breaking_changes)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaMessage', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=[], signature_hash='25363255614bfa84', line_count=7, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['key: bytes | None', 'value: bytes', 'topic: str', 'partition: int | None', 'offset: int | None', 'timestamp: int | None', 'headers: dict[str, bytes]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka message data.\\n\\n    Represents a single message with key, value, headers, and metadata\\n    for comprehensive message handling across producers and consumers.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConsumer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async subscribe_to_topics(topics: list[str], group_id: str) -> None', 'async unsubscribe_from_topics(topics: list[str]) -> None', \"async consume_messages(timeout_ms: int, max_messages: int) -> list['ProtocolKafkaMessage']\", \"async consume_messages_stream(batch_timeout_ms: int) -> list['ProtocolKafkaMessage']\", 'async commit_offsets() -> None', 'async seek_to_beginning(topic: str, partition: int) -> None', 'async seek_to_end(topic: str, partition: int) -> None', 'async seek_to_offset(topic: str, partition: int, offset: int) -> None', 'async get_current_offsets() -> dict[str, dict[int, int]]', 'async close_consumer() -> None'], signature_hash='413a99eb591b19ed', line_count=10, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=32, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for Kafka consumer operations.\\n\\n    Supports topic subscription, message consumption, offset management,\\n    and consumer group coordination for distributed event processing.\\n\\n    Example:\\n        ```python\\n        consumer: \"ProtocolKafkaConsumer\" = get_kafka_consumer()\\n\\n        # Subscribe to topics\\n        await consumer.subscribe_to_topics(\\n            topics=[\"events\", \"notifications\"],\\n            group_id=\"service_processor\"\\n        )\\n\\n        # Consume messages\\n        async for messages in consumer.consume_messages_stream():\\n            for message in messages:\\n                await process_message(message)\\n            await consumer.commit_offsets()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaBatchProducer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=[\"async send_batch(messages: list['ProtocolKafkaMessage']) -> None\", 'async send_to_partition(topic: str, partition: int, key: bytes | None, value: bytes, headers: dict[str, bytes] | None) -> None', 'async send_with_custom_partitioner(topic: str, key: bytes | None, value: bytes, partition_strategy: str, headers: dict[str, bytes] | None) -> None', 'async flush_pending(timeout_ms: int) -> None', 'async get_batch_metrics() -> dict[str, int]'], signature_hash='f7bb3ba11f25ba86', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=194, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for batch Kafka producer operations.\\n\\n    Supports batching multiple messages, custom partitioning strategies,\\n    transaction management, and high-throughput message production.\\n\\n    Example:\\n        ```python\\n        producer: \"ProtocolKafkaBatchProducer\" = get_batch_producer()\\n\\n        # Prepare batch of messages\\n        messages = [\\n            create_kafka_message(\"user.created\", user_data),\\n            create_kafka_message(\"notification.sent\", notification_data)\\n        ]\\n\\n        # Send batch\\n        await producer.send_batch(messages)\\n        await producer.flush_pending()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaTransactionalProducer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async init_transactions(transaction_id: str) -> None', 'async begin_transaction() -> None', 'async send_transactional(topic: str, value: bytes, key: bytes | None, headers: dict[str, bytes] | None) -> None', 'async commit_transaction() -> None', 'async abort_transaction() -> None'], signature_hash='3b2a4b2c94193dd7', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=302, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for transactional Kafka producer operations.\\n\\n    Supports exactly-once semantics with transaction management,\\n    atomic message production, and consumer-producer coordination.\\n\\n    Example:\\n        ```python\\n        producer: \"ProtocolKafkaTransactionalProducer\" = get_transactional_producer()\\n\\n        # Start transaction\\n        await producer.begin_transaction()\\n\\n        try:\\n            await producer.send_transactional(\"events\", event_data)\\n            await producer.send_transactional(\"audit\", audit_data)\\n            await producer.commit_transaction()\\n        except Exception:\\n            await producer.abort_transaction()\\n            raise\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaExtendedClient', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async create_consumer() -> ProtocolKafkaConsumer', 'async create_batch_producer() -> ProtocolKafkaBatchProducer', 'async create_transactional_producer() -> ProtocolKafkaTransactionalProducer', \"async create_topic(topic_name: str, partitions: int, replication_factor: int, config: dict[str, 'ContextValue'] | None) -> None\", 'async delete_topic(topic_name: str) -> None', 'async list_topics() -> list[str]', 'async get_topic_metadata(topic_name: str) -> dict[str, str | int]', 'async health_check() -> bool', 'async close_client() -> None'], signature_hash='58d1354be27c472f', line_count=9, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=395, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive Kafka client with all operations.\\n\\n    Combines producer, consumer, and administrative operations\\n    with advanced features like schema registry and monitoring.\\n\\n    Example:\\n        ```python\\n        client: \"ProtocolKafkaExtendedClient\" = get_extended_kafka_client()\\n\\n        # Create consumer and producer\\n        consumer = client.create_consumer()\\n        producer = client.create_batch_producer()\\n\\n        # Administrative operations\\n        await client.create_topic(\"new_events\", partitions=3, replication=2)\\n        topics = await client.list_topics()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHealthMonitor', file_path='src/omnibase_spi/protocols/core/protocol_health_monitor.py', module_path='omnibase_spi.protocols.core.protocol_health_monitor', methods=[\"async perform_health_check(level: 'LiteralHealthCheckLevel', dimensions: list['LiteralHealthDimension']) -> 'ProtocolHealthCheck'\", \"get_current_health_status() -> 'LiteralHealthStatus'\", \"get_health_metrics() -> 'ProtocolHealthMetrics'\", \"configure_monitoring(config: 'ProtocolHealthMonitoring') -> bool\", \"get_monitoring_configuration() -> 'ProtocolHealthMonitoring'\", 'async start_monitoring() -> bool', 'async stop_monitoring() -> bool', 'is_monitoring_active() -> bool', \"get_health_history(hours_back: int) -> list['ProtocolHealthCheck']\", \"async register_health_dependency(dependency_name: str, dependency_monitor: 'ProtocolHealthMonitor') -> bool\", 'async unregister_health_dependency(dependency_name: str) -> bool', \"get_dependency_health_status(dependency_name: str) -> 'LiteralHealthStatus'\", \"set_health_alert_callback(callback: Callable[[str, 'LiteralHealthStatus', 'LiteralHealthStatus'], None]) -> bool\", \"get_aggregated_health_status() -> dict[str, 'LiteralHealthStatus']\"], signature_hash='7ea3d28222eace2f', line_count=14, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthCheckLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthDimension', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthCheck', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthMetrics', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthMonitoring'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized health monitoring across ONEX services.\\n\\n    Provides consistent health check patterns, monitoring configuration,\\n    and availability tracking for distributed system reliability.\\n\\n    Key Features:\\n        - Multi-level health checks (quick to comprehensive)\\n        - Dimensional health assessment (availability, performance, etc.)\\n        - Configurable monitoring intervals and thresholds\\n        - Health metrics collection and trending\\n        - Automated alerting and escalation\\n        - Service dependency health tracking\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class HealthMonitorImpl:\\n            async def perform_health_check(self, level, dimensions):\\n                checks = {}\\n                metrics = self._collect_metrics()\\n\\n                for dimension in dimensions:\\n                    if dimension == \"availability\":\\n                        checks[dimension] = self._check_availability()\\n                    elif dimension == \"performance\":\\n                        checks[dimension] = self._check_performance(metrics)\\n\\n                overall = self._aggregate_status(checks.values())\\n                return HealthCheck(overall_status=overall, individual_checks=checks)\\n\\n        # Usage in application code\\n        health_monitor: \"ProtocolHealthMonitor\" = HealthMonitorImpl()\\n\\n        health_status = health_monitor.perform_health_check(\\n            level=\"standard\",\\n            dimensions=[\"availability\", \"performance\"]\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolLogger', file_path='src/omnibase_spi/protocols/core/protocol_logger.py', module_path='omnibase_spi.protocols.core.protocol_logger', methods=[\"emit(level: LiteralLogLevel, message: str, correlation_id: UUID, context: 'ProtocolLogContext | None') -> None\", \"log(entry: 'ProtocolLogEntry') -> None\", 'is_level_enabled(level: LiteralLogLevel) -> bool'], signature_hash='cf37fc77af098248', line_count=3, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.LiteralLogLevel', 'omnibase_spi.protocols.types.ProtocolLogContext', 'omnibase_spi.protocols.types.ProtocolLogEntry'], line_number=12, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX logging services that can be resolved from the registry.\\n\\n    This protocol defines the interface that all logging implementations must\\n    implement to be compatible with the ONEX logging system.\\n\\n    Example:\\n        class MyLogger:\\n            def emit(self, level: LiteralLogLevel, message: str, correlation_id: UUID) -> None:\\n                ...\\n\\n            def log(self, entry: \"ProtocolLogEntry\") -> None:\\n                ...\\n    ')",
        "ProtocolInfo(name='ProtocolStorageBackend', file_path='src/omnibase_spi/protocols/core/protocol_storage_backend.py', module_path='omnibase_spi.protocols.core.protocol_storage_backend', methods=[\"async store_checkpoint(checkpoint_data: 'ProtocolCheckpointData') -> 'ProtocolStorageResult'\", \"async retrieve_checkpoint(checkpoint_id: str) -> 'ProtocolStorageResult'\", \"async list_checkpoints(workflow_id: str | None, limit: int | None, offset: int | None) -> 'ProtocolStorageListResult'\", \"async delete_checkpoint(checkpoint_id: str) -> 'ProtocolStorageResult'\", \"async cleanup_expired_checkpoints(retention_hours: int) -> 'ProtocolStorageResult'\", \"async get_storage_status() -> 'ProtocolStorageHealthStatus'\", \"async test_connection() -> 'ProtocolStorageResult'\", \"async initialize_storage() -> 'ProtocolStorageResult'\", 'backend_id() -> str', 'backend_type() -> str', 'is_healthy() -> bool'], signature_hash='48bdc22baba35ea4', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCheckpointData', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageCredentials', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageListResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageResult'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for checkpoint storage backends.\\n\\n    Follows the same pattern as ProtocolEventBus for consistency.\\n    Provides pluggable storage interface for different backends\\n    (filesystem, sqlite, postgresql, cloud storage, etc.).\\n\\n    Key Features:\\n        - Checkpoint storage and retrieval\\n        - Listing with filtering and pagination\\n        - Health monitoring and status\\n        - Connection testing\\n        - Retention policy management\\n    ')",
        "ProtocolInfo(name='ProtocolStorageBackendFactory', file_path='src/omnibase_spi/protocols/core/protocol_storage_backend.py', module_path='omnibase_spi.protocols.core.protocol_storage_backend', methods=[\"async get_storage_backend(backend_type: str, storage_config: 'ProtocolStorageConfiguration', credentials: 'ProtocolStorageCredentials | None') -> 'ProtocolStorageBackend'\", 'async list_available_backends() -> list[str]', \"async validate_backend_config(backend_type: str, storage_config: 'ProtocolStorageConfiguration') -> 'ProtocolStorageResult'\", \"async get_default_config(backend_type: str) -> 'ProtocolStorageConfiguration'\"], signature_hash='a43cb57926f6d92c', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCheckpointData', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageCredentials', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageListResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageResult'], line_number=198, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for creating storage backends.\\n\\n    Follows the same pattern as event bus factory for consistency.\\n    Provides pluggable factory interface for different backend types.\\n    ')",
        "ProtocolInfo(name='ProtocolInputValidator', file_path='src/omnibase_spi/protocols/core/protocol_input_validator.py', module_path='omnibase_spi.protocols.core.protocol_input_validator', methods=[\"async validate_input(value: 'ContextValue', rules: list[str], validation_level: 'LiteralValidationLevel') -> 'ProtocolValidationResult'\", \"async validate_string(value: str, min_length: int | None, max_length: int | None, pattern: str | None, allow_empty: bool) -> 'ProtocolValidationResult'\", \"async validate_numeric(value: float | int, min_value: float | None, max_value: float | None, allow_negative: bool, precision: int | None) -> 'ProtocolValidationResult'\", \"async validate_collection(value: list[object] | dict[str, object], max_size: int | None, item_rules: list[str] | None, unique_items: bool) -> 'ProtocolValidationResult'\", \"async validate_email(email: str, check_mx: bool, allow_international: bool) -> 'ProtocolValidationResult'\", \"async validate_url(url: str, allowed_schemes: list[str] | None, allow_private_ips: bool, max_length: int) -> 'ProtocolValidationResult'\", 'sanitize_input(value: str, remove_html: bool, escape_special_chars: bool, normalize_whitespace: bool) -> str', \"async validate_batch(inputs: list[dict[str, object]], validation_mode: 'LiteralValidationMode') -> list['ProtocolValidationResult']\", 'add_custom_rule(rule_name: str, validator_function: Callable[..., bool], error_message: str) -> bool', \"async check_security_patterns(value: str, check_sql_injection: bool, check_xss: bool, check_path_traversal: bool, check_command_injection: bool) -> 'ProtocolValidationResult'\", 'async get_validation_statistics(time_window_hours: int) -> dict[str, object]', \"async validate_with_rate_limit(value: str, caller_id: str, max_requests_per_minute: int, validation_type: str) -> 'ProtocolValidationResult'\", 'async get_rate_limit_status(caller_id: str, validation_type: str) -> dict[str, object]'], signature_hash='24935cfe97bee435', line_count=13, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized input validation across ONEX services.\\n\\n    Provides comprehensive input validation, sanitization, and security\\n    checking to prevent injection attacks and ensure data integrity.\\n\\n    Key Features:\\n        - Multi-level validation (basic to paranoid)\\n        - Type-specific validation rules\\n        - Size and format constraints\\n        - Security-focused validation patterns\\n        - Custom validation rule support\\n        - Batch validation for performance\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class InputValidatorImpl:\\n            async def validate_input(self, value, rules, level):\\n                result = ValidationResult(is_valid=True, errors=[], warnings=[])\\n\\n                for rule in rules:\\n                    if rule == \"max_length\" and len(str(value)) > 1000:\\n                        result.is_valid = False\\n                        result.errors.append(\"Input exceeds maximum length\")\\n\\n                return result\\n\\n        # Usage in application code\\n        validator: \"ProtocolInputValidator\" = InputValidatorImpl()\\n\\n        result = validator.validate_input(\\n            value=user_input,\\n            rules=[\"required\", \"max_length:255\", \"no_sql_injection\"],\\n            validation_level=\"standard\"\\n        )\\n\\n        if not result.is_valid:\\n            raise ValidationError(result.errors)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolSchemaLoader', file_path='src/omnibase_spi/protocols/core/protocol_schema_loader.py', module_path='omnibase_spi.protocols.core.protocol_schema_loader', methods=[\"async load_onex_yaml(path: str) -> 'ProtocolNodeMetadataBlock'\", 'async load_json_schema(path: str) -> ProtocolSchemaObject', \"async load_schema_for_node(node: 'ProtocolNodeMetadataBlock') -> ProtocolSchemaObject\"], signature_hash='8cd734eeec177e48', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadataBlock', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSchemaObject'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX schema loaders.\\n    All methods use path strings and return strongly-typed models as appropriate.\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationManager', file_path='src/omnibase_spi/protocols/core/protocol_configuration_manager.py', module_path='omnibase_spi.protocols.core.protocol_configuration_manager', methods=['async load_configuration(config_name: str) -> dict[str, Any]', 'async validate_configuration(config_data: dict[str, Any]) -> bool', 'get_configuration_value(config_name: str, key: str) -> Any', 'set_configuration_value(config_name: str, key: str, value: Any) -> bool', 'async update_configuration_runtime(config_name: str, updates: dict[str, Any]) -> bool', 'async reload_configuration(config_name: str) -> bool', 'async backup_configuration(config_name: str) -> str | None', 'async restore_configuration(config_name: str, backup_path: str) -> bool', 'get_configuration_sources(config_name: str) -> list[dict[str, Any]]', 'add_configuration_source(config_name: str, source_type: str, source_path: str | None) -> bool', 'remove_configuration_source(config_name: str, source_type: str, source_path: str | None) -> bool', 'is_configuration_valid(config_name: str) -> bool', 'get_configuration_health(config_name: str) -> dict[str, Any]', 'list_configurations() -> list[str]', 'get_sensitive_keys(config_name: str) -> list[str]', 'mask_sensitive_values(config_data: dict[str, Any], config_name: str) -> dict[str, Any]'], signature_hash='e0517860c99ce865', line_count=16, imports=['typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable'], line_number=41, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration management implementations.\\n\\n    Configuration managers provide centralized configuration loading, validation,\\n    merging from multiple sources, and runtime reconfiguration capabilities for\\n    ONEX infrastructure components.\\n\\n    Example:\\n        class MyConfigurationManager:\\n            async def load_configuration(self, config_name: str) -> dict[str, Any]:\\n                # Load from multiple sources and merge\\n                return self._merge_configuration_sources(config_name)\\n\\n            async def validate_configuration(self, config_data: dict[str, Any]) -> bool:\\n                # Validate against schema and constraints\\n                return self._apply_validation_rules(config_data)\\n\\n            async def update_configuration_runtime(\\n                self, config_name: str, updates: dict[str, Any]\\n            ) -> bool:\\n                # Apply runtime configuration updates\\n                return await self._apply_runtime_updates(config_name, updates)\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationManagerFactory', file_path='src/omnibase_spi/protocols/core/protocol_configuration_manager.py', module_path='omnibase_spi.protocols.core.protocol_configuration_manager', methods=['async create_default() -> ProtocolConfigurationManager', 'async create_strict() -> ProtocolConfigurationManager', 'async create_runtime_enabled() -> ProtocolConfigurationManager', 'async create_custom() -> ProtocolConfigurationManager'], signature_hash='746a49fc4c2d26af', line_count=4, imports=['typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable'], line_number=378, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration manager factory implementations.\\n\\n    Factories create and configure configuration managers with different\\n    validation levels, source types, and runtime capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolTimeBasedOperations', file_path='src/omnibase_spi/protocols/core/protocol_time_based.py', module_path='omnibase_spi.protocols.core.protocol_time_based', methods=[\"async start_duration_tracking(operation_id: str) -> 'ProtocolDuration'\", \"complete_duration_tracking(operation_id: str) -> 'ProtocolDuration'\", \"get_operation_duration(operation_id: str) -> 'ProtocolDuration'\", \"set_timeout(operation_id: str, timeout_ms: int, warning_threshold_ms: int | None) -> 'ProtocolTimeout'\", 'is_timeout_expired(operation_id: str) -> bool', 'is_timeout_warning(operation_id: str) -> bool', 'get_timeout_remaining(operation_id: str) -> int', 'clear_timeout(operation_id: str) -> bool', \"async create_time_based_operation(operation_type: 'LiteralTimeBasedType', duration_ms: int) -> 'ProtocolTimeBased'\", 'is_operation_active(operation_id: str) -> bool', 'has_operation_expired(operation_id: str) -> bool', 'get_active_operations() -> list[str]', 'cleanup_expired_operations() -> int', 'get_time_based_metrics() -> dict[str, int | float]', 'reset_time_tracking() -> None', \"schedule_interval_operation(operation_id: str, interval_ms: int) -> 'ProtocolTimeBased'\", \"set_deadline(operation_id: str, deadline: 'ProtocolDateTime') -> 'ProtocolTimeBased'\", 'get_deadline_remaining(operation_id: str) -> int'], signature_hash='20f89dde0c530281', line_count=18, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralTimeBasedType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDuration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTimeBased', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTimeout'], line_number=21, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for time-based operations and measurements across ONEX services.\\n\\n    Provides consistent time tracking patterns, timeout management, and\\n    duration measurement for distributed system operations and monitoring.\\n\\n    Key Features:\\n        - Duration measurement for operation timing\\n        - Timeout management with early warning thresholds\\n        - Time-based scheduling and interval management\\n        - Deadline tracking for time-sensitive operations\\n        - Active time window management\\n        - Expiration detection and handling\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class TimeBasedOperationImpl:\\n            async def start_duration_tracking(self, operation_id):\\n                duration = DurationRecord(  # implements ProtocolDuration\\n                    start_time=datetime.now(),\\n                    end_time=None,\\n                    is_completed=False\\n                )\\n                self._active_durations[operation_id] = duration\\n                return duration\\n\\n            def set_timeout(self, operation_id, timeout_ms):\\n                timeout = TimeoutTracker(  # implements ProtocolTimeout\\n                    timeout_ms=timeout_ms,\\n                    start_time=datetime.now(),\\n                    warning_threshold_ms=timeout_ms * 0.8\\n                )\\n                self._active_timeouts[operation_id] = timeout\\n                return timeout\\n\\n        # Usage in application code\\n        time_ops: \"ProtocolTimeBasedOperations\" = TimeBasedOperationImpl()\\n\\n        # Start tracking an operation\\n        duration = time_ops.start_duration_tracking(\"data_processing\")\\n        timeout = time_ops.set_timeout(\"data_processing\", 30000)  # 30 seconds\\n\\n        # Check status during operation\\n        if time_ops.is_timeout_warning(\"data_processing\"):\\n            logger.warning(\"Operation approaching timeout\")\\n\\n        # Complete operation\\n        time_ops.complete_duration_tracking(\"data_processing\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflow', file_path='src/omnibase_spi/protocols/core/protocol_workflow_reducer.py', module_path='omnibase_spi.protocols.core.protocol_workflow_reducer', methods=['async run() -> Any'], signature_hash='c351b423870fb688', line_count=1, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAction', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolState'], line_number=21, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow objects - replaces LlamaIndex dependency.')",
        "ProtocolInfo(name='ProtocolWorkflowReducer', file_path='src/omnibase_spi/protocols/core/protocol_workflow_reducer.py', module_path='omnibase_spi.protocols.core.protocol_workflow_reducer', methods=['initial_state() -> ProtocolState', \"dispatch(state: 'ProtocolState', action: 'ProtocolAction') -> ProtocolState\", \"async dispatch_async(state: 'ProtocolState', action: 'ProtocolAction') -> ProtocolNodeResult\", 'async create_workflow() -> ProtocolWorkflow | None', \"async validate_state_transition(from_state: 'ProtocolState', action: 'ProtocolAction', to_state: 'ProtocolState') -> bool\", 'async get_state_schema() -> dict[str, Any] | None', 'async get_action_schema() -> dict[str, Any] | None'], signature_hash='6e4486f082db472e', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAction', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolState'], line_number=30, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Enhanced reducer protocol with workflow support.\\n\\n    Extends the basic reducer pattern to support:\\n    - Asynchronous workflow-based state transitions\\n    - Observable state changes via ProtocolNodeResult\\n    - Complex orchestration through workflow patterns\\n    - Monadic composition with error handling\\n    - Event emission for monitoring and coordination\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class UserWorkflowReducer:\\n            def initial_state(self) -> ProtocolState:\\n                return {\\n                    \"users\": {},\\n                    \"session_count\": 0,\\n                    \"last_activity\": None\\n                }\\n\\n            def dispatch(self, state: \"ProtocolState\", action: \"ProtocolAction\") -> ProtocolState:\\n                # Synchronous state transitions\\n                if action[\"type\"] == \"INCREMENT_SESSION\":\\n                    return {**state, \"session_count\": state[\"session_count\"] + 1}\\n                return state\\n\\n            async def dispatch_async(self, state: \"ProtocolState\",\\n                                   action: \"ProtocolAction\") -> ProtocolNodeResult:\\n                # Asynchronous workflow-based transitions\\n                if action[\"type\"] == \"CREATE_USER\":\\n                    try:\\n                        # Complex workflow: validate, create, notify\\n                        user_data = await self._validate_user(action[\"payload\"])\\n                        user_id = await self._create_user_in_db(user_data)\\n                        await self._send_welcome_email(user_id)\\n\\n                        new_state = {\\n                            **state,\\n                            \"users\": {**state[\"users\"], user_id: user_data}\\n                        }\\n\\n                        return ProtocolNodeResult(\\n                            value=new_state,\\n                            is_success=True,\\n                            events=[{\"type\": \"user_created\", \"user_id\": user_id}]\\n                        )\\n                    except Exception as e:\\n                        return ProtocolNodeResult(\\n                            is_failure=True,\\n                            error={\"message\": str(e), \"retryable\": True}\\n                        )\\n\\n        # Usage in application\\n        reducer: \"ProtocolWorkflowReducer\" = UserWorkflowReducer()\\n\\n        # Get initial state\\n        state = reducer.initial_state()\\n\\n        # Synchronous dispatch\\n        action = {\"type\": \"INCREMENT_SESSION\"}\\n        new_state = reducer.dispatch(state, action)\\n\\n        # Asynchronous dispatch\\n        async_action = {\\n            \"type\": \"CREATE_USER\",\\n            \"payload\": {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\\n        }\\n        result = await reducer.dispatch_async(state, async_action)\\n\\n        if result.is_success:\\n            final_state = result.value\\n            print(f\"User created, events: {result.events}\")\\n        else:\\n            print(f\"Error: {result.error}\")\\n        ```\\n\\n    State Management Patterns:\\n        - Immutable state updates (always return new state objects)\\n        - Event sourcing support through ProtocolNodeResult.events\\n        - Error propagation via monadic composition\\n        - Observable state changes for UI/monitoring integration\\n    ')",
        "ProtocolInfo(name='ProtocolValidationRule', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"is_applicable(target: ValidationTarget, context: dict[str, 'ContextValue']) -> bool\", \"async validate(target: ValidationTarget, context: dict[str, 'ContextValue']) -> 'ProtocolValidationResult'\", 'async get_dependencies() -> list[str]'], signature_hash='74be7864c32d7f2e', line_count=9, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=33, is_runtime_checkable=True, domain='core', properties=['rule_id: str', 'rule_name: str', 'rule_description: str', \"rule_version: 'ProtocolSemVer'\", \"severity: 'LiteralValidationSeverity'\", \"category: 'LiteralValidationCategory'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for individual validation rules.\\n\\n    Defines the structure for validation rules that can be applied\\n    to validate different aspects of ONEX components, configurations,\\n    and data structures.\\n\\n    Key Features:\\n        - Rule identification and metadata\\n        - Severity levels for validation outcomes\\n        - Conditional rule application\\n        - Rule composition and dependencies\\n\\n    Usage Example:\\n        ```python\\n        rule: \"ProtocolValidationRule\" = SomeValidationRule()\\n        if rule.is_applicable(target_object):\\n            result = rule.validate(target_object, context)\\n            if not result.is_valid:\\n                handle_validation_failure(result.errors)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationRuleSet', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async get_applicable_rules(target: ValidationTarget, context: dict[str, 'ContextValue']) -> list['ProtocolValidationRule']\", \"resolve_dependencies(rules: list['ProtocolValidationRule']) -> list['ProtocolValidationRule']\", \"async validate_rule_set(context: dict[str, 'ContextValue']) -> bool\"], signature_hash='856e336f1cc7461b', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=105, is_runtime_checkable=True, domain='core', properties=['rule_set_id: str', 'rule_set_name: str', \"rule_set_version: 'ProtocolSemVer'\", \"rules: list['ProtocolValidationRule']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for collections of validation rules.\\n\\n    Manages groups of related validation rules with dependency resolution,\\n    conditional execution, and rule composition capabilities.\\n\\n    Key Features:\\n        - Rule collection management\\n        - Dependency resolution and ordering\\n        - Conditional rule set application\\n        - Performance optimization through rule batching\\n\\n    Usage Example:\\n        ```python\\n        rule_set: \"ProtocolValidationRuleSet\" = ComplianceRuleSet()\\n        applicable_rules = rule_set.get_applicable_rules(target, context)\\n        execution_order = rule_set.resolve_dependencies(applicable_rules)\\n\\n        for rule in execution_order:\\n            result = rule.validate(target, context)\\n            if not result.is_valid:\\n                handle_rule_failure(rule, result)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationSession', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async start_validation(validation_name: str, targets: list[ValidationTarget], metadata: 'ProtocolMetadata | None') -> None\", \"async execute_validation_rules(rule_set: 'ProtocolValidationRuleSet', level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async get_session_progress() -> dict[str, 'ContextValue']\", \"async get_session_summary() -> dict[str, 'ContextValue']\", 'cancel_validation() -> bool', 'end_validation() -> None'], signature_hash='8ef319560a8c7cca', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=179, is_runtime_checkable=True, domain='core', properties=['session_id: str', 'session_name: str', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for validation execution sessions.\\n\\n    Manages the execution context and state for validation operations,\\n    providing session isolation, progress tracking, and result aggregation.\\n\\n    Key Features:\\n        - Session isolation and state management\\n        - Progress tracking and cancellation\\n        - Result aggregation and reporting\\n        - Performance metrics and diagnostics\\n\\n    Usage Example:\\n        ```python\\n        session: \"ProtocolValidationSession\" = ValidationSession()\\n        session.start_validation(\"component_validation\", targets)\\n\\n        try:\\n            results = session.execute_validation_rules(rule_set, level, mode)\\n            summary = session.get_session_summary()\\n            if not summary.overall_success:\\n                handle_validation_failures(results)\\n        finally:\\n            session.end_validation()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationProvider', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async register_validation_rule(rule: 'ProtocolValidationRule') -> bool\", 'async unregister_validation_rule(rule_id: str) -> bool', \"async get_validation_rule(rule_id: str) -> 'ProtocolValidationRule | None'\", \"async list_validation_rules(category_filter: 'LiteralValidationCategory | None', severity_filter: 'LiteralValidationSeverity | None') -> list['ProtocolValidationRule']\", \"async create_rule_set(rule_set_name: str, rule_ids: list[str], rule_set_metadata: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationRuleSet'\", \"async create_validation_session(session_name: str, session_metadata: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationSession'\", \"async get_active_sessions() -> list['ProtocolValidationSession']\", 'cleanup_completed_sessions(older_than_hours: int) -> int', \"async validate(targets: list[ValidationTarget], rule_sets: list['ProtocolValidationRuleSet'], level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async validate_with_session(session: 'ProtocolValidationSession', targets: list[ValidationTarget], rule_sets: list['ProtocolValidationRuleSet'], level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async validate_single(target: ValidationTarget, rule_set: 'ProtocolValidationRuleSet', level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationResult'\", \"is_validation_successful(results: list['ProtocolValidationResult']) -> bool\", \"async get_critical_issues(results: list['ProtocolValidationResult']) -> list['ProtocolValidationResult']\", \"async get_validation_summary(results: list['ProtocolValidationResult']) -> dict[str, 'ContextValue']\", \"async generate_quality_report(session: 'ProtocolValidationSession', results: list['ProtocolValidationResult'], report_format: str) -> str\", \"async get_provider_metrics() -> dict[str, 'ContextValue']\", \"optimize_rule_execution(rule_sets: list['ProtocolValidationRuleSet']) -> list['ProtocolValidationRuleSet']\", 'clear_validation_cache() -> bool', \"configure_provider(configuration: dict[str, 'ContextValue']) -> bool\", \"async get_provider_health() -> dict[str, 'ContextValue']\", 'async reset_provider_state() -> bool'], signature_hash='cbcbb52d9085ce35', line_count=26, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=285, is_runtime_checkable=True, domain='core', properties=['provider_id: str', 'provider_name: str', \"provider_version: 'ProtocolSemVer'\", \"supported_levels: list['LiteralValidationLevel']\", \"supported_modes: list['LiteralValidationMode']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for comprehensive validation model providers in ONEX systems.\\n\\n    This protocol defines the interface for validation providers that orchestrate\\n    validation workflows, manage validation rules and rule sets, and provide\\n    comprehensive quality assurance capabilities for ONEX services and components.\\n\\n    The validation provider serves as the central orchestration point for all\\n    validation activities, managing rule execution, result aggregation, and\\n    quality reporting across different validation levels and modes.\\n\\n    Key Features:\\n        - Multi-level validation orchestration (BASIC, STANDARD, COMPREHENSIVE, PARANOID)\\n        - Multiple execution modes (strict, lenient, smoke, regression, integration)\\n        - Dynamic rule management and composition\\n        - Session-based validation execution with progress tracking\\n        - Comprehensive result reporting and quality metrics\\n        - Performance optimization and caching\\n        - Plugin architecture for custom validation rules\\n\\n    Validation Levels:\\n        - BASIC: Essential validation only (fast performance)\\n        - STANDARD: Normal validation with common checks\\n        - COMPREHENSIVE: Thorough validation with detailed analysis\\n        - PARANOID: Maximum validation with all possible checks\\n\\n    Validation Modes:\\n        - strict: Fail on any validation error\\n        - lenient: Allow warnings but fail on errors\\n        - smoke: Basic functionality validation\\n        - regression: Validate against known good states\\n        - integration: Cross-system validation testing\\n\\n    Usage Example:\\n        ```python\\n        # Initialize validation provider\\n        provider: \"ProtocolValidationProvider\" = SomeValidationProvider()\\n\\n        # Register validation rules\\n        compliance_rules = provider.create_rule_set(\\n            \"compliance_validation\",\\n            [\"namespace_isolation\", \"protocol_purity\", \"import_validation\"]\\n        )\\n\\n        # Execute comprehensive validation\\n        session = provider.create_validation_session(\"component_audit\")\\n        results = provider.validate_with_session(\\n            session=session,\\n            targets=[component1, component2],\\n            rule_sets=[compliance_rules],\\n            level=\"COMPREHENSIVE\",\\n            mode=\"strict\"\\n        )\\n\\n        # Process results\\n        if not provider.is_validation_successful(results):\\n            failures = provider.get_critical_issues(results)\\n            handle_validation_failures(failures)\\n\\n        # Generate quality report\\n        report = provider.generate_quality_report(session, results)\\n        save_validation_report(report)\\n        ```\\n\\n    Integration Patterns:\\n        - Works with existing ProtocolValidationResult from protocol_core_types\\n        - Integrates with ONEX observability and monitoring systems\\n        - Supports custom rule development and plugin architecture\\n        - Compatible with CI/CD pipeline integration\\n        - Provides metrics for quality dashboards and alerting\\n    ')",
        "ProtocolInfo(name='ProtocolRetryable', file_path='src/omnibase_spi/protocols/core/protocol_retryable.py', module_path='omnibase_spi.protocols.core.protocol_retryable', methods=[\"async execute_with_retry(operation: Callable[..., Any], config: 'ProtocolRetryConfig') -> 'ProtocolRetryResult'\", \"configure_retry_policy(policy: 'ProtocolRetryPolicy') -> bool\", \"get_retry_policy() -> 'ProtocolRetryPolicy'\", \"should_retry(error: Exception, attempt_number: int, config: 'ProtocolRetryConfig') -> bool\", \"calculate_backoff_delay(attempt_number: int, strategy: 'LiteralRetryBackoffStrategy', base_delay_ms: int, max_delay_ms: int) -> int\", \"record_retry_attempt(attempt: 'ProtocolRetryAttempt') -> None\", \"get_retry_metrics() -> dict[str, 'ContextValue']\", 'reset_retry_budget() -> None', 'get_retry_budget_status() -> dict[str, int]', \"add_retry_condition(condition: 'LiteralRetryCondition', error_types: list[type[BaseException]]) -> bool\", \"remove_retry_condition(condition: 'LiteralRetryCondition') -> bool\", \"get_retry_conditions() -> list['LiteralRetryCondition']\"], signature_hash='4c8020f2e03012f7', line_count=12, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralRetryBackoffStrategy', 'omnibase_spi.protocols.types.protocol_core_types.LiteralRetryCondition', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryAttempt', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryConfig', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryPolicy', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryResult'], line_number=23, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized retry functionality across ONEX services.\\n\\n    Provides consistent retry patterns, backoff strategies, and policy\\n    management for resilient distributed system operations.\\n\\n    Key Features:\\n        - Configurable retry policies with multiple backoff strategies\\n        - Conditional retry logic based on error types and contexts\\n        - Retry attempt tracking with success/failure metrics\\n        - Backoff strategies: linear, exponential, fibonacci, fixed, jitter\\n        - Circuit breaker integration for fail-fast scenarios\\n        - Retry budget management to prevent resource exhaustion\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class RetryableServiceImpl:\\n            async def execute_with_retry(self, operation, config):\\n                for attempt in range(config.max_attempts):\\n                    try:\\n                        result = operation()\\n                        self._record_success(attempt)\\n                        return ProtocolRetryResult(success=True, result=result)\\n                    except Exception as e:\\n                        if not self._should_retry(e, attempt, config):\\n                            break\\n                        self._apply_backoff(attempt, config.backoff_strategy)\\n\\n                return ProtocolRetryResult(success=False, final_error=e)\\n\\n        # Usage in application code\\n        retryable: \"ProtocolRetryable\" = RetryableServiceImpl()\\n\\n        retry_config = \"ProtocolRetryConfig\"(\\n            max_attempts=5,\\n            backoff_strategy=\"fibonacci\",\\n            base_delay_ms=1000,\\n            max_delay_ms=30000\\n        )\\n\\n        result = retryable.execute_with_retry(\\n            operation=lambda: external_api_call(),\\n            config=retry_config\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolNodeConfiguration', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['get_config_value(key: str, default: ContextValue | None) -> ContextValue', 'get_timeout_ms(timeout_type: str, default_ms: int | None) -> int', 'get_security_config(key: str, default: ContextValue | None) -> ContextValue', 'get_business_logic_config(key: str, default: ContextValue | None) -> ContextValue', 'get_performance_config(key: str, default: ContextValue | None) -> ContextValue', 'has_config(key: str) -> bool', \"get_all_config() -> dict[str, 'ContextValue']\", 'async validate_config(config_key: str) -> bool', 'async validate_required_configs(required_keys: list[str]) -> dict[str, bool]', \"get_config_schema() -> dict[str, 'ContextValue']\"], signature_hash='7077782ae4c79847', line_count=10, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=13, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node configuration management.\\n\\n    Provides standardized configuration access for all ONEX nodes\\n    without coupling to specific configuration implementations.\\n\\n    Example:\\n        ```python\\n        # Basic usage\\n        config: \"ProtocolNodeConfiguration\" = get_node_config()\\n\\n        # Get configuration values\\n        api_url = config.get_config_value(\"api.base_url\", \"http://localhost:8080\")\\n        timeout = config.get_timeout_ms(\"api_call\", 5000)\\n\\n        # Domain-specific configurations\\n        auth_settings = config.get_security_config(\"authentication\")\\n        perf_limits = config.get_performance_config(\"memory.max_heap_mb\")\\n\\n        # Check configuration availability\\n        if config.has_config(\"feature.experimental\"):\\n            experimental_mode = config.get_config_value(\"feature.experimental\")\\n\\n        # Validate configurations\\n        is_valid = config.validate_config(\"api.base_url\")\\n        required_keys = [\"database.host\", \"database.port\", \"api.key\"]\\n        validation_results = config.validate_required_configs(required_keys)\\n\\n        # Get configuration schema\\n        schema = config.get_config_schema()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolNodeConfigurationProvider', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['async load_configuration(node_type: str, node_id: str) -> ProtocolNodeConfiguration', 'async reload_configuration() -> None', 'async validate_configuration() -> bool'], signature_hash='5e3442f0c0d2ad2e', line_count=3, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=181, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration provider implementations.\\n\\n    Allows different configuration backends (environment, files, databases)\\n    to be used interchangeably through dependency injection.\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationError', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['__str__() -> str', 'is_key_error(config_key: str) -> bool', 'get_error_context() -> dict[str, str | None]'], signature_hash='fea8191f0efacad5', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=226, is_runtime_checkable=True, domain='core', properties=['message: str', 'key: str | None', 'source: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration-related errors.\\n\\n    Provides structured error information for configuration failures\\n    with support for error formatting and context details.\\n\\n    Example:\\n        ```python\\n        error: \"ProtocolConfigurationError\" = ConfigError(\\n            message=\"Missing required configuration\",\\n            key=\"database.host\",\\n            source=\"environment\"\\n        )\\n\\n        # String representation\\n        error_msg = str(error)  # \"Config error in environment: Missing required configuration (key: database.host)\"\\n\\n        # Check if error is for specific key\\n        if error.is_key_error(\"database.host\"):\\n            # Handle specific key error\\n            ...\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolCacheService', file_path='src/omnibase_spi/protocols/core/protocol_cache_service.py', module_path='omnibase_spi.protocols.core.protocol_cache_service', methods=['async get(key: str) -> T | None', 'async set(key: str, value: T, ttl_seconds: int | None) -> bool', 'async delete(key: str) -> bool', 'async clear(pattern: str | None) -> int', 'async exists(key: str) -> bool', \"async get_stats() -> 'ProtocolCacheStatistics'\"], signature_hash='15a008944dbc67c1', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Generic', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCacheStatistics'], line_number=25, is_runtime_checkable=True, domain='core', properties=[], base_protocols=['Generic[T]'], protocol_type='mixin', docstring='\\n    Protocol for cache service operations.\\n\\n    Generic cache service supporting any serializable value type.\\n    Implementations can use in-memory, Redis, or other cache backends.\\n\\n    Example:\\n        ```python\\n        # String cache\\n        cache: \"ProtocolCacheService\"[str] = get_string_cache()\\n        await cache.set(\"user:123\", \"john_doe\", ttl_seconds=3600)\\n        username = await cache.get(\"user:123\")  # Returns Optional[str]\\n\\n        # Dict cache for complex data\\n        cache: \"ProtocolCacheService\"[dict[str, Any]] = get_dict_cache()\\n        user_data = {\"id\": 123, \"name\": \"John\", \"active\": True}\\n        await cache.set(\"user:123:profile\", user_data, ttl_seconds=1800)\\n\\n        # Cache operations\\n        exists = await cache.exists(\"user:123\")\\n        await cache.delete(\"user:123\")\\n        await cache.clear()  # Clear all cached data\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolCacheServiceProvider', file_path='src/omnibase_spi/protocols/core/protocol_cache_service.py', module_path='omnibase_spi.protocols.core.protocol_cache_service', methods=['async create_cache_service() -> ProtocolCacheService[T]', \"get_cache_configuration() -> dict[str, 'ContextValue']\"], signature_hash='566fbe05ed4e4253', line_count=2, imports=['typing.TYPE_CHECKING', 'typing.Generic', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCacheStatistics'], line_number=124, is_runtime_checkable=True, domain='core', properties=[], base_protocols=['Generic[T]'], protocol_type='mixin', docstring='Protocol for cache service provider.')",
        "ProtocolInfo(name='ProtocolNodeChangeCallback', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[\"__call__(node_info: 'ProtocolNodeInfo', change_type: str) -> None\"], signature_hash='17af6ac61c672534', line_count=1, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=24, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for node change callback functions.')",
        "ProtocolInfo(name='ProtocolWatchHandle', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='7723358402e554bd', line_count=2, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=33, is_runtime_checkable=True, domain='core', properties=['watch_id: str', 'is_active: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for watch handle objects.')",
        "ProtocolInfo(name='ProtocolNodeRegistryConfig', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='e1593fa9819aee74', line_count=5, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=41, is_runtime_checkable=True, domain='core', properties=['consul_host: str', 'consul_port: int', 'consul_token: str | None', 'health_check_interval: int', 'retry_attempts: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node registry configuration.')",
        "ProtocolInfo(name='ProtocolNodeInfo', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='1651be277fe5637d', line_count=11, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=52, is_runtime_checkable=True, domain='core', properties=['node_id: str', 'node_type: LiteralNodeType', 'node_name: str', 'environment: str', 'group: str', \"version: 'ProtocolSemVer'\", \"health_status: 'LiteralHealthStatus'\", 'endpoint: str', \"metadata: dict[str, 'ContextValue']\", \"registered_at: 'ProtocolDateTime'\", \"last_heartbeat: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for node information objects.')",
        "ProtocolInfo(name='ProtocolNodeRegistry', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=['environment() -> str', 'consul_endpoint() -> str | None', 'config() -> ProtocolNodeRegistryConfig | None', \"async register_node(node_info: 'ProtocolNodeInfo', ttl_seconds: int) -> bool\", 'async unregister_node(node_id: str) -> bool', \"async update_node_health(node_id: str, health_status: 'LiteralHealthStatus', metadata: dict[str, 'ContextValue']) -> bool\", 'async heartbeat(node_id: str) -> bool', \"async discover_nodes(node_type: 'LiteralNodeType | None', environment: str | None, group: str | None, health_filter: 'LiteralHealthStatus | None') -> list['ProtocolNodeInfo']\", 'async get_node(node_id: str) -> ProtocolNodeInfo | None', \"async get_nodes_by_group(group: str) -> list['ProtocolNodeInfo']\", 'async get_gateway_for_group(group: str) -> ProtocolNodeInfo | None', \"async watch_node_changes(callback: 'ProtocolNodeChangeCallback', node_type: 'LiteralNodeType | None', group: str | None) -> ProtocolWatchHandle\", \"async stop_watch(watch_handle: 'ProtocolWatchHandle') -> None\"], signature_hash='3958da80247eb054', line_count=13, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=69, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node discovery and registration services.\\n\\n    Supports the ONEX Messaging Design v0.3 patterns:\\n    - Environment isolation (dev, staging, prod)\\n    - Node group mini-meshes\\n    - Consul-based discovery integration\\n    - Health monitoring and heartbeat tracking\\n\\n    Implementations may use Consul, etcd, or other discovery backends.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class RegistryConsulNode:\\n            @property\\n            def environment(self) -> str: ...\\n\\n            @property\\n            def consul_endpoint(self) -> str: ...\\n\\n            @property\\n            def watches(self) -> dict[str, object]: ...\\n\\n            async def register_node(self, node_info: \"ProtocolNodeInfo\", ttl_seconds: int) -> bool:\\n                # Register node in Consul with TTL health check\\n                service_id = f\"{node_info.node_id}-{self.environment}\"\\n                return await self.consul.agent.service.register(\\n                    name=f\"{self.environment}-{node_info.group}-{node_info.node_type}\",\\n                    service_id=service_id,\\n                    address=node_info.endpoint.split(\\':\\')[0],\\n                    port=int(node_info.endpoint.split(\\':\\')[1]),\\n                    tags=[node_info.group, str(node_info.version)],\\n                    meta=node_info.metadata,\\n                    check=consul.Check.ttl(f\"{ttl_seconds}s\")\\n                )\\n\\n            async def discover_nodes(self, node_type: Optional[LiteralNodeType] = None,\\n                                   environment: Optional[str] = None,\\n                                   group: Optional[str] = None) -> list[\"ProtocolNodeInfo\"]:\\n                # Discover nodes from Consul catalog\\n                env = environment or self.environment\\n                service_filter = f\"{env}-\"\\n                if group:\\n                    service_filter += f\"{group}-\"\\n                if node_type:\\n                    service_filter += str(node_type)\\n\\n                services = await self.consul.catalog.services()\\n                matching_nodes = []\\n\\n                for service_name in services:\\n                    if service_name.startswith(service_filter):\\n                        service_info = await self.consul.catalog.service(service_name)\\n                        for node in service_info:\\n                            matching_nodes.append(self._convert_to_node_info(node))\\n\\n                return matching_nodes\\n\\n        # Usage in application\\n        registry: \"ProtocolNodeRegistry\" = RegistryConsulNode(\"prod\", \"consul.company.com:8500\")\\n\\n        # Register current node\\n        node_info = NodeInfo(\\n            node_id=\"worker-001\",\\n            node_type=\"COMPUTE\",\\n            node_name=\"Data Processor\",\\n            environment=\"prod\",\\n            group=\"analytics\",\\n            version=ProtocolSemVer(1, 2, 3),\\n            health_status=\"healthy\",\\n            endpoint=\"10.0.1.15:8080\",\\n            metadata={\"cpu_cores\": 8, \"memory_gb\": 32},\\n            registered_at=datetime.now(),\\n            last_heartbeat=datetime.now()\\n        )\\n\\n        success = await registry.register_node(node_info, ttl_seconds=60)\\n        if success:\\n            print(f\"Registered {node_info.node_name} successfully\")\\n\\n        # Discover compute nodes in analytics group\\n        compute_nodes = await registry.discover_nodes(\\n            node_type=\"COMPUTE\",\\n            environment=\"prod\",\\n            group=\"analytics\"\\n        )\\n\\n        print(f\"Found {len(compute_nodes)} compute nodes in analytics group\")\\n\\n        # Set up node change monitoring\\n        async def on_node_change(node: \"ProtocolNodeInfo\", change_type: str):\\n            print(f\"Node {node.node_name} changed: {change_type}\")\\n            if change_type == \"unhealthy\":\\n                # Implement failover logic\\n                await handle_node_failure(node)\\n\\n        watch_handle = await registry.watch_node_changes(\\n            callback=on_node_change,\\n            node_type=\"COMPUTE\",\\n            group=\"analytics\"\\n        )\\n\\n        # Send periodic heartbeats\\n        while True:\\n            await registry.heartbeat(node_info.node_id)\\n            await asyncio.sleep(30)  # Heartbeat every 30 seconds\\n        ```\\n\\n    Node Discovery Patterns:\\n        - Environment-based isolation: `prod-analytics-COMPUTE`\\n        - Group-based discovery: Find all nodes in a node group\\n        - Health-based filtering: Only discover healthy nodes\\n        - Type-based filtering: Find specific node types (COMPUTE, ORCHESTRATOR, etc.)\\n        - Watch-based monitoring: Real-time notifications of node changes\\n    ')",
        "ProtocolInfo(name='ProtocolErrorHandler', file_path='src/omnibase_spi/protocols/core/protocol_error_handler.py', module_path='omnibase_spi.protocols.core.protocol_error_handler', methods=[\"async handle_error(error: Exception, context: 'ProtocolErrorContext') -> 'ProtocolErrorResult'\", \"get_error_recovery_strategy(error_result: 'ProtocolErrorResult') -> 'ProtocolRecoveryAction'\", \"classify_error_severity(error: Exception, context: 'ProtocolErrorContext') -> 'LiteralErrorSeverity'\", \"should_retry_error(error_result: 'ProtocolErrorResult', attempt_count: int) -> bool\", \"get_backoff_delay_seconds(error_result: 'ProtocolErrorResult', attempt_count: int) -> float\", \"record_error_metrics(error_result: 'ProtocolErrorResult', recovery_outcome: str) -> None\", 'activate_circuit_breaker(service_name: str, error_threshold: int) -> bool', 'get_circuit_breaker_status(service_name: str) -> str', 'reset_circuit_breaker(service_name: str) -> bool', 'get_error_statistics(time_window_minutes: int) -> dict[str, object]'], signature_hash='111929d89f0c0180', line_count=10, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralErrorSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolErrorContext', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolErrorResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRecoveryAction'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized error handling across ONEX services.\\n\\n    Provides consistent error handling patterns, recovery strategies,\\n    and observability for distributed system reliability.\\n\\n    Key Features:\\n        - Standardized error classification and severity\\n        - Automatic recovery strategy selection\\n        - Error context capture and correlation\\n        - Circuit breaker pattern support\\n        - Comprehensive error observability\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ErrorHandlerImpl:\\n            def handle_error(self, error, context):\\n                error_result = self._classify_error(error)\\n                recovery_action = self.get_error_recovery_strategy(error_result)\\n                if recovery_action.action_type == \"retry\":\\n                    return self._retry_with_backoff(error_result, recovery_action)\\n                elif recovery_action.action_type == \"circuit_breaker\":\\n                    return self._activate_circuit_breaker(error_result)\\n                else:\\n                    return self._handle_terminal_error(error_result)\\n\\n        # Usage in application code\\n        error_handler: \"ProtocolErrorHandler\" = ErrorHandlerImpl()\\n\\n        try:\\n            result = risky_operation()\\n        except Exception as e:\\n            error_context = create_error_context(operation_name=\"risky_operation\")\\n            return error_handler.handle_error(e, error_context)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolServiceDiscovery', file_path='src/omnibase_spi/protocols/core/protocol_service_discovery.py', module_path='omnibase_spi.protocols.core.protocol_service_discovery', methods=[\"async register_service(service_name: str, service_id: str, host: str, port: int, metadata: 'ProtocolServiceMetadata', health_check_url: str | None, tags: list[str] | None) -> bool\", 'async deregister_service(service_id: str) -> bool', \"async discover_services(service_name: str, healthy_only: bool, tags: list[str] | None, limit: int | None, offset: int | None) -> tuple[list['ProtocolServiceInstance'], bool]\", \"async get_service_health(service_id: str) -> 'ProtocolServiceHealthStatus'\", 'async set_key_value(key: str, value: str) -> bool', 'async get_key_value(key: str) -> str | None', 'async delete_key(key: str) -> bool', 'async list_keys(prefix: str) -> list[str]', 'async health_check() -> bool', 'async close() -> None'], signature_hash='fb74c40ac07fe611', line_count=10, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceInstance', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceMetadata'], line_number=19, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service discovery systems.\\n\\n    Abstracts service registration, discovery, and health checking\\n    from specific implementations like Consul, etcd, or in-memory fallbacks.\\n\\n    Key Features:\\n        - Service registration and deregistration\\n        - Service discovery with health filtering\\n        - Key-value store functionality\\n        - Health monitoring capabilities\\n        - Clean resource management\\n    ')",
        "ProtocolInfo(name='ProtocolOnexNode', file_path='src/omnibase_spi/protocols/core/protocol_onex_node.py', module_path='omnibase_spi.protocols.core.protocol_onex_node', methods=['run() -> Any', \"get_node_config() -> 'ProtocolNodeConfiguration'\", 'get_input_model() -> type[Any]', 'get_output_model() -> type[Any]'], signature_hash='94540a976d94afb8', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_node_configuration.ProtocolNodeConfiguration'], line_number=10, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX node implementations.\\n\\n    All ONEX nodes must implement these methods to be compatible with the\\n    dynamic node loading system and container orchestration.\\n\\n    This protocol defines the standard interface that node_loader.py expects\\n    when loading and validating nodes.\\n\\n    Key Features:\\n        - Standard execution interface\\n        - Configuration metadata access\\n        - Input/output type definitions\\n        - Runtime compatibility validation\\n\\n    Breaking Changes (v2.0):\\n        - get_input_type() \u2192 get_input_model() for clarity\\n        - get_output_type() \u2192 get_output_model() for clarity\\n\\n    Migration Guide:\\n        For existing implementations, rename your methods:\\n        ```python\\n        # Old (v1.x)\\n        def get_input_type(self) -> type[Any]: ...\\n        def get_output_type(self) -> type[Any]: ...\\n\\n        # New (v2.0+)\\n        def get_input_model(self) -> type[Any]: ...\\n        def get_output_model(self) -> type[Any]: ...\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolContractService', file_path='src/omnibase_spi/protocols/core/protocol_contract_service.py', module_path='omnibase_spi.protocols.core.protocol_contract_service', methods=[\"async load_contract(contract_path: str) -> 'ProtocolMetadata'\", \"async validate_contract(contract_data: 'ProtocolMetadata') -> 'ProtocolValidationResult'\", \"async get_cached_contract(contract_path: str) -> 'ProtocolMetadata | None'\", \"cache_contract(contract_path: str, contract_data: 'ProtocolMetadata') -> bool\", 'clear_cache(contract_path: str | None) -> int', \"extract_node_id(contract_data: 'ProtocolMetadata') -> str\", \"extract_version(contract_data: 'ProtocolMetadata') -> 'ProtocolSemVer'\", \"extract_dependencies(contract_data: 'ProtocolMetadata') -> list[dict[str, 'ContextValue']]\", \"extract_tool_class_name(contract_data: 'ProtocolMetadata') -> str\", \"extract_event_patterns(contract_data: 'ProtocolMetadata') -> list[str]\", 'async get_cache_statistics() -> dict[str, object]', 'async health_check() -> dict[str, object]'], signature_hash='10682b829966dc3e', line_count=12, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for contract service operations following ONEX standards.\\n\\n    Provides contract management including loading, parsing, validation,\\n    caching, and metadata extraction for ONEX-compliant systems.\\n\\n    Key Features:\\n        - Contract loading and parsing from YAML files\\n        - Contract validation and structure verification\\n        - Contract caching for performance optimization\\n        - Contract metadata extraction and processing\\n        - Version management and dependency resolution\\n        - Event pattern extraction\\n        - Health monitoring\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ContractServiceImpl:\\n            async def load_contract(self, contract_path: str) -> dict:\\n                with open(contract_path) as f:\\n                    import yaml\\n                    return yaml.safe_load(f)\\n\\n            async def validate_contract(self, contract_data: dict) -> dict:\\n                # Validate contract structure and content\\n                is_valid = self._validate_structure(contract_data)\\n                return {\\n                    \\'is_valid\\': is_valid,\\n                    \\'errors\\': [],\\n                    \\'warnings\\': []\\n                }\\n\\n        # Usage in application code\\n        contract_service: \"ProtocolContractService\" = ContractServiceImpl()\\n\\n        contract = contract_service.load_contract(\\'/path/to/contract.yaml\\')\\n        validation_result = contract_service.validate_contract(contract)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolErrorSanitizer', file_path='src/omnibase_spi/protocols/core/protocol_error_sanitizer.py', module_path='omnibase_spi.protocols.core.protocol_error_sanitizer', methods=['sanitize_message(message: str) -> str', 'sanitize_exception(exception: Exception) -> Exception', 'sanitize_dict(data: dict[str, Any]) -> dict[str, Any]', 'sanitize_list(data: list[Any]) -> list[Any]', 'sanitize_file_path(path: str) -> str', 'get_cache_info() -> dict[str, Any]'], signature_hash='a7a3fecd3c225449', line_count=6, imports=['typing.Any', 'typing.Protocol', 'typing.runtime_checkable'], line_number=36, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for error message sanitization implementations.\\n\\n    Error sanitizers protect sensitive information by masking or removing\\n    confidential data from error messages, logs, and exception details\\n    while preserving debugging context.\\n\\n    Example:\\n        class MyErrorSanitizer:\\n            def sanitize_message(self, message: str) -> str:\\n                # Remove passwords, API keys, etc.\\n                return self._apply_sanitization_patterns(message)\\n\\n            def sanitize_exception(self, exception: Exception) -> Exception:\\n                sanitized_message = self.sanitize_message(str(exception))\\n                return type(exception)(sanitized_message)\\n    ')",
        "ProtocolInfo(name='ProtocolErrorSanitizerFactory', file_path='src/omnibase_spi/protocols/core/protocol_error_sanitizer.py', module_path='omnibase_spi.protocols.core.protocol_error_sanitizer', methods=['async create_default() -> ProtocolErrorSanitizer', 'async create_strict() -> ProtocolErrorSanitizer', 'async create_lenient() -> ProtocolErrorSanitizer', 'async create_custom() -> ProtocolErrorSanitizer'], signature_hash='fc5b155f4d4c8c12', line_count=4, imports=['typing.Any', 'typing.Protocol', 'typing.runtime_checkable'], line_number=126, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for error sanitizer factory implementations.\\n\\n    Factories create and configure error sanitizers with different\\n    security levels and pattern sets.\\n    ')",
        "ProtocolInfo(name='ProtocolCircuitBreakerConfig', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['failure_threshold() -> int', 'recovery_timeout_seconds() -> float', 'half_open_max_calls() -> int', 'success_threshold() -> int', 'metrics_window_seconds() -> float', 'request_timeout_seconds() -> float'], signature_hash='d76f76c058088f1a', line_count=6, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=51, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Configuration protocol for circuit breaker settings.')",
        "ProtocolInfo(name='ProtocolCircuitBreakerMetrics', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['total_requests() -> int', 'successful_requests() -> int', 'failed_requests() -> int', 'timeout_requests() -> int', \"current_state() -> 'LiteralProtocolCircuitBreakerState'\", 'state_changes() -> int', 'last_state_change() -> float | None', 'last_success_time() -> float | None', 'last_failure_time() -> float | None', 'average_response_time_ms() -> float', 'requests_in_window() -> int', 'failures_in_window() -> int', 'successes_in_window() -> int', 'half_open_requests() -> int', 'half_open_successes() -> int', 'half_open_failures() -> int', 'get_failure_rate() -> float', 'get_success_rate() -> float', 'reset_window() -> None'], signature_hash='af388124a55536e5', line_count=19, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=86, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Real-time circuit breaker metrics.')",
        "ProtocolInfo(name='ProtocolCircuitBreaker', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['service_name() -> str', \"get_state() -> 'LiteralProtocolCircuitBreakerState'\", 'get_metrics() -> ProtocolCircuitBreakerMetrics', 'async call(func: Callable[[], Awaitable[T]], fallback: Callable[[], Awaitable[T]] | None, timeout: float | None) -> T', 'async record_success(execution_time_ms: float | None) -> None', 'async record_failure(exception: Exception | None) -> None', 'async record_timeout() -> None'], signature_hash='260273100ac1c20a', line_count=7, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=188, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for circuit breaker fault tolerance implementations.\\n\\n    Circuit breakers prevent cascading failures by monitoring external\\n    service calls and temporarily stopping requests when failure thresholds\\n    are exceeded.\\n\\n    Example:\\n        class MyCircuitBreaker:\\n            def get_state(self) -> \"LiteralProtocolCircuitBreakerState\":\\n                return self._current_state\\n\\n            async def call(self, func, fallback=None, timeout=None):\\n                if self.get_state() == \"open\":\\n                    if fallback:\\n                        return await fallback()\\n                    raise Exception(\"Circuit breaker is open\")\\n\\n                try:\\n                    result = await func()\\n                    await self.record_success()\\n                    return result\\n                except Exception as e:\\n                    await self.record_failure(e)\\n                    raise\\n    ')",
        "ProtocolInfo(name='ProtocolCircuitBreakerFactory', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=[\"get_circuit_breaker(service_name: str, config: 'ProtocolCircuitBreakerConfig | None') -> ProtocolCircuitBreaker | None\", \"async register_circuit_breaker(service_name: str, circuit_breaker: 'ProtocolCircuitBreaker') -> None\", 'remove_circuit_breaker(service_name: str) -> bool', \"get_all_circuit_breakers() -> dict[str, 'ProtocolCircuitBreaker']\"], signature_hash='c73c2de64a7fbb00', line_count=4, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=287, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for circuit breaker factory implementations.\\n\\n    Factories manage circuit breaker instances and provide\\n    consistent configuration across services.\\n    ')",
        "ProtocolInfo(name='ProtocolHttpClientConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='95a6fcfc83f1473a', line_count=19, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['base_url: str', 'timeout_seconds: int', 'connect_timeout_seconds: int', 'read_timeout_seconds: int', 'max_retries: int', 'retry_delay_seconds: int', 'connection_pool_size: int', 'max_connections_per_host: int', 'ssl_verify: bool', 'ssl_cert_path: str | None', 'ssl_key_path: str | None', 'user_agent: str', \"default_headers: dict[str, 'ContextValue']\", 'proxy_url: str | None', 'proxy_auth: str | None', 'follow_redirects: bool', 'max_redirects: int', 'cookie_jar_enabled: bool', 'compression_enabled: bool'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for HTTP client configuration parameters.\\n\\n    Defines typed configuration structure for HTTP clients with\\n    connection pooling, security, retry logic, and performance settings.\\n\\n    Example:\\n        ```python\\n        config: \"ProtocolHttpClientConfig\" = get_http_config()\\n\\n        print(f\"Base URL: {config.base_url}\")\\n        print(f\"Timeout: {config.timeout_seconds}s\")\\n        print(f\"Pool size: {config.connection_pool_size}\")\\n        print(f\"SSL verify: {config.ssl_verify}\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpAuthConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='dcaea53f62a77f28', line_count=12, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=54, is_runtime_checkable=True, domain='core', properties=['auth_type: str', 'bearer_token: str | None', 'basic_username: str | None', 'basic_password: str | None', 'api_key_header: str | None', 'api_key_value: str | None', 'oauth2_client_id: str | None', 'oauth2_client_secret: str | None', 'oauth2_token_url: str | None', 'oauth2_scope: str | None', 'refresh_token_automatically: bool', 'token_expiry_buffer_seconds: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for HTTP authentication configuration.\\n\\n    Defines typed authentication settings for HTTP clients including\\n    various authentication schemes and credential management.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClientConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='8082bcf4cec48d35', line_count=16, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=77, is_runtime_checkable=True, domain='core', properties=['bootstrap_servers: list[str]', 'client_id: str', 'security_protocol: str', 'ssl_ca_location: str | None', 'ssl_certificate_location: str | None', 'ssl_key_location: str | None', 'ssl_key_password: str | None', 'sasl_mechanism: str | None', 'sasl_username: str | None', 'sasl_password: str | None', 'request_timeout_ms: int', 'retry_backoff_ms: int', 'max_retry_attempts: int', 'session_timeout_ms: int', 'heartbeat_interval_ms: int', 'max_poll_interval_ms: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka client configuration parameters.\\n\\n    Defines typed configuration structure for Kafka clients with\\n    connection settings, security, performance tuning, and reliability.\\n\\n    Example:\\n        ```python\\n        config: \"ProtocolKafkaClientConfig\" = get_kafka_config()\\n\\n        print(f\"Brokers: {config.bootstrap_servers}\")\\n        print(f\"Security: {config.security_protocol}\")\\n        print(f\"Batch size: {config.batch_size}\")\\n        print(f\"Compression: {config.compression_type}\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaProducerConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='948e6c5ecfebe02c', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=114, is_runtime_checkable=True, domain='core', properties=['acks: str', 'batch_size: int', 'linger_ms: int', 'buffer_memory: int', 'compression_type: str', 'max_in_flight_requests_per_connection: int', 'retries: int', 'delivery_timeout_ms: int', 'enable_idempotence: bool', 'transactional_id: str | None', 'max_request_size: int', 'send_buffer_bytes: int', 'receive_buffer_bytes: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka producer-specific configuration parameters.\\n\\n    Defines typed configuration for producer performance, reliability,\\n    and delivery semantics including batching and compression settings.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConsumerConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='c3493df7713c65db', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=138, is_runtime_checkable=True, domain='core', properties=['group_id: str', 'auto_offset_reset: str', 'enable_auto_commit: bool', 'auto_commit_interval_ms: int', 'max_poll_records: int', 'fetch_min_bytes: int', 'fetch_max_wait_ms: int', 'max_partition_fetch_bytes: int', 'check_crcs: bool', 'isolation_level: str', 'exclude_internal_topics: bool', 'partition_assignment_strategy: str', 'allow_auto_create_topics: bool'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka consumer-specific configuration parameters.\\n\\n    Defines typed configuration for consumer group management, offset handling,\\n    and message consumption patterns including auto-commit and fetch settings.\\n    ')",
        "ProtocolInfo(name='ProtocolClientConfigProvider', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=['async get_http_client_config(client_name: str) -> ProtocolHttpClientConfig', 'async get_http_auth_config(auth_name: str) -> ProtocolHttpAuthConfig', 'async get_kafka_client_config(client_name: str) -> ProtocolKafkaClientConfig', 'async get_kafka_producer_config(producer_name: str) -> ProtocolKafkaProducerConfig', 'async get_kafka_consumer_config(consumer_name: str) -> ProtocolKafkaConsumerConfig', 'async validate_configurations() -> list[str]', 'async reload_configurations() -> None', 'async get_configuration_summary() -> dict[str, dict[str, str | int | bool]]'], signature_hash='06697e3181df5285', line_count=8, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=162, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for client configuration provider.\\n\\n    Provides access to typed configuration objects for HTTP and Kafka clients\\n    with support for environment-based overrides and configuration validation.\\n\\n    Example:\\n        ```python\\n        provider: \"ProtocolClientConfigProvider\" = get_config_provider()\\n\\n        http_config = provider.get_http_client_config(\"api_client\")\\n        kafka_config = provider.get_kafka_client_config(\"event_processor\")\\n\\n        # Validate configurations\\n        await provider.validate_configurations()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolCanonicalSerializer', file_path='src/omnibase_spi/protocols/core/protocol_canonical_serializer.py', module_path='omnibase_spi.protocols.core.protocol_canonical_serializer', methods=[\"canonicalize_metadata_block(block: 'ProtocolNodeMetadata', volatile_fields: tuple[str, ...], placeholder: str) -> str\", 'normalize_body(body: str) -> str', \"canonicalize_for_hash(block: 'ProtocolNodeMetadata', body: str, volatile_fields: tuple[str, ...], placeholder: str) -> str\"], signature_hash='68958e2b7797b8df', line_count=3, imports=['typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ProtocolNodeMetadata'], line_number=31, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for canonical serialization and normalization of metadata blocks.\\n    Enforces protocol-compliant, deterministic serialization for stamping, hashing, and idempotency.\\n    All field references must use canonical Enums (e.g., NodeMetadataField), not string literals.\\n    Implementations may support YAML, JSON, or other formats.\\n\\n    NOTE: This protocol uses TYPE_CHECKING and forward references for data types to avoid circular imports\\n    while maintaining strong typing. This is the canonical pattern for all ONEX protocol interfaces.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowManageable', file_path='src/omnibase_spi/protocols/core/protocol_workflow_manageable.py', module_path='omnibase_spi.protocols.core.protocol_workflow_manageable', methods=[\"async create_workflow_instance(workflow_type: str, instance_id: UUID, initial_context: dict[str, 'ContextValue'], correlation_metadata: 'ProtocolMetadata', configuration: dict[str, 'ContextValue'] | None) -> 'ProtocolWorkflowSnapshot'\", \"async start_workflow_execution(workflow_type: str, instance_id: UUID, execution_context: dict[str, 'ContextValue']) -> bool\", 'async pause_workflow_execution(workflow_type: str, instance_id: UUID, reason: str | None) -> bool', 'async resume_workflow_execution(workflow_type: str, instance_id: UUID) -> bool', 'async terminate_workflow_execution(workflow_type: str, instance_id: UUID, termination_reason: str, force: bool) -> bool', \"async transition_workflow_state(workflow_type: str, instance_id: UUID, target_state: 'LiteralWorkflowState', event_metadata: dict[str, 'ContextValue'] | None, causation_id: UUID | None) -> bool\", \"async get_workflow_state(workflow_type: str, instance_id: UUID) -> 'LiteralWorkflowState'\", \"async get_workflow_snapshot(workflow_type: str, instance_id: UUID, include_task_details: bool) -> 'ProtocolWorkflowSnapshot'\", \"async schedule_workflow_task(workflow_type: str, instance_id: UUID, task_definition: dict[str, 'ContextValue'], dependencies: list[UUID] | None) -> UUID\", \"async update_task_state(workflow_type: str, instance_id: UUID, task_id: UUID, new_state: 'LiteralTaskState', result_data: dict[str, 'ContextValue'] | None) -> bool\", \"async get_task_dependencies_status(workflow_type: str, instance_id: UUID, task_id: UUID) -> dict[UUID, 'LiteralTaskState']\", \"async handle_workflow_event(workflow_event: 'ProtocolWorkflowEvent') -> bool\", \"async publish_workflow_event(workflow_type: str, instance_id: UUID, event_type: 'LiteralWorkflowEventType', event_data: dict[str, 'ContextValue'], causation_id: UUID | None, correlation_chain: list[UUID] | None) -> UUID\", \"async get_workflow_execution_metrics(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async get_workflow_performance_summary(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", 'async initiate_compensation(workflow_type: str, instance_id: UUID, compensation_reason: str, failed_task_id: UUID | None) -> bool', \"async check_compensation_status(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async validate_workflow_consistency(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async get_workflow_health_status(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\"], signature_hash='41515d0e03025a5e', line_count=19, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=69, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for entities that can be managed within workflow orchestration.\\n\\n    This protocol defines the contract for workflow lifecycle management,\\n    state transitions, execution monitoring, and event coordination within\\n    the ONEX distributed orchestration framework.\\n\\n    Key Capabilities:\\n        - Complete workflow lifecycle management\\n        - Event-driven state transitions with FSM support\\n        - Real-time execution monitoring and metrics\\n        - Workflow instance isolation and correlation\\n        - Compensation action support for saga patterns\\n        - Distributed task coordination and dependency resolution\\n    ')",
        "ProtocolInfo(name='ProtocolOnexContractData', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='d8bae3b6f89e54aa', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=19, is_runtime_checkable=True, domain='core', properties=[\"contract_version: 'ProtocolSemVer'\", 'node_name: str', 'node_type: str', 'input_model: str', 'output_model: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX contract data structure protocol.')",
        "ProtocolInfo(name='ProtocolOnexSecurityContext', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='1a51f13da224bc53', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=30, is_runtime_checkable=True, domain='core', properties=['user_id: str', 'session_id: str', 'authentication_token: str', 'security_profile: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX security context data protocol.')",
        "ProtocolInfo(name='ProtocolOnexMetadata', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='39f114c870bbe4e9', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='core', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", \"timestamp: 'ProtocolDateTime'\", 'environment: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX metadata structure protocol.')",
        "ProtocolInfo(name='ProtocolOnexSchema', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='bceb39ff06615e07', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=50, is_runtime_checkable=True, domain='core', properties=['schema_type: str', \"version: 'ProtocolSemVer'\", \"properties: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='ONEX schema definition protocol.')",
        "ProtocolInfo(name='ProtocolOnexValidationReport', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='0b96d723615ed498', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=59, is_runtime_checkable=True, domain='core', properties=['total_validations: int', 'passed_validations: int', 'failed_validations: int', 'overall_status: str', 'summary: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX validation report protocol.')",
        "ProtocolInfo(name='ProtocolOnexValidationResult', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='5c8bbc5313a21449', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=86, is_runtime_checkable=True, domain='core', properties=['is_valid: bool', 'compliance_level: LiteralOnexComplianceLevel', 'validation_type: LiteralValidationType', 'errors: list[str]', 'warnings: list[str]', \"metadata: 'ProtocolOnexMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Result of Onex validation protocol.')",
        "ProtocolInfo(name='ProtocolOnexValidation', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[\"async validate_envelope(envelope: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_reply(reply: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_contract_compliance(contract_data: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_security_context(security_context: 'ProtocolOnexSecurityContext') -> ProtocolOnexValidationResult\", \"async validate_metadata(metadata: 'ProtocolOnexMetadata') -> ProtocolOnexValidationResult\", \"async validate_full_onex_pattern(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async check_required_fields(data: 'ProtocolOnexContractData', required_fields: list[str]) -> list[str]\", 'async validate_semantic_versioning(version: str) -> bool', \"async validate_correlation_id_consistency(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> bool\", \"async validate_timestamp_sequence(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> bool\", 'get_validation_schema(validation_type: LiteralValidationType) -> ProtocolOnexSchema', \"async validate_against_schema(data: 'ProtocolOnexContractData', schema: 'ProtocolOnexSchema') -> ProtocolOnexValidationResult\", \"generate_validation_report(results: list['ProtocolOnexValidationResult']) -> ProtocolOnexValidationReport\", \"is_production_ready(validation_results: list['ProtocolOnexValidationResult']) -> bool\"], signature_hash='0f1d573f6cf6f3d7', line_count=14, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=98, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex validation and compliance checking.\\n\\n    All ONEX tools must implement this protocol for Onex pattern validation.\\n    Provides standardized validation for envelopes, replies, and contract compliance.\\n    ')",
        "ProtocolInfo(name='ProtocolNodeDiscoveryRegistry', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[\"async register_discovery_source(discovery: 'ProtocolHandlerDiscovery') -> None\", 'async discover_and_register_nodes() -> None', \"async register_node_info(node_info: 'ProtocolHandlerInfo') -> None\"], signature_hash='70adf825b6dbfa40', line_count=3, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=148, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node registries that support dynamic discovery.\\n\\n    This protocol extends the basic node registry with discovery capabilities,\\n    allowing nodes to be registered from multiple sources without hardcoded imports.\\n        ...\\n    ')"
      ],
      "memory": [
        "ProtocolInfo(name='ProtocolMemoryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['error_message() -> str | None'], signature_hash='599905a66343b975', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=45, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool'], base_protocols=[], protocol_type='functional', docstring='Base protocol for all memory operation responses.')",
        "ProtocolInfo(name='ProtocolMemoryStoreResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='659e548162a57a30', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=59, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID | None', 'storage_location: str | None'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory storage responses.')",
        "ProtocolInfo(name='ProtocolMemoryRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"related_memories() -> list['ProtocolMemoryRecord']\"], signature_hash='23a60770d9a3c1f3', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=67, is_runtime_checkable=True, domain='memory', properties=[\"memory: 'ProtocolMemoryRecord | None'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolMemoryListResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='c692aeea3907b229', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=79, is_runtime_checkable=True, domain='memory', properties=[\"memories: list['ProtocolMemoryRecord']\", \"pagination: 'ProtocolPaginationResponse'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for paginated memory list responses.')",
        "ProtocolInfo(name='ProtocolBatchOperationResult', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['execution_time_ms() -> int'], signature_hash='7015a3ae0035dc6a', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=87, is_runtime_checkable=True, domain='memory', properties=['operation_index: int', 'success: bool', 'result_id: UUID | None', \"error: 'ProtocolMemoryError | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual batch operation results.')",
        "ProtocolInfo(name='ProtocolBatchMemoryStoreResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['partial_success() -> bool'], signature_hash='1506c0dbd32ccb3a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=102, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolBatchOperationResult']\", 'total_processed: int', 'successful_count: int', 'failed_count: int', 'batch_execution_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for batch memory storage responses.')",
        "ProtocolInfo(name='ProtocolBatchMemoryRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='06c1dfe5de69e8c4', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=118, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolBatchOperationResult']\", \"memories: list['ProtocolMemoryRecord']\", 'missing_ids: list[UUID]', 'batch_execution_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for batch memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolSemanticSearchResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async query_embedding() -> list[float] | None'], signature_hash='47a7415708d3b6bd', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=128, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolSearchResult']\", 'total_matches: int', 'search_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for semantic search responses.')",
        "ProtocolInfo(name='ProtocolPatternAnalysisResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['confidence_scores() -> list[float]'], signature_hash='b9aef8dcc783f286', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=142, is_runtime_checkable=True, domain='memory', properties=['patterns_found: int', \"analysis_results: 'ProtocolAnalysisResults'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for pattern analysis responses.')",
        "ProtocolInfo(name='ProtocolEmbeddingResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='6c262ef0dd712c8d', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=155, is_runtime_checkable=True, domain='memory', properties=['embedding: list[float]', 'algorithm_used: str', 'dimensions: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for embedding generation responses.')",
        "ProtocolInfo(name='ProtocolConsolidationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='8e6d9034c86bd486', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=164, is_runtime_checkable=True, domain='memory', properties=['consolidated_memory_id: UUID', 'source_memory_ids: list[UUID]'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory consolidation responses.')",
        "ProtocolInfo(name='ProtocolAggregationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='6332c80f2d979087', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=172, is_runtime_checkable=True, domain='memory', properties=[\"aggregated_data: 'ProtocolAggregatedData'\", \"aggregation_metadata: 'ProtocolMemoryMetadata'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory aggregation responses.')",
        "ProtocolInfo(name='ProtocolWorkflowExecutionResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"agent_statuses() -> 'ProtocolAgentStatusMap'\"], signature_hash='f1eaa662fe533e24', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=180, is_runtime_checkable=True, domain='memory', properties=['workflow_id: UUID', 'execution_status: str'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for workflow execution responses.')",
        "ProtocolInfo(name='ProtocolAgentCoordinationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"agent_responses() -> 'ProtocolAgentResponseMap'\"], signature_hash='1aae9ac4c21ec107', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=193, is_runtime_checkable=True, domain='memory', properties=['coordination_id: UUID', 'coordination_status: str'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for agent coordination responses.')",
        "ProtocolInfo(name='ProtocolPaginationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"page_info() -> 'ProtocolPageInfo'\"], signature_hash='c0c5189e2eb4250d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=206, is_runtime_checkable=True, domain='memory', properties=['total_count: int', 'has_next_page: bool', 'has_previous_page: bool', 'next_cursor: str | None', 'previous_cursor: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for paginated response metadata.')",
        "ProtocolInfo(name='ProtocolMemoryMetrics', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['throughput_ops_per_second() -> float', 'error_rate_percent() -> float', \"custom_metrics() -> 'ProtocolCustomMetrics'\"], signature_hash='e4fee6766ba520a7', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=222, is_runtime_checkable=True, domain='memory', properties=['operation_type: str', 'execution_time_ms: int', 'memory_usage_mb: float', \"timestamp: 'datetime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for memory system performance metrics.')",
        "ProtocolInfo(name='ProtocolMemoryMetricsResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='e17c7551df9d0c64', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=247, is_runtime_checkable=True, domain='memory', properties=[\"metrics: list['ProtocolMemoryMetrics']\", \"aggregation_summary: 'ProtocolAggregationSummary'\", \"collection_timestamp: 'datetime'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for metrics collection responses.')",
        "ProtocolInfo(name='ProtocolStreamingMemoryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async stream_content() -> AsyncIterator[bytes]', 'compression_ratio() -> float | None'], signature_hash='ec8c1b6faa676117', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=256, is_runtime_checkable=True, domain='memory', properties=['stream_id: UUID', 'chunk_count: int', 'total_size_bytes: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for streaming memory operation responses.')",
        "ProtocolInfo(name='ProtocolStreamingRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async stream_memory_content(memory_id: UUID) -> AsyncIterator[bytes]'], signature_hash='09f26d5797860c26', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=274, is_runtime_checkable=True, domain='memory', properties=[\"memory_metadata: list['ProtocolMemoryRecord']\"], base_protocols=['ProtocolStreamingMemoryResponse'], protocol_type='functional', docstring='Protocol for streaming memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolKeyValueStore', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['keys() -> list[str]', 'async get_value(key: str) -> str | None', 'has_key(key: str) -> bool', 'async validate_store() -> bool'], signature_hash='ac1b1a6e880a7f1f', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=40, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Base protocol for key-value storage structures with validation.')",
        "ProtocolInfo(name='ProtocolMemoryMetadata', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metadata_keys() -> list[str]', 'async get_metadata_value(key: str) -> str | None', 'has_metadata_key(key: str) -> bool'], signature_hash='c165197fe0febe6e', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=62, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for memory metadata structures.')",
        "ProtocolInfo(name='ProtocolWorkflowConfiguration', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['configuration_keys() -> list[str]', 'async get_configuration_value(key: str) -> str | None', 'async validate_configuration() -> bool'], signature_hash='d329a2c876121d67', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=80, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for workflow configuration structures.')",
        "ProtocolInfo(name='ProtocolAnalysisParameters', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['parameter_keys() -> list[str]', 'async get_parameter_value(key: str) -> str | None', 'async validate_parameters() -> bool'], signature_hash='84ad372195bdc6ed', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=98, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for analysis parameter structures.')",
        "ProtocolInfo(name='ProtocolAggregationCriteria', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['criteria_keys() -> list[str]', 'async get_criteria_value(key: str) -> str | None', 'async validate_criteria() -> bool'], signature_hash='d67aa240be4bc351', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=116, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for aggregation criteria structures.')",
        "ProtocolInfo(name='ProtocolCoordinationMetadata', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metadata_keys() -> list[str]', 'async get_metadata_value(key: str) -> str | None', 'async validate_metadata() -> bool'], signature_hash='49fe1ed42efa7947', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=134, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for coordination metadata structures.')",
        "ProtocolInfo(name='ProtocolAnalysisResults', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['result_keys() -> list[str]', 'async get_result_value(key: str) -> str | None', 'has_result_key(key: str) -> bool'], signature_hash='250df27571aff957', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=152, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for analysis result structures.')",
        "ProtocolInfo(name='ProtocolAggregatedData', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['data_keys() -> list[str]', 'async get_data_value(key: str) -> str | None', 'async validate_data() -> bool'], signature_hash='0346848e77855909', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=170, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for aggregated data structures.')",
        "ProtocolInfo(name='ProtocolMemoryErrorContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['context_keys() -> list[str]', 'async get_context_value(key: str) -> str | None', 'add_context(key: str, value: str) -> None'], signature_hash='b3f4da92cfd5cfa3', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=188, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for error context structures.')",
        "ProtocolInfo(name='ProtocolPageInfo', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['info_keys() -> list[str]', 'async get_info_value(key: str) -> str | None', 'has_next_page() -> bool'], signature_hash='67c607fecb7047d1', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=206, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for pagination information structures.')",
        "ProtocolInfo(name='ProtocolCustomMetrics', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metric_names() -> list[str]', 'async get_metric_value(name: str) -> float | None', 'has_metric(name: str) -> bool'], signature_hash='bc0f2052ebede274', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=224, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for custom metrics structures.')",
        "ProtocolInfo(name='ProtocolAggregationSummary', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['summary_keys() -> list[str]', 'async get_summary_value(key: str) -> float | None', 'calculate_total() -> float', 'async validate_record_data() -> bool'], signature_hash='612ac2f3a9369af5', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=242, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for aggregation summary structures.')",
        "ProtocolInfo(name='ProtocolMemoryRecord', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['embedding() -> list[float] | None', 'related_memories() -> list[UUID]'], signature_hash='e1ccef920653da8f', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=267, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID', 'content: str', 'content_type: str', \"created_at: 'datetime'\", \"updated_at: 'datetime'\", 'access_level: LiteralMemoryAccessLevel', 'source_agent: str', \"expires_at: 'datetime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for memory record data structure.')",
        "ProtocolInfo(name='ProtocolSearchResult', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['highlighted_content() -> str | None'], signature_hash='b1d90daf0ba048ef', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=291, is_runtime_checkable=True, domain='memory', properties=[\"memory_record: 'ProtocolMemoryRecord'\", 'relevance_score: float', 'match_type: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for search result data structure.')",
        "ProtocolInfo(name='ProtocolSearchFilters', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['tags() -> list[str] | None'], signature_hash='9df61c28ab89700d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=305, is_runtime_checkable=True, domain='memory', properties=['content_types: list[str] | None', 'access_levels: list[str] | None', 'source_agents: list[str] | None', \"date_range_start: 'datetime | None'\", \"date_range_end: 'datetime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for search filter specifications.')",
        "ProtocolInfo(name='ProtocolAgentStatusMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['agent_ids() -> list[UUID]', 'async get_agent_status(agent_id: UUID) -> str | None', 'async set_agent_status(agent_id: UUID, status: str) -> None', 'async get_all_statuses() -> dict[UUID, str]'], signature_hash='9397aa791b6dc543', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=321, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for agent status mapping structures.')",
        "ProtocolInfo(name='ProtocolAgentResponseMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['responding_agents() -> list[UUID]', 'async get_agent_response(agent_id: UUID) -> str | None', 'add_agent_response(agent_id: UUID, response: str) -> None', 'async get_all_responses() -> dict[UUID, str]'], signature_hash='77579e967fda063a', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=343, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for agent response mapping structures.')",
        "ProtocolInfo(name='ProtocolErrorCategoryMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['category_names() -> list[str]', 'async get_category_count(category: str) -> int', 'increment_category(category: str) -> None', 'async get_all_counts() -> dict[str, int]'], signature_hash='99b3c714fee57796', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=365, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for error category counting structures.')",
        "ProtocolInfo(name='ProtocolWorkflowManager', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async execute_workflow(request: 'ProtocolWorkflowExecutionRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolWorkflowExecutionResponse'\", \"async pause_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async resume_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async cancel_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async get_workflow_status(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='6b909b2ff4348696', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=29, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for workflow management operations.\\n\\n    Handles workflow execution, monitoring, and lifecycle management\\n    without agent coordination complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolAgentCoordinator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async coordinate_agents(request: 'ProtocolAgentCoordinationRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolAgentCoordinationResponse'\", \"async register_agent(agent_id: UUID, agent_capabilities: list[str], agent_metadata: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async unregister_agent(agent_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async get_agent_status(agent_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async list_available_agents(capability_filter: list[str] | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='f16072fe301c0566', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=155, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for agent coordination operations.\\n\\n    Handles agent management, coordination, and communication\\n    without workflow execution complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolClusterCoordinator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async broadcast_update(update_type: str, update_data: 'ProtocolMemoryMetadata', target_nodes: list[UUID] | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async synchronize_state(node_ids: list[UUID], synchronization_scope: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async get_cluster_status(include_node_details: bool, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async perform_cluster_maintenance(maintenance_type: str, maintenance_parameters: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='17f282a5212e4f95', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=285, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for cluster-wide coordination operations.\\n\\n    Handles distributed memory operations, synchronization, and\\n    cluster state management.\\n    ')",
        "ProtocolInfo(name='ProtocolLifecycleManager', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async apply_retention_policies(policy_scope: 'ProtocolMemoryMetadata', dry_run: bool, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async archive_memories(memory_ids: list[UUID], archive_destination: str, archive_format: str, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async cleanup_expired_memories(cleanup_scope: 'ProtocolMemoryMetadata', safety_threshold_hours: int, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async restore_archived_memories(archive_reference: str, restore_destination: str | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='9b9866f31c5a3800', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=401, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for memory lifecycle management operations.\\n\\n    Handles memory retention policies, archival, and cleanup\\n    without orchestration complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryOrchestrator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async health_check(check_scope: str, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='73e2ffc28de7cf0e', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=525, is_runtime_checkable=True, domain='memory', properties=[\"workflow_manager: 'ProtocolWorkflowManager'\", \"agent_coordinator: 'ProtocolAgentCoordinator'\", \"cluster_coordinator: 'ProtocolClusterCoordinator'\", \"lifecycle_manager: 'ProtocolLifecycleManager'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Composite interface combining all orchestration capabilities.\\n\\n    This interface can be implemented by combining the smaller focused\\n    interfaces above, or implemented directly for comprehensive orchestration.\\n    ')",
        "ProtocolInfo(name='ProtocolComputeNodeComposite', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async process_semantics(content: str, processing_options: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async analyze_patterns(data_source: 'ProtocolMemoryMetadata', analysis_type: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async generate_embeddings(content_items: list[str], embedding_model: str | None, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='d16e85c559c27180', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=563, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Composite interface that can split compute operations into focused areas.\\n\\n    Allows implementation as separate semantic processing, pattern analysis,\\n    and embedding generation services that can be coordinated independently.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['operation_type() -> str'], signature_hash='00530f390437b78f', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=40, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"request_timestamp: 'datetime'\"], base_protocols=[], protocol_type='functional', docstring='Base protocol for all memory operation requests.')",
        "ProtocolInfo(name='ProtocolMemoryStoreRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"metadata() -> 'ProtocolMemoryMetadata | None'\"], signature_hash='4e2023dde9aee1f3', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=53, is_runtime_checkable=True, domain='memory', properties=['content: str', 'content_type: str', 'access_level: str', 'source_agent: str', \"expires_at: 'datetime | None'\"], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for memory storage requests.')",
        "ProtocolInfo(name='ProtocolMemoryRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['related_depth() -> int'], signature_hash='b0a03098fdbd50aa', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=69, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID', 'include_related: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolMemoryListRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['include_content() -> bool'], signature_hash='bdea28e77b495260', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=83, is_runtime_checkable=True, domain='memory', properties=[\"pagination: 'ProtocolPaginationRequest'\", \"filters: 'ProtocolSearchFilters | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for paginated memory list requests.')",
        "ProtocolInfo(name='ProtocolBatchMemoryStoreRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['transaction_isolation() -> str', 'parallel_execution() -> bool'], signature_hash='8e6446af0573ecc5', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=97, is_runtime_checkable=True, domain='memory', properties=[\"memory_records: list['ProtocolAggregatedData']\", 'batch_size: int', 'fail_on_first_error: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for batch memory storage requests.')",
        "ProtocolInfo(name='ProtocolBatchMemoryRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['related_depth() -> int'], signature_hash='4935f4f8a409577b', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=117, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'include_related: bool', 'fail_on_missing: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for batch memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolSemanticSearchRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['embedding_model() -> str | None'], signature_hash='e84a3075135c054d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=132, is_runtime_checkable=True, domain='memory', properties=['query: str', 'limit: int', 'similarity_threshold: float', \"filters: 'ProtocolSearchFilters | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for semantic search requests.')",
        "ProtocolInfo(name='ProtocolPatternAnalysisRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"analysis_parameters() -> 'ProtocolAnalysisParameters'\"], signature_hash='c851cce0aa698593', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=148, is_runtime_checkable=True, domain='memory', properties=['data_source: str', \"analysis_type: 'LiteralAnalysisType'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for pattern analysis requests.')",
        "ProtocolInfo(name='ProtocolEmbeddingRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='e631c61ebf6335ce', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=162, is_runtime_checkable=True, domain='memory', properties=['text: str', 'algorithm: str | None', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for embedding generation requests.')",
        "ProtocolInfo(name='ProtocolConsolidationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='3856778abfd4669a', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=171, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'consolidation_strategy: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for memory consolidation requests.')",
        "ProtocolInfo(name='ProtocolAggregationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='5615f81b28fdab9c', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=180, is_runtime_checkable=True, domain='memory', properties=[\"aggregation_criteria: 'ProtocolAggregationCriteria'\", \"time_window_start: 'datetime | None'\", \"time_window_end: 'datetime | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for memory aggregation requests.')",
        "ProtocolInfo(name='ProtocolWorkflowExecutionRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['async target_agents() -> list[UUID]'], signature_hash='c30c0d5affbb8144', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=190, is_runtime_checkable=True, domain='memory', properties=['workflow_type: str', \"workflow_configuration: 'ProtocolWorkflowConfiguration'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for workflow execution requests.')",
        "ProtocolInfo(name='ProtocolAgentCoordinationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"coordination_metadata() -> 'ProtocolCoordinationMetadata'\"], signature_hash='67a9c21068b8d46a', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=204, is_runtime_checkable=True, domain='memory', properties=['agent_ids: list[UUID]', 'coordination_task: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for agent coordination requests.')",
        "ProtocolInfo(name='ProtocolPaginationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['sort_by() -> str | None', 'sort_order() -> str'], signature_hash='b5511d52f55c9235', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=218, is_runtime_checkable=True, domain='memory', properties=['limit: int', 'offset: int', 'cursor: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for paginated request parameters.')",
        "ProtocolInfo(name='ProtocolMemoryMetricsRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['include_detailed_breakdown() -> bool'], signature_hash='c2e40d3bed8bf607', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=237, is_runtime_checkable=True, domain='memory', properties=['metric_types: list[str]', \"time_window_start: 'datetime | None'\", \"time_window_end: 'datetime | None'\", 'aggregation_level: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for metrics collection requests.')",
        "ProtocolInfo(name='ProtocolStreamingMemoryRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['compression_enabled() -> bool'], signature_hash='2b2a141de9a04f6c', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=253, is_runtime_checkable=True, domain='memory', properties=['stream_type: str', 'chunk_size: int', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for streaming memory operations.')",
        "ProtocolInfo(name='ProtocolStreamingRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['max_content_size() -> int | None'], signature_hash='7cf2b5b8869627f7', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=267, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'include_metadata: bool'], base_protocols=['ProtocolStreamingMemoryRequest'], protocol_type='functional', docstring='Protocol for streaming memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolMemoryEffectNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async store_memory(request: 'ProtocolMemoryStoreRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryStoreResponse'\", \"async retrieve_memory(request: 'ProtocolMemoryRetrieveRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryRetrieveResponse'\", \"async update_memory(memory_id: UUID, updates: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async delete_memory(memory_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async list_memories(request: 'ProtocolMemoryListRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryListResponse'\", \"async batch_store_memories(request: 'ProtocolBatchMemoryStoreRequest', security_context: 'ProtocolMemorySecurityContext | None', rate_limit_config: 'ProtocolRateLimitConfig | None', timeout_seconds: float | None) -> 'ProtocolBatchMemoryStoreResponse'\", \"async batch_retrieve_memories(request: 'ProtocolBatchMemoryRetrieveRequest', security_context: 'ProtocolMemorySecurityContext | None', rate_limit_config: 'ProtocolRateLimitConfig | None', timeout_seconds: float | None) -> 'ProtocolBatchMemoryRetrieveResponse'\"], signature_hash='13fe2e2d1e420133', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=59, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory effect operations in ONEX architecture.\\n\\n    Handles storage, retrieval, and persistence of memory records\\n    with transactional guarantees and consistency management.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryComputeNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async semantic_search(request: 'ProtocolSemanticSearchRequest') -> 'ProtocolSemanticSearchResponse'\", \"async generate_embedding(text: str, model: str | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async analyze_patterns(request: 'ProtocolPatternAnalysisRequest', timeout_seconds: float | None) -> 'ProtocolPatternAnalysisResponse'\", \"async extract_insights(memory_ids: list[UUID], analysis_type: 'LiteralAnalysisType', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async compare_semantics(content_a: str, content_b: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='cc5e7cecf45b38b4', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=250, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory compute operations in ONEX architecture.\\n\\n    Handles intelligence processing, semantic analysis, and pattern recognition\\n    with advanced AI capabilities and embedding generation.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryReducerNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async consolidate_memories(request: 'ProtocolConsolidationRequest', timeout_seconds: float | None) -> 'ProtocolConsolidationResponse'\", \"async deduplicate_memories(memory_scope: 'ProtocolMemoryMetadata', similarity_threshold: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async aggregate_data(aggregation_criteria: 'ProtocolAggregationCriteria', time_window_start: str | None, time_window_end: str | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async compress_memories(memory_ids: list[UUID], compression_algorithm: 'LiteralCompressionAlgorithm', quality_threshold: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async optimize_storage(optimization_strategy: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='b489809eb2b56e76', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=366, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory reducer operations in ONEX architecture.\\n\\n    Handles memory consolidation, aggregation, and optimization\\n    with data reduction and compression capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryOrchestratorNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async execute_workflow(request: 'ProtocolWorkflowExecutionRequest', timeout_seconds: float | None) -> 'ProtocolWorkflowExecutionResponse'\", \"async coordinate_agents(request: 'ProtocolAgentCoordinationRequest', timeout_seconds: float | None) -> 'ProtocolAgentCoordinationResponse'\", \"async broadcast_update(update_type: str, update_data: 'ProtocolMemoryMetadata', target_agents: list[UUID] | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async synchronize_state(agent_ids: list[UUID], synchronization_scope: 'ProtocolMemoryMetadata', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async manage_lifecycle(lifecycle_policies: 'ProtocolMemoryMetadata', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='bb418eb2a4f7bc41', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=491, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory orchestrator operations in ONEX architecture.\\n\\n    Handles workflow coordination, agent management, and distributed\\n    memory operations across the entire ONEX cluster.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryHealthNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async check_health(correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async collect_metrics(request: 'ProtocolMemoryMetricsRequest') -> 'ProtocolMemoryMetricsResponse'\", \"async get_status(include_detailed: bool, correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='9a9ecf5b60282761', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=614, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory health monitoring and system observability.\\n\\n    Provides health checks, metrics collection, and system status\\n    monitoring across all memory nodes.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=[\"error_context() -> 'ProtocolMemoryErrorContext'\", 'recoverable() -> bool', 'retry_strategy() -> str | None'], signature_hash='d2e8036e9c6eb99f', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=35, is_runtime_checkable=True, domain='memory', properties=['error_code: str', 'error_message: str', \"error_timestamp: 'datetime'\", 'correlation_id: UUID | None', 'error_category: LiteralErrorCategory'], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized memory operation errors.')",
        "ProtocolInfo(name='ProtocolMemoryErrorResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'retry_after_seconds() -> int | None'], signature_hash='0609454bef4723f1', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=61, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', \"error: 'ProtocolMemoryError'\", 'suggested_action: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for error responses from memory operations.')",
        "ProtocolInfo(name='ProtocolMemoryValidationError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['invalid_fields() -> list[str]'], signature_hash='57ff53c7110c5d62', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=82, is_runtime_checkable=True, domain='memory', properties=['validation_failures: list[str]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory validation errors.')",
        "ProtocolInfo(name='ProtocolMemoryAuthorizationError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['missing_permissions() -> list[str]'], signature_hash='8aa7b11c77575821', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=94, is_runtime_checkable=True, domain='memory', properties=['required_permissions: list[str]', 'user_permissions: list[str]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory authorization errors.')",
        "ProtocolInfo(name='ProtocolMemoryNotFoundError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['async search_suggestions() -> list[str]'], signature_hash='a03d69802b284022', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=107, is_runtime_checkable=True, domain='memory', properties=['requested_memory_id: UUID', 'suggested_alternatives: list[UUID]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory not found errors.')",
        "ProtocolInfo(name='ProtocolMemoryTimeoutError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['progress_percentage() -> float | None'], signature_hash='d343b40cc4db24ef', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=120, is_runtime_checkable=True, domain='memory', properties=['timeout_seconds: float', 'operation_type: str', 'partial_results: str | None'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory operation timeout errors.')",
        "ProtocolInfo(name='ProtocolMemoryCapacityError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['usage_percentage() -> float'], signature_hash='250c31a2214ffeb6', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=134, is_runtime_checkable=True, domain='memory', properties=['resource_type: str', 'current_usage: float', 'maximum_capacity: float'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory capacity/resource errors.')",
        "ProtocolInfo(name='ProtocolMemoryCorruptionError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['async backup_available() -> bool'], signature_hash='eea1c9a64d9bf361', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=148, is_runtime_checkable=True, domain='memory', properties=['corruption_type: str', 'affected_memory_ids: list[UUID]', 'recovery_possible: bool'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory corruption/integrity errors.')",
        "ProtocolInfo(name='ProtocolErrorRecoveryStrategy', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['success_probability() -> float', 'async execute_recovery() -> bool'], signature_hash='d2b263fc86ec6dea', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=162, is_runtime_checkable=True, domain='memory', properties=['strategy_type: str', 'recovery_steps: list[str]', 'estimated_recovery_time: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery strategies.')",
        "ProtocolInfo(name='ProtocolMemoryErrorRecoveryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'recovery_details() -> str | None'], signature_hash='fe991153c7c51868', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=180, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', 'recovery_attempted: bool', 'recovery_successful: bool', \"recovery_strategy: 'ProtocolErrorRecoveryStrategy | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery operation responses.')",
        "ProtocolInfo(name='ProtocolBatchErrorSummary', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['failure_rate() -> float', 'most_common_error() -> str | None'], signature_hash='c40c5e4fd40f838b', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=202, is_runtime_checkable=True, domain='memory', properties=['total_operations: int', 'failed_operations: int', \"error_categories: 'ProtocolErrorCategoryMap'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for batch operation error summaries.')",
        "ProtocolInfo(name='ProtocolBatchErrorResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'retry_after_seconds() -> int | None', 'partial_success_recovery() -> ProtocolErrorRecoveryStrategy | None'], signature_hash='00e5b4036f3019fb', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=221, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', \"error: 'ProtocolMemoryError'\", 'suggested_action: str', \"batch_summary: 'ProtocolBatchErrorSummary'\", \"individual_errors: list['ProtocolMemoryError']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for batch operation error responses.')",
        "ProtocolInfo(name='ProtocolErrorCategory', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['error_type() -> str', 'error_code() -> str', 'error_severity() -> str', 'is_recoverable() -> bool', 'recovery_strategy() -> str', 'requires_user_intervention() -> bool', 'compliance_impact() -> str | None'], signature_hash='f29ebce5442f398e', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=20, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Error category classification for memory operations.\\n\\n    Categorizes errors as transient, permanent, security, validation,\\n    or infrastructure to enable appropriate error handling strategies.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryRetryPolicy', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['max_retries() -> int', 'initial_delay_seconds() -> float', 'backoff_strategy() -> str', 'backoff_multiplier() -> float', 'max_delay_seconds() -> float', 'jitter_enabled() -> bool', 'retry_on_error_types() -> list[str]', 'circuit_breaker_enabled() -> bool', 'circuit_breaker_threshold() -> int'], signature_hash='0f7d1d87feeaab84', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=65, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Retry policy configuration for memory operation error recovery.\\n\\n    Defines retry behavior, backoff strategies, and retry limits\\n    for different types of memory operations and error conditions.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryCompensationAction', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['action_id() -> UUID', 'action_type() -> str', 'target_operation_id() -> UUID', 'compensation_order() -> int', 'is_idempotent() -> bool', 'timeout_seconds() -> float', \"action_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='46b4f75906cb7421', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=120, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Compensation action for failed operations.\\n\\n    Defines rollback, cleanup, and compensation actions to maintain\\n    data consistency when operations fail partially or completely.\\n    ')",
        "ProtocolInfo(name='ProtocolOperationContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['operation_id() -> UUID', 'operation_type() -> str', 'parent_operation_id() -> UUID | None', 'correlation_id() -> UUID', \"started_at() -> 'datetime'\", \"timeout_at() -> 'datetime | None'\", 'dependencies() -> list[UUID]', \"compensation_actions() -> list['ProtocolMemoryCompensationAction']\", \"operation_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='679ac57ecd4f62b8', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=165, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Context information for operation tracking and error recovery.\\n\\n    Maintains operation state, dependencies, and recovery information\\n    for comprehensive error handling and rollback capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryErrorHandler', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=[\"async categorize_error(error: Exception, operation_context: 'ProtocolOperationContext', correlation_id: UUID | None) -> 'ProtocolErrorCategory'\", \"async should_retry_operation(error_category: 'ProtocolErrorCategory', retry_policy: 'ProtocolMemoryRetryPolicy', current_attempt: int, operation_context: 'ProtocolOperationContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async execute_retry(operation_context: 'ProtocolOperationContext', retry_policy: 'ProtocolMemoryRetryPolicy', retry_attempt: int, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async execute_compensation_actions(operation_context: 'ProtocolOperationContext', compensation_actions: list['ProtocolMemoryCompensationAction'], correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async create_error_report(error: Exception, error_category: 'ProtocolErrorCategory', operation_context: 'ProtocolOperationContext', recovery_actions: list[str], correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async handle_circuit_breaker(operation_type: str, error_rate: float, failure_threshold: int, time_window_seconds: int, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async recover_from_partial_failure(operation_context: 'ProtocolOperationContext', successful_operations: list[UUID], failed_operations: list[UUID], recovery_strategy: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='3c35d243e71f85ea', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=220, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Error handling and recovery for memory operations.\\n\\n    Provides comprehensive error categorization, retry handling,\\n    compensation execution, and error reporting capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryHealthMonitor', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=[\"async monitor_operation_health(operation_types: list[str], monitoring_window_minutes: int, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async detect_degradation_patterns(metric_types: list[str], baseline_period_hours: int, detection_sensitivity: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async generate_early_warning(warning_type: str, severity_level: str, affected_operations: list[str], warning_metadata: 'ProtocolMemoryMetadata', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async create_health_dashboard(dashboard_scope: str, time_window_hours: int, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='a0b3323d0e28ed0f', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=411, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Health monitoring and early warning system for memory operations.\\n\\n    Monitors system health, detects degradation patterns, and provides\\n    early warnings to prevent cascading failures.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingChunk', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['chunk_id() -> UUID', 'stream_id() -> UUID', 'sequence_number() -> int', 'total_chunks() -> int | None', 'chunk_data() -> bytes', 'chunk_size() -> int', 'is_final_chunk() -> bool', 'checksum() -> str', 'compression_type() -> str | None', \"chunk_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='031655173c749925', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=19, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for streaming data chunks.\\n\\n    Represents individual chunks in a streaming operation with\\n    metadata for reconstruction and error handling.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingConfig', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['chunk_size_bytes() -> int', 'max_concurrent_chunks() -> int', 'buffer_size_mb() -> float', 'compression_enabled() -> bool', 'compression_level() -> int', 'timeout_per_chunk_seconds() -> float', 'retry_failed_chunks() -> bool', 'max_retries_per_chunk() -> int', 'enable_checksum_validation() -> bool'], signature_hash='c1cf4cb1c49f29b5', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=79, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Configuration for streaming operations.\\n\\n    Defines parameters for chunking, compression, buffering,\\n    and streaming behavior optimization.\\n    ')",
        "ProtocolInfo(name='ProtocolCursorPagination', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['cursor() -> str | None', 'limit() -> int', 'sort_field() -> str', 'sort_direction() -> str', \"filters() -> 'ProtocolMemoryMetadata'\", 'include_total_count() -> bool'], signature_hash='76a9f813254e884d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=134, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Cursor-based pagination for large datasets.\\n\\n    Provides efficient pagination for large memory collections\\n    with stable ordering and consistent performance.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingMemoryNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async stream_memory_content(memory_id: UUID, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator['ProtocolStreamingChunk', None]\", \"async upload_memory_stream(content_stream: AsyncGenerator['ProtocolStreamingChunk', None], target_memory_id: UUID, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async paginate_memories_cursor(pagination_config: 'ProtocolCursorPagination', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async stream_search_results(search_query: str, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator[ProtocolMemoryMetadata, None]\", \"async compress_memory_content(memory_id: UUID, compression_algorithm: str, compression_level: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async decompress_memory_content(memory_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async stream_embedding_vectors(memory_ids: list[UUID], vector_chunk_size: int, compression_enabled: bool, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator['ProtocolStreamingChunk', None]\", \"async batch_upload_embedding_vectors(vector_stream: AsyncGenerator['ProtocolStreamingChunk', None], target_memory_ids: list[UUID], vector_dimensions: int, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='7a831da04d1dcf44', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=174, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Streaming operations for memory content processing.\\n\\n    Handles large content streaming, chunked uploads/downloads,\\n    and cursor-based pagination for memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryCache', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async cache_memory(memory_id: UUID, cache_ttl_seconds: int, cache_level: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\", \"async invalidate_cache(memory_id: UUID, invalidation_scope: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\", \"async warm_cache(memory_ids: list[UUID], warming_strategy: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async get_cache_stats(cache_scope: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\"], signature_hash='4cb9fa04a3f33eec', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=403, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Caching protocol for memory operations performance optimization.\\n\\n    Provides intelligent caching with TTL, invalidation patterns,\\n    and cache warming strategies for memory access optimization.\\n    ')",
        "ProtocolInfo(name='ProtocolPerformanceOptimization', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async analyze_performance_patterns(operation_types: list[str], time_window_hours: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async optimize_memory_access_patterns(memory_ids: list[UUID], optimization_strategy: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async create_performance_baseline(operation_type: str, baseline_duration_hours: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='ed0495936f8ca04d', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=507, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Performance optimization protocol for memory operations.\\n\\n    Provides performance monitoring, optimization suggestions,\\n    and automated optimization for memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemorySecurityContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['user_id() -> UUID | None', 'session_id() -> UUID | None', 'permissions() -> list[str]', 'access_level() -> str', 'audit_enabled() -> bool', 'rate_limit_key() -> str | None', 'pii_detection_enabled() -> bool'], signature_hash='253a5b9586d4a221', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=20, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Security context for memory operations.\\n\\n    Provides authentication, authorization, and audit trail information\\n    for all memory operations with sub-millisecond PII detection.\\n    ')",
        "ProtocolInfo(name='ProtocolAuditTrail', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['operation_id() -> UUID', 'operation_type() -> str', 'resource_id() -> UUID | None', 'user_id() -> UUID | None', \"timestamp() -> 'datetime'\", 'source_ip() -> str | None', 'user_agent() -> str | None', \"operation_metadata() -> 'ProtocolMemoryMetadata'\", 'compliance_tags() -> list[str]'], signature_hash='1bd648fbd30404ff', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=65, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Audit trail information for compliance and security monitoring.\\n\\n    Captures detailed operation logs for security analysis and compliance\\n    reporting with comprehensive event tracking.\\n    ')",
        "ProtocolInfo(name='ProtocolRateLimitConfig', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['requests_per_minute() -> int', 'requests_per_hour() -> int', 'burst_limit() -> int', 'batch_size_limit() -> int', 'data_size_limit_mb() -> float', 'concurrent_operations_limit() -> int'], signature_hash='602b66cd6e896d8a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=120, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Rate limiting configuration for memory operations.\\n\\n    Defines rate limits and throttling policies to prevent abuse\\n    and ensure fair resource utilization.\\n    ')",
        "ProtocolInfo(name='ProtocolInputValidation', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['max_content_length() -> int', 'allowed_content_types() -> list[str]', 'forbidden_patterns() -> list[str]', 'require_sanitization() -> bool', 'pii_detection_threshold() -> float', 'encoding_requirements() -> list[str]'], signature_hash='4760b757c2040e8a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=160, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Input validation requirements for memory operations.\\n\\n    Defines validation rules and sanitization requirements for\\n    all memory operation inputs to prevent injection attacks.\\n    ')",
        "ProtocolInfo(name='ProtocolMemorySecurityNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=[\"async validate_access(security_context: 'ProtocolMemorySecurityContext', operation_type: str, resource_id: UUID | None, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async detect_pii(content: str, detection_threshold: float, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async validate_input(input_data: 'ProtocolMemoryMetadata', validation_config: 'ProtocolInputValidation', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async check_rate_limits(security_context: 'ProtocolMemorySecurityContext', operation_type: str, rate_limit_config: 'ProtocolRateLimitConfig', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async create_audit_trail(audit_info: 'ProtocolAuditTrail', security_context: 'ProtocolMemorySecurityContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async encrypt_sensitive_data(data: 'ProtocolMemoryMetadata', encryption_level: str, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async decrypt_sensitive_data(encrypted_data: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='6291fe47d6c99db9', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=200, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Security validation and monitoring for memory operations.\\n\\n    Provides security validation, PII detection, access control,\\n    and audit trail management for all memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryComplianceNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=[\"async validate_gdpr_compliance(operation_type: str, data_subject_id: UUID | None, legal_basis: str, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async validate_hipaa_compliance(operation_type: str, phi_categories: list[str], covered_entity_id: UUID, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async generate_compliance_report(report_type: str, time_period_start: 'datetime', time_period_end: 'datetime', compliance_frameworks: list[str], correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async handle_data_subject_request(request_type: str, data_subject_id: UUID, request_details: 'ProtocolMemoryMetadata', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='ae24bd135574581b', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=370, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Compliance monitoring and enforcement for memory operations.\\n\\n    Ensures memory operations comply with regulatory requirements\\n    including GDPR, HIPAA, SOX, and other compliance frameworks.\\n    ')"
      ],
      "unknown": [
        "ProtocolInfo(name='ProtocolHandlerInfo', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[], signature_hash='45dd6de0a6b57b0b', line_count=7, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=40, is_runtime_checkable=True, domain='unknown', properties=['node_class: Type[ProtocolFileTypeHandler]', 'name: str', 'source: str', 'priority: int', 'extensions: list[str]', 'special_files: list[str]', 'metadata: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node information objects.')"
      ],
      "mcp": [
        "ProtocolInfo(name='ProtocolMCPToolRouter', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=[\"async select_tool_implementation(tool_name: str, parameters: dict[str, 'ContextValue'], routing_policy: str | None) -> ProtocolMCPToolDefinition | None\", \"async get_available_implementations(tool_name: str) -> list['ProtocolMCPToolDefinition']\", \"async check_implementation_health(tool_def: 'ProtocolMCPToolDefinition') -> bool\", 'async get_routing_statistics() -> dict[str, Any]'], signature_hash='3c9fecc2c0b5ba6a', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=23, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool routing and selection.\\n\\n    Handles intelligent routing of tool execution requests\\n    to appropriate subsystem implementations based on load,\\n    health, and routing policies.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolExecutor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=[\"async execute_tool(tool_def: 'ProtocolMCPToolDefinition', subsystem: 'ProtocolMCPSubsystemRegistration', parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID, timeout_seconds: int | None) -> dict[str, Any]\", \"async execute_with_retry(tool_def: 'ProtocolMCPToolDefinition', subsystem: 'ProtocolMCPSubsystemRegistration', parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID, max_retries: int | None) -> dict[str, Any]\", 'async cancel_execution(execution_id: str) -> bool', \"async get_execution_status(execution_id: str) -> 'LiteralMCPExecutionStatus | None'\"], signature_hash='f20a5ff7272f53bf', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=90, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool execution management.\\n\\n    Handles the actual execution of tools through HTTP proxying,\\n    including retry logic, timeout handling, and result processing.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolProxy', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=['router() -> ProtocolMCPToolRouter', 'executor() -> ProtocolMCPToolExecutor', \"async proxy_tool_execution(tool_name: str, parameters: dict[str, 'ContextValue'], correlation_id: UUID, timeout_seconds: int | None, routing_policy: str | None, preferred_subsystem: str | None) -> dict[str, Any]\", 'async proxy_batch_execution(requests: list[dict[str, Any]], correlation_id: UUID, max_parallel: int) -> list[dict[str, Any]]', \"async get_active_executions(tool_name: str | None) -> list['ProtocolMCPToolExecution']\", \"async get_execution_history(tool_name: str | None, subsystem_id: str | None, correlation_id: UUID | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async cancel_execution(execution_id: str) -> bool', 'async cancel_all_executions(tool_name: str | None, subsystem_id: str | None) -> int', 'async get_execution_metrics(time_range_hours: int, tool_name: str | None) -> dict[str, Any]', 'async get_load_balancing_stats() -> dict[str, Any]', 'async configure_caching(tool_name: str, cache_ttl_seconds: int, cache_key_fields: list[str]) -> bool', 'async clear_cache(tool_name: str | None) -> int', 'async validate_proxy_configuration() -> dict[str, Any]'], signature_hash='9c253e41b435b24b', line_count=13, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=180, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP tool proxy protocol for distributed tool execution.\\n\\n    Combines routing, execution, and result management to provide\\n    a complete tool proxy solution for the MCP registry system.\\n\\n    Key Features:\\n        - **Intelligent Routing**: Route tools to optimal subsystem implementations\\n        - **Load Balancing**: Distribute load across multiple implementations\\n        - **Fault Tolerance**: Handle failures with retry and failover logic\\n        - **Execution Tracking**: Track all tool executions with detailed metrics\\n        - **Performance Monitoring**: Monitor execution performance and success rates\\n        - **Cancellation Support**: Cancel long-running executions\\n        - **Result Caching**: Optional result caching for expensive operations\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistry', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['config() -> ProtocolMCPRegistryConfig', \"async register_subsystem(subsystem_metadata: Any, tools: list['ProtocolMCPToolDefinition'], api_key: str, configuration: dict[str, 'ContextValue'] | None) -> str\", 'async unregister_subsystem(registration_id: str) -> bool', \"async update_subsystem_heartbeat(registration_id: str, health_status: str | None, metadata: dict[str, 'ContextValue'] | None) -> bool\", 'async get_subsystem_registration(registration_id: str) -> ProtocolMCPSubsystemRegistration | None', \"async get_all_subsystems(subsystem_type: 'LiteralMCPSubsystemType | None', status_filter: 'LiteralOperationStatus | None') -> list['ProtocolMCPSubsystemRegistration']\", \"async discover_tools(tool_type: 'LiteralMCPToolType | None', tags: list[str] | None, subsystem_id: str | None) -> list['ProtocolMCPToolDefinition']\", 'async get_tool_definition(tool_name: str) -> ProtocolMCPToolDefinition | None', \"async get_all_tool_implementations(tool_name: str) -> list['ProtocolMCPToolDefinition']\", \"async execute_tool(tool_name: str, parameters: dict[str, 'ContextValue'], correlation_id: UUID, timeout_seconds: int | None, preferred_subsystem: str | None) -> dict[str, Any]\", 'async get_tool_execution(execution_id: str) -> ProtocolMCPToolExecution | None', \"async get_tool_executions(tool_name: str | None, subsystem_id: str | None, correlation_id: UUID | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async cancel_tool_execution(execution_id: str) -> bool', \"async validate_subsystem_registration(subsystem_metadata: Any, tools: list['ProtocolMCPToolDefinition']) -> ProtocolMCPValidationResult\", \"async validate_tool_parameters(tool_name: str, parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async perform_health_check(registration_id: str) -> ProtocolMCPHealthCheck', 'async get_subsystem_health(registration_id: str) -> ProtocolMCPHealthCheck | None', 'async cleanup_expired_registrations() -> int', \"async update_subsystem_configuration(registration_id: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async get_registry_status() -> ProtocolMCPRegistryStatus', 'async get_registry_metrics() -> ProtocolMCPRegistryMetrics'], signature_hash='4617f20bcacdc26c', line_count=21, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=35, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Core MCP registry protocol for distributed tool coordination.\\n\\n    Manages subsystem registration, tool discovery, and execution routing\\n    across multiple MCP-enabled subsystems in the ONEX ecosystem.\\n\\n    Key Features:\\n        - **Multi-Subsystem Coordination**: Register and coordinate multiple MCP subsystems\\n        - **Dynamic Tool Discovery**: Discover and route tools across registered subsystems\\n        - **Load Balancing**: Distribute tool execution across multiple implementations\\n        - **Health Monitoring**: Monitor subsystem health and handle failures gracefully\\n        - **Execution Tracking**: Track tool execution metrics and performance\\n        - **Security**: API key authentication and request validation\\n        - **TTL Management**: Automatic cleanup of expired registrations\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistryAdmin', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['async set_maintenance_mode(enabled: bool) -> bool', 'async force_subsystem_cleanup(registration_id: str) -> bool', \"async update_registry_configuration(configuration: dict[str, 'ContextValue']) -> bool\", 'async export_registry_state() -> dict[str, Any]', 'async import_registry_state(state_data: dict[str, Any]) -> bool', 'async get_system_diagnostics() -> dict[str, Any]'], signature_hash='3982cb436f41c70d', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=365, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Administrative protocol for MCP registry management.\\n\\n    Provides privileged operations for registry administration,\\n    configuration management, and system maintenance.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistryMetricsOperations', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['async get_execution_metrics(time_range_hours: int, tool_name: str | None, subsystem_id: str | None) -> dict[str, Any]', 'async get_performance_trends(metric_name: str, time_range_hours: int) -> dict[str, Any]', 'async get_error_analysis(time_range_hours: int) -> dict[str, Any]', 'async get_capacity_metrics() -> dict[str, Any]'], signature_hash='b11a172bf2c49b9f', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=401, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for advanced MCP registry metrics and analytics.\\n\\n    Provides detailed performance metrics, trend analysis,\\n    and operational insights for the registry system.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPHealthMonitor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_monitor', methods=[\"async perform_health_check(subsystem: 'ProtocolMCPSubsystemRegistration', check_tools: bool) -> ProtocolMCPHealthCheck\", 'async monitor_subsystem_health(subsystem_id: str, interval_seconds: int, callback: Callable[[Any], Any] | None) -> bool', 'async stop_health_monitoring(subsystem_id: str) -> bool', 'async get_health_status(subsystem_id: str) -> ProtocolMCPHealthCheck | None', \"async get_health_history(subsystem_id: str, hours: int, limit: int) -> list['ProtocolMCPHealthCheck']\", 'async detect_health_anomalies(subsystem_id: str | None, time_window_hours: int) -> list[dict[str, Any]]'], signature_hash='84c98ec30d7dc313', line_count=6, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=19, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP health monitoring operations.\\n\\n    Handles health checks, status monitoring, and failure detection\\n    for MCP subsystems and registry components.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPMonitor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_monitor', methods=['health_monitor() -> ProtocolMCPHealthMonitor', 'async start_comprehensive_monitoring(registry_config: dict[str, Any], monitoring_config: dict[str, Any] | None) -> bool', 'async stop_all_monitoring() -> bool', 'async collect_system_metrics(time_range_minutes: int) -> dict[str, Any]', 'async generate_alerts(alert_config: dict[str, Any] | None) -> list[dict[str, Any]]', 'async monitor_subsystem_performance(subsystem_id: str, interval_seconds: int, callback: Callable[[Any], Any] | None) -> bool', 'async analyze_performance_trends(subsystem_id: str | None, time_range_hours: int, metrics: list[str] | None) -> dict[str, Any]', 'async generate_health_report(time_range_hours: int, include_recommendations: bool) -> dict[str, Any]', 'async configure_alerting(alert_handlers: list[Callable[[Any], Any]], thresholds: dict[str, Any], escalation_rules: dict[str, Any] | None) -> bool', 'async get_monitoring_status() -> dict[str, Any]', 'async generate_dashboard_data(dashboard_config: dict[str, Any] | None) -> dict[str, Any]', 'async export_monitoring_data(format_type: str, time_range_hours: int, include_raw_data: bool) -> dict[str, Any]'], signature_hash='89a38814ec662176', line_count=12, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=120, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP monitoring protocol for system observability.\\n\\n    Provides complete monitoring capabilities including health monitoring,\\n    performance tracking, alerting, and operational dashboards.\\n\\n    Key Features:\\n        - **Comprehensive Health Monitoring**: Monitor all subsystems and tools\\n        - **Performance Metrics**: Track execution times, success rates, and throughput\\n        - **Intelligent Alerting**: Generate alerts based on thresholds and anomalies\\n        - **Dashboard Generation**: Create operational dashboards and reports\\n        - **Historical Analysis**: Analyze trends and patterns over time\\n        - **Automated Recovery**: Trigger automated recovery actions\\n        - **Multi-Level Monitoring**: Registry, subsystem, and tool-level monitoring\\n    ')",
        "ProtocolInfo(name='ProtocolMCPSubsystemConfig', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client', methods=[], signature_hash='b98f324e44c32083', line_count=10, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPConnectionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPLifecycleState', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=29, is_runtime_checkable=True, domain='mcp', properties=[\"subsystem_metadata: 'ProtocolMCPSubsystemMetadata'\", 'registry_url: str', 'api_key: str', 'heartbeat_interval: int', \"tool_definitions: list['ProtocolMCPToolDefinition']\", 'auto_register: bool', 'retry_count: int', 'timeout_seconds: int', 'health_check_endpoint: str', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for MCP subsystem configuration.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemClient', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client', methods=['config() -> ProtocolMCPSubsystemConfig', 'registration_id() -> str | None', \"lifecycle_state() -> 'LiteralMCPLifecycleState'\", \"async connection_status() -> 'LiteralMCPConnectionStatus'\", 'async register_subsystem() -> str', 'async unregister_subsystem() -> bool', 'async start_heartbeat(interval: int | None) -> bool', 'async stop_heartbeat() -> bool', \"async send_heartbeat(health_status: str | None, metadata: dict[str, 'ContextValue'] | None) -> bool\", \"async register_tool_handler(tool_name: str, handler: Callable[[dict[str, 'ContextValue']], dict[str, Any]]) -> bool\", 'async unregister_tool_handler(tool_name: str) -> bool', 'async get_registered_tools() -> list[str]', \"async execute_tool_locally(tool_name: str, parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID) -> dict[str, Any]\", 'async validate_configuration() -> ProtocolValidationResult', \"async validate_tool_parameters(tool_name: str, parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async perform_local_health_check() -> ProtocolMCPHealthCheck', 'async get_subsystem_status() -> dict[str, Any]', \"async update_configuration(configuration: dict[str, 'ContextValue']) -> bool\", 'async get_registration_info() -> ProtocolMCPSubsystemRegistration | None', 'async test_registry_connection() -> bool', \"async get_tool_execution_history(tool_name: str | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async shutdown_gracefully(timeout_seconds: int) -> bool'], signature_hash='b03ffff027a793e1', line_count=22, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPConnectionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPLifecycleState', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=45, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    MCP subsystem client protocol for registry integration.\\n\\n    Provides the client-side interface for subsystems to register with\\n    and interact with the central MCP registry infrastructure.\\n\\n    Key Features:\\n        - **Automatic Registration**: Register subsystem and tools with central registry\\n        - **Heartbeat Management**: Maintain connection with periodic health updates\\n        - **Tool Handler Registration**: Register local handlers for tool execution\\n        - **Health Monitoring**: Perform local health checks and report status\\n        - **Configuration Validation**: Validate subsystem configuration before registration\\n        - **Error Recovery**: Handle connection failures and retry logic\\n        - **Lifecycle Management**: Manage subsystem lifecycle states\\n    ')",
        "ProtocolInfo(name='ProtocolMCPServiceDiscovery', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_discovery', methods=[\"async discover_mcp_services(service_type: 'LiteralMCPSubsystemType | None', timeout_seconds: int) -> list['ProtocolMCPDiscoveryInfo']\", \"async discover_registries(timeout_seconds: int) -> list['ProtocolMCPDiscoveryInfo']\", \"async register_service_for_discovery(service_info: 'ProtocolMCPDiscoveryInfo', ttl_seconds: int) -> bool\", 'async unregister_service_from_discovery(service_name: str) -> bool', \"async monitor_service_changes(callback: Callable[[Any], Any], service_type: 'LiteralMCPSubsystemType | None') -> bool\"], signature_hash='d6d98e508ca6e6f5', line_count=5, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPDiscoveryInfo', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=24, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP service discovery operations.\\n\\n    Handles discovery of MCP services across the network using\\n    various discovery mechanisms (DNS-SD, Consul, etcd, etc.).\\n    ')",
        "ProtocolInfo(name='ProtocolMCPDiscovery', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_discovery', methods=['service_discovery() -> ProtocolMCPServiceDiscovery', \"async discover_available_subsystems(service_type: 'LiteralMCPSubsystemType | None', health_check: bool, timeout_seconds: int) -> list['ProtocolMCPSubsystemRegistration']\", \"async discover_available_tools(service_type: 'LiteralMCPSubsystemType | None', tool_tags: list[str] | None, health_check: bool) -> dict[str, list[str]]\", 'async find_optimal_registry(criteria: dict[str, Any] | None, timeout_seconds: int) -> ProtocolMCPDiscoveryInfo | None', \"async coordinate_multi_registry(registries: list['ProtocolMCPDiscoveryInfo'], coordination_strategy: str) -> dict[str, Any]\", 'async monitor_network_changes(callback: Callable[[Any], Any], service_types: list[LiteralMCPSubsystemType] | None, change_types: list[str] | None) -> bool', 'async get_network_topology(include_health: bool) -> dict[str, Any]', \"async test_service_connectivity(service_info: 'ProtocolMCPDiscoveryInfo', test_tools: bool) -> dict[str, Any]\", \"async get_service_health_status(service_name: str) -> 'LiteralHealthStatus | None'\", \"async update_service_cache(force_refresh: bool, service_type: 'LiteralMCPSubsystemType | None') -> int\", \"async configure_discovery_backend(backend_type: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async get_discovery_statistics() -> dict[str, Any]'], signature_hash='d6eb496561939ced', line_count=12, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPDiscoveryInfo', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=107, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP discovery protocol for distributed service coordination.\\n\\n    Provides complete discovery capabilities including service discovery,\\n    health monitoring, and automatic registry coordination.\\n\\n    Key Features:\\n        - **Multi-Protocol Discovery**: Support DNS-SD, Consul, etcd, and other backends\\n        - **Health-Aware Discovery**: Filter services based on health status\\n        - **Registry Selection**: Intelligent selection of optimal registry\\n        - **Multi-Registry Coordination**: Coordinate multiple registries with various strategies\\n        - **Change Monitoring**: Real-time monitoring of network changes\\n        - **Geographic Awareness**: Region and location-aware service discovery\\n        - **Load Balancing**: Distribute load across discovered services\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolValidator', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_validator', methods=[\"async validate_tool_definition(tool_def: 'ProtocolMCPToolDefinition') -> ProtocolMCPValidationResult\", \"async validate_tool_parameters(tool_def: 'ProtocolMCPToolDefinition', parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async validate_parameter_schema(schema: dict[str, Any]) -> ProtocolMCPValidationResult', \"async sanitize_parameters(tool_def: 'ProtocolMCPToolDefinition', parameters: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\"], signature_hash='ba5b53d8b4897860', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationError', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=25, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool validation operations.\\n\\n    Handles validation of tool definitions, parameters,\\n    and execution requests for security and correctness.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPValidator', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_validator', methods=['tool_validator() -> ProtocolMCPToolValidator', \"async validate_subsystem_registration(subsystem_metadata: 'ProtocolMCPSubsystemMetadata', tools: list['ProtocolMCPToolDefinition'], api_key: str) -> ProtocolMCPValidationResult\", \"async validate_execution_request(tool_name: str, parameters: dict[str, 'ContextValue'], subsystem_id: str | None) -> ProtocolValidationResult\", 'async validate_api_key(api_key: str, subsystem_id: str | None) -> bool', \"async validate_configuration(configuration: dict[str, 'ContextValue']) -> ProtocolMCPValidationResult\", 'async validate_network_access(base_url: str, endpoints: list[str]) -> ProtocolMCPValidationResult', \"async sanitize_subsystem_metadata(metadata: 'ProtocolMCPSubsystemMetadata') -> ProtocolMCPSubsystemMetadata\", \"async detect_security_issues(parameters: dict[str, 'ContextValue'], tool_definition: 'ProtocolMCPToolDefinition | None') -> list['ProtocolMCPValidationError']\", \"async validate_compatibility(subsystem_version: str, registry_version: str, tools: list['ProtocolMCPToolDefinition']) -> ProtocolMCPValidationResult\", \"async validate_performance_constraints(tools: list['ProtocolMCPToolDefinition'], expected_load: dict[str, Any] | None) -> ProtocolMCPValidationResult\", 'async get_validation_rules() -> dict[str, Any]', 'async update_validation_rules(rules: dict[str, Any]) -> bool'], signature_hash='9d60a58069452c27', line_count=12, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationError', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=97, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP validation protocol for all MCP operations.\\n\\n    Provides validation for subsystem registrations, tool definitions,\\n    execution parameters, and system configurations.\\n\\n    Key Features:\\n        - **Schema Validation**: Validate against JSON schemas and type definitions\\n        - **Security Validation**: Detect potential security issues in parameters\\n        - **Business Rule Validation**: Enforce business rules and constraints\\n        - **Performance Validation**: Check for performance-impacting configurations\\n        - **Compatibility Validation**: Ensure compatibility across versions\\n        - **Sanitization**: Clean and normalize input data\\n        - **Detailed Error Reporting**: Provide actionable error messages and suggestions\\n    ')",
        "ProtocolInfo(name='ProtocolToolDiscoveryService', file_path='src/omnibase_spi/protocols/mcp/protocol_tool_discovery_service.py', module_path='omnibase_spi.protocols.mcp.protocol_tool_discovery_service', methods=[\"resolve_tool_from_contract(metadata: 'ProtocolMetadata', registry: object, contract_path: str) -> 'ProtocolToolInstance'\", \"async discover_tool_class_from_module(module_path: str, tool_class_name: str) -> 'ProtocolToolClass'\", \"instantiate_tool_with_container(tool_class: 'ProtocolToolClass', container: object) -> 'ProtocolToolInstance'\", \"resolve_tool_from_registry(registry: object, tool_class_name: str) -> 'ProtocolToolInstance | None'\", 'build_module_path_from_contract(contract_path: str) -> str', 'async validate_module_path(module_path: str) -> bool', 'convert_class_name_to_registry_key(class_name: str) -> str'], signature_hash='fc6fae4cbb14f090', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolToolClass', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolToolInstance'], line_number=19, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for tool discovery service operations.\\n\\n    Provides duck typing interface for tool class discovery, validation,\\n    instantiation, and registry resolution in MCP-compliant systems.\\n\\n    Key Features:\\n        - Tool resolution from contract specifications\\n        - Dynamic tool class discovery from modules\\n        - Container-based tool instantiation\\n        - Registry-based tool resolution\\n        - Secure module path validation\\n        - Tool metadata management\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ToolDiscoveryServiceImpl:\\n            def resolve_tool_from_contract(self, metadata, registry, contract_path):\\n                # Load tool configuration from contract\\n                module_path = self.build_module_path_from_contract(contract_path)\\n                tool_class = self.discover_tool_class_from_module(module_path, metadata.get(\\'tool_class\\'))\\n                return self.instantiate_tool_with_container(tool_class, registry)\\n\\n        # Usage in application code\\n        discovery_service: \"ProtocolToolDiscoveryService\" = ToolDiscoveryServiceImpl()\\n\\n        tool = discovery_service.resolve_tool_from_contract(\\n            metadata={\\'tool_class\\': \\'MyTool\\'},\\n            registry=container,\\n            contract_path=\\'/path/to/contract.yaml\\'\\n        )\\n        ```\\n    ')"
      ],
      "container": [
        "ProtocolInfo(name='ProtocolServiceRegistrationMetadata', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='7dc90595ac59cd74', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=42, is_runtime_checkable=True, domain='container', properties=['service_id: str', 'service_name: str', 'service_interface: str', 'service_implementation: str', \"version: 'ProtocolSemVer'\", 'description: str | None', 'tags: list[str]', \"configuration: dict[str, 'ContextValue']\", \"created_at: 'ProtocolDateTime'\", \"last_modified_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registration metadata objects in service registry.')",
        "ProtocolInfo(name='ProtocolServiceDependency', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_dependency() -> bool', 'is_satisfied() -> bool'], signature_hash='7c8393268f554d42', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=58, is_runtime_checkable=True, domain='container', properties=['dependency_name: str', 'dependency_interface: str', \"dependency_version: 'ProtocolSemVer | None'\", 'is_required: bool', 'is_circular: bool', 'injection_point: str', 'default_value: Any | None', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service dependency information.')",
        "ProtocolInfo(name='ProtocolServiceRegistration', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_registration() -> bool', 'is_active() -> bool'], signature_hash='870f2a3a23690d98', line_count=14, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=80, is_runtime_checkable=True, domain='container', properties=['registration_id: str', \"service_metadata: 'ProtocolServiceRegistrationMetadata'\", 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralInjectionScope', \"dependencies: list['ProtocolServiceDependency']\", \"registration_status: Literal['registered', 'unregistered', 'failed', 'pending', 'conflict', 'invalid']\", 'health_status: ServiceHealthStatus', \"registration_time: 'ProtocolDateTime'\", \"last_access_time: 'ProtocolDateTime | None'\", 'access_count: int', 'instance_count: int', 'max_instances: int | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for service registration information.')",
        "ProtocolInfo(name='ProtocolRegistryServiceInstance', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_instance() -> bool', 'is_active() -> bool'], signature_hash='6756e40ec4e49a67', line_count=12, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=108, is_runtime_checkable=True, domain='container', properties=['instance_id: str', 'service_registration_id: str', 'instance: Any', 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralInjectionScope', \"created_at: 'ProtocolDateTime'\", \"last_accessed: 'ProtocolDateTime'\", 'access_count: int', 'is_disposed: bool', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service registry managed instance information.')",
        "ProtocolInfo(name='ProtocolDependencyGraph', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='250ccf3db7b6a05e', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=132, is_runtime_checkable=True, domain='container', properties=['service_id: str', 'dependencies: list[str]', 'dependents: list[str]', 'depth_level: int', 'circular_references: list[str]', 'resolution_order: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency graph information.')",
        "ProtocolInfo(name='ProtocolInjectionContext', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='e2e823b93332d0fc', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=145, is_runtime_checkable=True, domain='container', properties=['context_id: str', 'target_service_id: str', 'scope: LiteralInjectionScope', 'resolved_dependencies: dict[str, Any]', \"injection_time: 'ProtocolDateTime'\", 'resolution_status: LiteralServiceResolutionStatus', 'error_details: str | None', 'resolution_path: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency injection context.')",
        "ProtocolInfo(name='ProtocolServiceRegistryStatus', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='ffc6a70b17d4f624', line_count=13, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=160, is_runtime_checkable=True, domain='container', properties=['registry_id: str', 'status: LiteralOperationStatus', 'message: str', 'total_registrations: int', 'active_instances: int', 'failed_registrations: int', 'circular_dependencies: int', 'lifecycle_distribution: dict[LiteralServiceLifecycle, int]', 'scope_distribution: dict[LiteralInjectionScope, int]', 'health_summary: dict[ServiceHealthStatus, int]', 'memory_usage_bytes: int | None', 'average_resolution_time_ms: float | None', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registry status information.')",
        "ProtocolInfo(name='ProtocolServiceValidator', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['async validate_service(service: Any, interface: Type[Any]) -> ProtocolValidationResult', \"async validate_dependencies(dependencies: list['ProtocolServiceDependency']) -> ProtocolValidationResult\"], signature_hash='8146cb0d189702de', line_count=2, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=179, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for service validation operations.')",
        "ProtocolInfo(name='ProtocolServiceFactory', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['async create_instance(interface: Type[T], context: dict[str, Any]) -> T', 'async dispose_instance(instance: Any) -> None'], signature_hash='0c36b9b016a8b47f', line_count=2, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=196, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for service factory operations.')",
        "ProtocolInfo(name='ProtocolServiceRegistryConfig', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='f51dfab880261669', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=209, is_runtime_checkable=True, domain='container', properties=['registry_name: str', 'auto_wire_enabled: bool', 'lazy_loading_enabled: bool', 'circular_dependency_detection: bool', 'max_resolution_depth: int', 'instance_pooling_enabled: bool', 'health_monitoring_enabled: bool', 'performance_monitoring_enabled: bool', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registry configuration.')",
        "ProtocolInfo(name='ProtocolServiceRegistry', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['config() -> ProtocolServiceRegistryConfig', 'validator() -> ProtocolServiceValidator | None', 'factory() -> ProtocolServiceFactory | None', \"async register_service(interface: Type[TInterface], implementation: Type[TImplementation], lifecycle: LiteralServiceLifecycle, scope: LiteralInjectionScope, configuration: dict[str, 'ContextValue'] | None) -> str\", \"async register_instance(interface: Type[TInterface], instance: TInterface, scope: 'LiteralInjectionScope', metadata: dict[str, 'ContextValue'] | None) -> str\", \"async register_factory(interface: Type[TInterface], factory: 'ProtocolServiceFactory', lifecycle: 'LiteralServiceLifecycle', scope: 'LiteralInjectionScope') -> str\", 'async unregister_service(registration_id: str) -> bool', \"async resolve_service(interface: Type[TInterface], scope: 'LiteralInjectionScope | None', context: dict[str, 'ContextValue'] | None) -> TInterface\", \"async resolve_named_service(interface: Type[TInterface], name: str, scope: 'LiteralInjectionScope | None') -> TInterface\", \"async resolve_all_services(interface: Type[TInterface], scope: 'LiteralInjectionScope | None') -> list[TInterface]\", \"async try_resolve_service(interface: Type[TInterface], scope: 'LiteralInjectionScope | None') -> TInterface | None\", 'async get_registration(registration_id: str) -> ProtocolServiceRegistration | None', \"async get_registrations_by_interface(interface: Type[T]) -> list['ProtocolServiceRegistration']\", \"async get_all_registrations() -> list['ProtocolServiceRegistration']\", \"async get_active_instances(registration_id: str | None) -> list['ProtocolRegistryServiceInstance']\", \"async dispose_instances(registration_id: str, scope: 'LiteralInjectionScope | None') -> int\", \"async validate_registration(registration: 'ProtocolServiceRegistration') -> bool\", \"async detect_circular_dependencies(registration: 'ProtocolServiceRegistration') -> list[str]\", 'async get_dependency_graph(service_id: str) -> ProtocolDependencyGraph | None', 'async get_registry_status() -> ProtocolServiceRegistryStatus', 'async validate_service_health(registration_id: str) -> ProtocolValidationResult', \"async update_service_configuration(registration_id: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async create_injection_scope(scope_name: str, parent_scope: str | None) -> str', 'async dispose_injection_scope(scope_id: str) -> int', 'async get_injection_context(context_id: str) -> ProtocolInjectionContext | None'], signature_hash='7814da6993a59b3f', line_count=25, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=224, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service registry operations.\\n\\n    Provides dependency injection service registration and management.\\n    Supports the complete service lifecycle including registration, resolution, injection, and disposal.\\n\\n    Advanced Features:\\n        - **Lifecycle Management**: Support for singleton, transient, scoped, pooled patterns\\n        - **Dependency Injection**: Constructor, property, and method injection patterns\\n        - **Circular Dependency Detection**: Automatic detection and prevention\\n        - **Health Monitoring**: Service health tracking and validation\\n        - **Performance Metrics**: Resolution time tracking and optimization\\n        - **Scoped Injection**: Request, session, thread-based scoping\\n        - **Service Validation**: Registration and runtime validation\\n        - **Instance Pooling**: Object pooling for performance optimization\\n\\n    Service Registration Patterns:\\n        - **Interface-based registration**: Register by interface type\\n        - **Named registration**: Register multiple implementations with names\\n        - **Generic registration**: Support for generic service types\\n        - **Conditional registration**: Register based on runtime conditions\\n        - **Decorator-based registration**: Use decorators for automatic registration\\n    ')",
        "ProtocolInfo(name='ProtocolContainerService', file_path='src/omnibase_spi/protocols/container/protocol_container_service.py', module_path='omnibase_spi.protocols.container.protocol_container_service', methods=[\"async create_container_from_contract(contract_metadata: 'ProtocolMetadata', node_id: str, node_ref: object | None) -> 'ProtocolContainerResult'\", \"async create_service_from_dependency(dependency_spec: 'ProtocolDependencySpec') -> 'ProtocolContainerServiceInstance | None'\", \"async validate_container_dependencies(container: 'ProtocolContainer') -> bool\", \"async get_registry_wrapper(container: 'ProtocolContainer', node_ref: object | None) -> 'ProtocolRegistryWrapper'\", \"async update_container_lifecycle(registry: 'ProtocolRegistryWrapper', node_ref: object) -> None\"], signature_hash='c56988c0332dfa8a', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainer', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainerResult', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainerServiceInstance', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolDependencySpec', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolRegistryWrapper', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata'], line_number=22, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for container service operations.\\n\\n    Provides dependency injection container management, service registration,\\n    and registry lifecycle operations for ONEX-compliant systems.\\n\\n    Key Features:\\n        - Container creation from contract specifications\\n        - Service instantiation from dependency specifications\\n        - Container dependency validation\\n        - Registry wrapper management\\n        - Container lifecycle management\\n        - Node reference integration\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ContainerServiceImpl:\\n            async def create_container_from_contract(self, metadata, node_id, node_ref=None):\\n                container = self._create_empty_container()\\n\\n                # Register dependencies from contract\\n                for dep_spec in metadata.dependencies:\\n                    service = self.create_service_from_dependency(dep_spec)\\n                    if service:\\n                        container.register(dep_spec.service_key, service)\\n\\n                return ContainerResult(container, registry_wrapper)\\n\\n        # Usage in application code\\n        container_service: \"ProtocolContainerService\" = ContainerServiceImpl()\\n\\n        result = container_service.create_container_from_contract(\\n            metadata=contract_metadata,\\n            node_id=\"my_node\",\\n            node_ref=node_instance\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolArtifactMetadata', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='57d18e323bec65bb', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=21, is_runtime_checkable=True, domain='container', properties=['description: str | None', 'author: str | None', 'created_at: str | None', 'last_modified_at: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact metadata.')",
        "ProtocolInfo(name='ProtocolArtifactInfo', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='45096fd7177cc52d', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=31, is_runtime_checkable=True, domain='container', properties=['name: str', \"version: 'ProtocolSemVer'\", 'artifact_type: LiteralContainerArtifactType', 'path: str', \"metadata: 'ProtocolArtifactMetadata'\", 'is_wip: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact information.')",
        "ProtocolInfo(name='ProtocolArtifactContainerStatus', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='7c6586e421910e38', line_count=7, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=43, is_runtime_checkable=True, domain='container', properties=['status: LiteralOnexStatus', 'message: str', 'artifact_count: int', 'valid_artifact_count: int', 'invalid_artifact_count: int', 'wip_artifact_count: int', 'artifact_types_found: list[LiteralContainerArtifactType]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact container status information.')",
        "ProtocolInfo(name='ProtocolArtifactContainer', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=['async get_status() -> ProtocolArtifactContainerStatus', \"get_artifacts() -> list['ProtocolArtifactInfo']\", \"get_artifacts_by_type(artifact_type: LiteralContainerArtifactType) -> list['ProtocolArtifactInfo']\", \"get_artifact_by_name(name: str, artifact_type: 'LiteralContainerArtifactType | None') -> ProtocolArtifactInfo\", \"has_artifact(name: str, artifact_type: 'LiteralContainerArtifactType | None') -> bool\"], signature_hash='ce61ccba7b3d70a5', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=56, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Cross-cutting artifact container protocol.\\n\\n    Provides an interface for artifact container operations that can be implemented\\n    by different container backends (artifact loader node, mock containers, etc.)\\n    without exposing implementation-specific details.\\n    ')"
      ],
      "workflow": [
        "ProtocolInfo(name='ProtocolWorkQueue', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_work_queue.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_work_queue', methods=['async connect_to_work_system() -> bool', 'async fetch_pending_tickets(limit: int | None) -> list[Any]', 'async subscribe_to_ticket_updates() -> AsyncIterator[Any]', 'async assign_ticket_to_agent(ticket_id: str, agent_id: str) -> Any', 'async update_ticket_status(ticket_id: str, status: str, message: str | None) -> bool', 'async update_ticket_progress(ticket_id: str, progress_percent: float) -> bool', \"async complete_ticket(ticket_id: str, result_data: dict[str, 'ContextValue']) -> bool\", 'async fail_ticket(ticket_id: str, error_message: str) -> bool', 'async get_ticket_by_id(ticket_id: str) -> Any | None', 'async get_tickets_by_priority(priority: LiteralWorkQueuePriority) -> list[Any]', 'async get_tickets_by_agent(agent_id: str) -> list[Any]', \"async get_available_tickets(agent_capabilities: list[str] | None, max_priority: 'LiteralWorkQueuePriority | None') -> list[Any]\", 'async reserve_ticket(ticket_id: str, agent_id: str, duration_minutes: int) -> bool', 'async release_ticket_reservation(ticket_id: str, agent_id: str) -> bool', 'async get_queue_statistics() -> dict[str, int]', 'async get_ticket_dependencies(ticket_id: str) -> list[str]', 'async add_ticket_dependency(ticket_id: str, dependency_ticket_id: str) -> bool', 'async remove_ticket_dependency(ticket_id: str, dependency_ticket_id: str) -> bool', 'async get_blocked_tickets() -> list[Any]', 'async get_ready_tickets() -> list[Any]', 'async set_assignment_strategy(strategy: LiteralAssignmentStrategy) -> bool', \"async get_assignment_strategy() -> 'LiteralAssignmentStrategy'\", 'async requeue_ticket(ticket_id: str, reason: str) -> bool', 'async estimate_completion_time(ticket_id: str) -> Any', 'async get_ticket_metrics(ticket_id: str) -> dict[str, float]', \"async create_ticket_checkpoint(ticket_id: str, checkpoint_data: dict[str, 'ContextValue']) -> str\", 'async restore_ticket_checkpoint(ticket_id: str, checkpoint_id: str) -> bool'], signature_hash='589cca7d0a7c412d', line_count=27, imports=['collections.abc.AsyncIterator', 'typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=28, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for work queue integration and ticket management.')",
        "ProtocolInfo(name='ProtocolWorkflowEventMessage', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=['async ack() -> None', 'async get_workflow_event() -> ProtocolWorkflowEvent'], signature_hash='9c600e9aa8cdc88f', line_count=14, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=21, is_runtime_checkable=True, domain='workflow', properties=['topic: str', 'key: bytes | None', 'value: bytes', 'headers: dict[str, Any]', 'offset: str | None', 'partition: int | None', 'workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'sequence_number: int', 'event_type: LiteralWorkflowEventType', 'idempotency_key: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific event messages.\\n\\n    Extends the base event message with workflow orchestration metadata\\n    for proper event sourcing and workflow coordination.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowEventHandler', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=[\"async __call__(event: 'ProtocolWorkflowEvent', context: dict[str, Any]) -> None\"], signature_hash='bacef0fb035e29a1', line_count=1, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=50, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow event handler functions.\\n\\n    Event handlers process workflow events and update workflow state\\n    according to event sourcing patterns.\\n    ')",
        "ProtocolInfo(name='ProtocolLiteralWorkflowStateProjection', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=[\"async apply_event(event: 'ProtocolWorkflowEvent', current_state: dict[str, Any]) -> dict[str, Any]\", 'async get_state(workflow_type: str, instance_id: UUID) -> dict[str, Any]'], signature_hash='89b2da8e62f1707a', line_count=3, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=72, is_runtime_checkable=True, domain='workflow', properties=['projection_name: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow state projection handlers.\\n\\n    Projections maintain derived state from workflow events\\n    for query optimization and real-time monitoring.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowEventBus', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=['base_event_bus() -> ProtocolEventBus'], signature_hash='0088fe9c82e778c3', line_count=1, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=112, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific event bus operations.\\n\\n    Extends the base event bus with workflow orchestration patterns:\\n    - Event sourcing with sequence numbers\\n    - Workflow instance isolation\\n    - Task coordination messaging\\n    - State projection updates\\n    - Recovery and replay support\\n\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowNodeCapability', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='9950155a195d9b96', line_count=9, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=24, is_runtime_checkable=True, domain='workflow', properties=['capability_id: str', 'capability_name: str', 'capability_version: str', 'supported_task_types: list[LiteralTaskType]', 'supported_node_types: list[LiteralNodeType]', 'resource_requirements: dict[str, Any]', 'configuration_schema: dict[str, Any]', 'performance_characteristics: dict[str, float]', 'availability_constraints: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for workflow-specific node capabilities.\\n\\n    Extends basic node capabilities with workflow orchestration\\n    features, task type support, and resource management.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowNodeInfo', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='61d5853d991037dc', line_count=17, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=44, is_runtime_checkable=True, domain='workflow', properties=['node_id: str', 'node_type: LiteralNodeType', 'node_name: str', 'environment: str', 'group: str', 'version: str', \"health_status: 'LiteralHealthStatus'\", 'endpoint: str', 'metadata: dict[str, Any]', \"workflow_capabilities: list['ProtocolWorkflowNodeCapability']\", 'current_workload: dict[str, Any]', 'max_concurrent_tasks: int', 'current_task_count: int', 'supported_workflow_types: list[str]', 'task_execution_history: dict[str, Any]', 'resource_utilization: dict[str, float]', 'scheduling_preferences: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for workflow-specific node information.\\n\\n    Extends base node info with workflow orchestration capabilities,\\n    current workload, and task execution metrics.\\n    ')",
        "ProtocolInfo(name='ProtocolTaskSchedulingCriteria', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='f0b2f4dd0d59453f', line_count=10, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=72, is_runtime_checkable=True, domain='workflow', properties=['task_type: LiteralTaskType', 'node_type: LiteralNodeType', 'required_capabilities: list[str]', 'preferred_capabilities: list[str]', 'resource_requirements: dict[str, Any]', 'affinity_rules: dict[str, Any]', 'anti_affinity_rules: dict[str, Any]', 'geographic_constraints: dict[str, Any] | None', 'priority: LiteralTaskPriority', 'timeout_tolerance: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for task scheduling criteria.\\n\\n    Defines the requirements and preferences for scheduling tasks\\n    on workflow nodes based on capabilities and constraints.\\n    ')",
        "ProtocolInfo(name='ProtocolNodeSchedulingResult', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='cc871e78c1ea703c', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=93, is_runtime_checkable=True, domain='workflow', properties=[\"selected_nodes: list['ProtocolWorkflowNodeInfo']\", 'scheduling_score: float', 'scheduling_rationale: str', \"fallback_nodes: list['ProtocolWorkflowNodeInfo']\", 'resource_allocation: dict[str, Any]', 'estimated_completion_time: float | None', 'constraints_satisfied: dict[str, bool]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for node scheduling results.\\n\\n    Contains the results of task scheduling decisions including\\n    selected nodes, scheduling rationale, and fallback options.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowNodeRegistry', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=['base_registry() -> ProtocolNodeRegistry', \"async discover_nodes_for_task(task_config: 'ProtocolTaskConfiguration', scheduling_criteria: 'ProtocolTaskSchedulingCriteria') -> ProtocolNodeSchedulingResult\", \"async discover_nodes_by_capability(capability_name: str, capability_version: str | None, min_availability: float | None) -> list['ProtocolWorkflowNodeInfo']\", \"async discover_nodes_for_workflow_type(workflow_type: str, required_node_types: list[LiteralNodeType] | None) -> list['ProtocolWorkflowNodeInfo']\", 'async get_workflow_node_info(node_id: str) -> ProtocolWorkflowNodeInfo | None', \"async register_workflow_capability(node_id: str, capability: 'ProtocolWorkflowNodeCapability') -> bool\", 'async unregister_workflow_capability(node_id: str, capability_id: str) -> bool', \"async get_node_capabilities(node_id: str) -> list['ProtocolWorkflowNodeCapability']\", 'async update_node_workload(node_id: str, task_id: UUID, workload_change: str) -> None', 'async get_node_workload(node_id: str) -> dict[str, Any]', 'async get_resource_utilization(node_id: str) -> dict[str, float]', \"async calculate_scheduling_score(node_info: 'ProtocolWorkflowNodeInfo', task_config: 'ProtocolTaskConfiguration', criteria: 'ProtocolTaskSchedulingCriteria') -> float\", 'async reserve_resources(node_id: str, task_id: UUID, resource_requirements: dict[str, Any], timeout_seconds: int) -> bool', 'async release_resources(node_id: str, task_id: UUID) -> bool', 'async record_task_execution_metrics(node_id: str, task_id: UUID, execution_metrics: dict[str, Any]) -> None', \"async get_node_performance_history(node_id: str, task_type: 'LiteralTaskType | None', time_window_seconds: int) -> dict[str, Any]\", 'async update_node_availability(node_id: str, availability_status: str, metadata: dict[str, Any] | None) -> bool', 'async get_cluster_health_summary(workflow_type: str | None, node_group: str | None) -> dict[str, Any]'], signature_hash='978e29e5bdbc4e6f', line_count=18, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=111, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific node discovery and management.\\n\\n    Extends the base node registry with workflow orchestration features:\\n    - Capability-based node discovery\\n    - Task scheduling and load balancing\\n    - Workflow-aware node selection\\n    - Resource utilization tracking\\n    - Performance-based routing\\n\\n    ')",
        "ProtocolInfo(name='ProtocolEventStoreTransaction', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=['async commit() -> bool', 'async rollback() -> None'], signature_hash='2bddc29a0d3a4945', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=21, is_runtime_checkable=True, domain='workflow', properties=['transaction_id: UUID', 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for event store transaction objects.\\n\\n    Provides ACID transaction support for event store operations\\n    with rollback capabilities and consistency guarantees.\\n    ')",
        "ProtocolInfo(name='ProtocolEventQueryOptions', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[], signature_hash='a4c75963ead27a89', line_count=10, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=42, is_runtime_checkable=True, domain='workflow', properties=['workflow_type: str | None', 'instance_id: UUID | None', 'event_types: list[LiteralWorkflowEventType] | None', 'from_sequence: int | None', 'to_sequence: int | None', \"from_timestamp: 'ProtocolDateTime | None'\", \"to_timestamp: 'ProtocolDateTime | None'\", 'limit: int | None', 'offset: int | None', 'order_by: str | None'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for event query options.\\n\\n    Defines filtering, ordering, and pagination options\\n    for event store queries.\\n    ')",
        "ProtocolInfo(name='ProtocolEventStoreResult', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[], signature_hash='8ee255c2a6df00e7', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=63, is_runtime_checkable=True, domain='workflow', properties=['success: bool', 'events_processed: int', 'sequence_numbers: list[int]', 'error_message: str | None', 'operation_time_ms: float', 'storage_size_bytes: int | None'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for event store operation results.\\n\\n    Provides operation outcome information with error details\\n    and performance metrics.\\n    ')",
        "ProtocolInfo(name='ProtocolEventStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async append_events(events: list['ProtocolWorkflowEvent'], expected_sequence: int | None, transaction: 'ProtocolEventStoreTransaction | None') -> ProtocolEventStoreResult\", \"async read_events(query_options: 'ProtocolEventQueryOptions', transaction: 'ProtocolEventStoreTransaction | None') -> list['ProtocolWorkflowEvent']\", \"async get_event_stream(workflow_type: str, instance_id: UUID, from_sequence: int, to_sequence: int | None) -> list['ProtocolWorkflowEvent']\", 'async get_last_sequence_number(workflow_type: str, instance_id: UUID) -> int', 'async begin_transaction() -> ProtocolEventStoreTransaction', 'async delete_event_stream(workflow_type: str, instance_id: UUID) -> ProtocolEventStoreResult', \"async archive_old_events(before_timestamp: 'ProtocolDateTime', batch_size: int) -> ProtocolEventStoreResult\"], signature_hash='e8db8e39a71226f2', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=80, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow event store operations.\\n\\n    Provides event sourcing capabilities with:\\n    - Append-only event storage\\n    - Sequence number guarantees\\n    - Transactional consistency\\n    - Event stream reading\\n    - Optimistic concurrency control\\n\\n    ')",
        "ProtocolInfo(name='ProtocolSnapshotStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async save_snapshot(snapshot: 'ProtocolWorkflowSnapshot', transaction: 'ProtocolEventStoreTransaction | None') -> bool\", 'async load_snapshot(workflow_type: str, instance_id: UUID, sequence_number: int | None) -> ProtocolWorkflowSnapshot | None', 'async list_snapshots(workflow_type: str, instance_id: UUID, limit: int) -> list[dict[str, Any]]', 'async delete_snapshot(workflow_type: str, instance_id: UUID, sequence_number: int) -> bool', 'async cleanup_old_snapshots(workflow_type: str, instance_id: UUID, keep_count: int) -> int'], signature_hash='15917e06aab7ea71', line_count=5, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=206, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow snapshot store operations.\\n\\n    Provides state snapshot capabilities for:\\n    - Point-in-time state capture\\n    - Fast state reconstruction\\n    - Recovery and replay optimization\\n    - State validation checkpoints\\n\\n    ')",
        "ProtocolInfo(name='ProtocolLiteralWorkflowStateStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async save_workflow_instance(workflow_instance: 'ProtocolWorkflowSnapshot') -> bool\", 'async load_workflow_instance(workflow_type: str, instance_id: UUID) -> ProtocolWorkflowSnapshot | None', \"async query_workflow_instances(workflow_type: str | None, state: 'LiteralWorkflowState | None', correlation_id: UUID | None, limit: int, offset: int) -> list['ProtocolWorkflowSnapshot']\", 'async delete_workflow_instance(workflow_type: str, instance_id: UUID) -> bool', 'async lock_workflow_instance(workflow_type: str, instance_id: UUID, lock_owner: str, timeout_seconds: int) -> bool', 'async unlock_workflow_instance(workflow_type: str, instance_id: UUID, lock_owner: str) -> bool'], signature_hash='8f08c2837f1e0b80', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=301, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow state store operations.\\n\\n    Provides current state management for:\\n    - Active workflow instance storage\\n    - Fast state queries and updates\\n    - Locking and concurrency control\\n    - State validation and consistency\\n    ')"
      ],
      "validation": [
        "ProtocolInfo(name='ProtocolValidationError', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['__str__() -> str'], signature_hash='5d52ab5889fc6ea7', line_count=5, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=13, is_runtime_checkable=True, domain='validation', properties=['error_type: str', 'message: str', 'context: Dict[str, Any]', 'severity: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation error objects.')",
        "ProtocolInfo(name='ProtocolValidationResult', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['add_error(error_type: str, message: str, context: Dict[str, Any] | None, severity: str) -> None', 'add_warning(error_type: str, message: str, context: Dict[str, Any] | None) -> None', 'async get_summary() -> str'], signature_hash='05abcf029156b534', line_count=8, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=27, is_runtime_checkable=True, domain='validation', properties=['is_valid: bool', 'protocol_name: str', 'implementation_name: str', 'errors: List[ProtocolValidationError]', 'warnings: List[ProtocolValidationError]'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation result objects.')",
        "ProtocolInfo(name='ProtocolValidator', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['async validate_implementation(implementation: Any, protocol: Any) -> ProtocolValidationResult'], signature_hash='6e043c1882118e6a', line_count=2, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=58, is_runtime_checkable=True, domain='validation', properties=['strict_mode: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for protocol validation functionality.')",
        "ProtocolInfo(name='ProtocolValidationDecorator', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['async validate_protocol_implementation(implementation: Any, protocol: Any, strict: bool) -> ProtocolValidationResult', 'validation_decorator(protocol: Any) -> Any'], signature_hash='4334214bfe7c3b97', line_count=2, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=80, is_runtime_checkable=True, domain='validation', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for validation decorator functionality.')",
        "ProtocolInfo(name='ProtocolQualityMetrics', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_complexity_rating() -> str', 'async get_maintainability_rating() -> str'], signature_hash='1fc729aea162162b', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['cyclomatic_complexity: int', 'maintainability_index: float', 'lines_of_code: int', 'code_duplication_percentage: float', 'test_coverage_percentage: float', 'technical_debt_score: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for code quality metrics.')",
        "ProtocolInfo(name='ProtocolQualityIssue', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_issue_summary() -> str', 'is_fixable() -> bool'], signature_hash='cc0086122bcd5ed4', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=35, is_runtime_checkable=True, domain='validation', properties=['issue_type: str', 'severity: str', 'file_path: str', 'line_number: int', 'column_number: int', 'message: str', 'rule_id: str', 'suggested_fix: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for quality issue representation.')",
        "ProtocolInfo(name='ProtocolQualityStandards', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async check_complexity_compliance(complexity: int) -> bool', 'async check_maintainability_compliance(score: float) -> bool'], signature_hash='965031f0df777cf4', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=57, is_runtime_checkable=True, domain='validation', properties=['max_complexity: int', 'min_maintainability_score: float', 'max_line_length: int', 'max_function_length: int', 'max_class_length: int', 'naming_conventions: List[str]', 'required_patterns: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for quality standards configuration.')",
        "ProtocolInfo(name='ProtocolQualityReport', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_critical_issues() -> List[ProtocolQualityIssue]', 'async get_fix_suggestions() -> List[str]'], signature_hash='1f377aca51222c5e', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=78, is_runtime_checkable=True, domain='validation', properties=['file_path: str', \"metrics: 'ProtocolQualityMetrics'\", 'issues: List[ProtocolQualityIssue]', 'standards_compliance: bool', 'overall_score: float', 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive quality assessment report.')",
        "ProtocolInfo(name='ProtocolQualityValidator', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async validate_file_quality(file_path: str, content: str | None) -> ProtocolQualityReport', 'async validate_directory_quality(directory_path: str, file_patterns: List[str] | None) -> List[ProtocolQualityReport]', 'calculate_quality_metrics(file_path: str, content: str | None) -> ProtocolQualityMetrics', 'detect_code_smells(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async check_naming_conventions(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async analyze_complexity(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async validate_documentation(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'suggest_refactoring(file_path: str, content: str | None) -> List[str]', \"configure_standards(standards: 'ProtocolQualityStandards') -> None\", 'async get_validation_summary(reports: List[ProtocolQualityReport]) -> ProtocolValidationResult'], signature_hash='34b88dc46ae01719', line_count=14, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=98, is_runtime_checkable=True, domain='validation', properties=[\"standards: 'ProtocolQualityStandards'\", 'enable_complexity_analysis: bool', 'enable_duplication_detection: bool', 'enable_style_checking: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for code quality validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeQualityValidatorEffect nodes\\n    that assess code quality, complexity metrics, maintainability, and\\n    compliance with coding standards.\\n    ')",
        "ProtocolInfo(name='ProtocolValidationScope', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async should_validate_file(file_path: str) -> bool', 'async get_repository_name() -> str'], signature_hash='a0de12aa507a8e7f', line_count=7, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['repository_path: str', 'validation_types: List[str]', 'file_patterns: List[str]', 'exclusion_patterns: List[str]', 'validation_depth: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for defining validation scope.')",
        "ProtocolInfo(name='ProtocolValidationWorkflow', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_execution_order() -> List[str]', 'is_step_ready(step: str, completed_steps: List[str]) -> bool'], signature_hash='5dffbf8e11c33f6a', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=34, is_runtime_checkable=True, domain='validation', properties=['workflow_id: str', 'workflow_name: str', 'validation_steps: List[str]', 'dependencies: List[str]', 'parallel_execution: bool', 'timeout_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation workflow definition.')",
        "ProtocolInfo(name='ProtocolValidationMetrics', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_performance_summary() -> str'], signature_hash='61e5391d11f94186', line_count=6, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=54, is_runtime_checkable=True, domain='validation', properties=['total_files_processed: int', 'validation_duration_seconds: float', 'memory_usage_mb: float', 'parallel_executions: int', 'cache_hit_rate: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation execution metrics.')",
        "ProtocolInfo(name='ProtocolValidationSummary', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_overall_status() -> str'], signature_hash='4f04f6107aef7287', line_count=7, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=69, is_runtime_checkable=True, domain='validation', properties=['total_validations: int', 'passed_validations: int', 'failed_validations: int', 'warning_count: int', 'critical_issues: int', 'success_rate: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation result summary.')",
        "ProtocolInfo(name='ProtocolValidationReport', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_critical_issues() -> List[ProtocolValidationResult]', 'generate_markdown_report() -> str'], signature_hash='dea7d51ed20bc9db', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=85, is_runtime_checkable=True, domain='validation', properties=['validation_id: str', 'repository_name: str', \"scope: 'ProtocolValidationScope'\", \"workflow: 'ProtocolValidationWorkflow'\", 'results: List[ProtocolValidationResult]', \"summary: 'ProtocolValidationSummary'\", \"metrics: 'ProtocolValidationMetrics'\", 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive validation reports.')",
        "ProtocolInfo(name='ProtocolValidationOrchestrator', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=[\"orchestrate_validation(scope: 'ProtocolValidationScope', workflow: 'ProtocolValidationWorkflow | None') -> ProtocolValidationReport\", \"async validate_imports(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", \"async validate_quality(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", \"async validate_compliance(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", 'async create_validation_workflow(workflow_name: str, validation_steps: List[str], dependencies: List[str], parallel_execution: bool) -> ProtocolValidationWorkflow', 'async create_validation_scope(repository_path: str, validation_types: List[str] | None, file_patterns: List[str] | None, exclusion_patterns: List[str] | None) -> ProtocolValidationScope', 'async get_orchestration_metrics() -> ProtocolValidationMetrics', 'async reset_orchestration_state() -> None'], signature_hash='ad3d509a6ca6bead', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=107, is_runtime_checkable=True, domain='validation', properties=['orchestration_id: str', \"default_scope: 'ProtocolValidationScope'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for validation orchestration in ONEX systems.\\n\\n    This protocol defines the interface for NodeValidationOrchestratorOrchestrator\\n    nodes that coordinate validation workflows across multiple validation nodes\\n    including import, quality, compliance, and security validation.\\n    ')",
        "ProtocolInfo(name='ProtocolComplianceRule', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async check_compliance(content: str, context: str) -> bool', 'async get_fix_suggestion() -> str'], signature_hash='7eb68c776c18a868', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['rule_id: str', 'rule_name: str', 'category: str', 'severity: str', 'description: str', 'required_pattern: str', 'violation_message: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for compliance rule definition.')",
        "ProtocolInfo(name='ProtocolComplianceViolation', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async get_violation_summary() -> str', 'async get_compliance_impact() -> str'], signature_hash='32fab2152ea5a8d2', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=36, is_runtime_checkable=True, domain='validation', properties=[\"rule: 'ProtocolComplianceRule'\", 'file_path: str', 'line_number: int', 'violation_text: str', 'severity: str', 'fix_suggestion: str', 'auto_fixable: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for compliance violation representation.')",
        "ProtocolInfo(name='ProtocolONEXStandards', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async validate_enum_naming(name: str) -> bool', 'async validate_model_naming(name: str) -> bool', 'async validate_protocol_naming(name: str) -> bool', 'async validate_node_naming(name: str) -> bool'], signature_hash='4c27469d5699458b', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=57, is_runtime_checkable=True, domain='validation', properties=['enum_naming_pattern: str', 'model_naming_pattern: str', 'protocol_naming_pattern: str', 'node_naming_pattern: str', 'required_directories: List[str]', 'forbidden_patterns: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for ONEX ecosystem standards.')",
        "ProtocolInfo(name='ProtocolArchitectureCompliance', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async check_dependency_compliance(imports: List[str]) -> List[str]', 'async validate_layer_separation(file_path: str, imports: List[str]) -> List[str]'], signature_hash='122a624bf125e65c', line_count=6, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=85, is_runtime_checkable=True, domain='validation', properties=['allowed_dependencies: List[str]', 'forbidden_dependencies: List[str]', 'required_patterns: List[str]', 'layer_violations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for architectural compliance checking.')",
        "ProtocolInfo(name='ProtocolComplianceReport', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async get_compliance_summary() -> str', 'async get_priority_fixes() -> List[ProtocolComplianceViolation]'], signature_hash='6b3b42760b139a94', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=105, is_runtime_checkable=True, domain='validation', properties=['file_path: str', 'violations: List[ProtocolComplianceViolation]', 'onex_compliance_score: float', 'architecture_compliance_score: float', 'overall_compliance: bool', 'critical_violations: int', 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive compliance report.')",
        "ProtocolInfo(name='ProtocolComplianceValidator', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async validate_file_compliance(file_path: str, content: str | None) -> ProtocolComplianceReport', 'async validate_repository_compliance(repository_path: str, file_patterns: List[str] | None) -> List[ProtocolComplianceReport]', 'async validate_onex_naming(file_path: str, content: str | None) -> List[ProtocolComplianceViolation]', 'async validate_architecture_compliance(file_path: str, content: str | None) -> List[ProtocolComplianceViolation]', 'async validate_directory_structure(repository_path: str) -> List[ProtocolComplianceViolation]', 'async validate_dependency_compliance(file_path: str, imports: List[str]) -> List[ProtocolComplianceViolation]', 'aggregate_compliance_results(reports: List[ProtocolComplianceReport]) -> ProtocolValidationResult', \"add_custom_rule(rule: 'ProtocolComplianceRule') -> None\", \"configure_onex_standards(standards: 'ProtocolONEXStandards') -> None\", 'async get_compliance_summary(reports: List[ProtocolComplianceReport]) -> str'], signature_hash='c277ac10d0be6d25', line_count=14, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=126, is_runtime_checkable=True, domain='validation', properties=[\"onex_standards: 'ProtocolONEXStandards'\", \"architecture_rules: 'ProtocolArchitectureCompliance'\", 'custom_rules: List[ProtocolComplianceRule]', 'strict_mode: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for compliance validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeComplianceValidatorReducer nodes\\n    that validate compliance with ONEX standards, architectural patterns,\\n    and ecosystem requirements.\\n    ')",
        "ProtocolInfo(name='ProtocolImportValidationConfig', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async is_import_allowed(import_path: str) -> bool', 'async is_import_item_allowed(import_item: str) -> bool'], signature_hash='6a48b53840588c28', line_count=6, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['allowed_imports: set[str]', 'allowed_import_items: set[str]', 'repository_type: str', 'validation_mode: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for import validation configuration.')",
        "ProtocolInfo(name='ProtocolImportAnalysis', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async get_risk_summary() -> str', 'async get_recommendations() -> List[str]'], signature_hash='8f68cadf72e493d8', line_count=8, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=33, is_runtime_checkable=True, domain='validation', properties=['import_path: str', 'import_items: List[str]', 'is_valid: bool', 'security_risk: str', 'dependency_level: int', 'analysis_details: Dict[str, Any]'], base_protocols=[], protocol_type='functional', docstring='Protocol for import analysis results.')",
        "ProtocolInfo(name='ProtocolImportValidator', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async validate_import(import_path: str, description: str, context: Dict[str, Any] | None) -> ProtocolValidationResult', 'async validate_from_import(from_path: str, import_items: str, description: str, context: Dict[str, Any] | None) -> ProtocolValidationResult', 'async validate_import_security(import_path: str, context: Dict[str, Any] | None) -> ProtocolImportAnalysis', 'async validate_dependency_chain(import_path: str, max_depth: int) -> List[ProtocolImportAnalysis]', 'async validate_repository_imports(repository_path: str, patterns: List[str] | None) -> List[ProtocolValidationResult]', 'async get_validation_summary() -> Dict[str, Any]', \"configure_validation(config: 'ProtocolImportValidationConfig') -> None\", 'async reset_validation_state() -> None'], signature_hash='2a11b28321ac33c6', line_count=11, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=53, is_runtime_checkable=True, domain='validation', properties=[\"validation_config: 'ProtocolImportValidationConfig'\", 'security_scanning_enabled: bool', 'dependency_analysis_enabled: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for import validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeImportValidatorCompute nodes\\n    that validate import statements, dependencies, and security implications\\n    across ONEX repositories.\\n    ')"
      ],
      "events": [
        "ProtocolInfo(name='ProtocolEventBusContextManager', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_context_manager.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_context_manager', methods=[\"async __aenter__() -> 'ProtocolEventBus'\", 'async __aexit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: object) -> None'], signature_hash='149d74468f689065', line_count=2, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.TypeVar', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for async context managers that yield a ProtocolEventBus-compatible object.\\n\\n    Provides lifecycle management for event bus resources with proper cleanup.\\n    Implementations must support async context management and return a ProtocolEventBus on enter.\\n\\n    Key Features:\\n        - Async context manager support (__aenter__, __aexit__)\\n        - Configuration-based initialization\\n        - Resource lifecycle management\\n        - Proper cleanup and error handling\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class KafkaEventBusContextManager:\\n            async def __aenter__(self) -> KafkaEventBus:\\n                # Implementation creates and connects event bus\\n                event_bus = KafkaEventBus(self.config)\\n                await event_bus.connect()\\n                return event_bus\\n\\n            async def __aexit__(self, exc_type, exc_val, exc_tb):\\n                # Implementation cleans up resources\\n                if hasattr(self, \\'_event_bus\\'):\\n                    await self._event_bus.close()\\n\\n        # Usage in application code\\n        async with context_manager_impl as event_bus:\\n            await event_bus.publish(topic=\"test\", key=None, value=b\"data\", headers={...})\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolRedpandaAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_redpanda_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_redpanda_adapter', methods=[\"redpanda_optimized_defaults() -> dict[str, 'ContextValue']\"], signature_hash='fcf5d912416c9152', line_count=1, imports=['typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'protocol_kafka_adapter.ProtocolKafkaAdapter'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolKafkaAdapter'], protocol_type='mixin', docstring='\\n    Protocol for Redpanda event bus adapter implementations.\\n\\n    Extends ProtocolKafkaAdapter since Redpanda uses Kafka protocol\\n    but with Redpanda-optimized defaults and configurations.\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusBase', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"async publish(event: 'ProtocolEventMessage') -> None\"], signature_hash='08df32bab936af7a', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=18, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Base protocol for event bus operations.\\n\\n    Defines common event publishing interface that both synchronous\\n    and asynchronous event buses must implement. Provides unified\\n    event publishing capabilities across different execution patterns.\\n\\n    Key Features:\\n        - Unified event publishing interface\\n        - Support for both sync and async implementations\\n        - Compatible with dependency injection patterns\\n    ')",
        "ProtocolInfo(name='ProtocolSyncEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"publish_sync(event: 'ProtocolEventMessage') -> None\"], signature_hash='17ecadcd4d5eac60', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=36, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolEventBusBase'], protocol_type='mixin', docstring='\\n    Protocol for synchronous event bus operations.\\n\\n    Defines synchronous event publishing interface for\\n    event bus implementations that operate synchronously.\\n    Inherits from ProtocolEventBusBase for unified interface.\\n\\n    Key Features:\\n        - Synchronous event publishing\\n        - Basic publish interface\\n        - Compatible with sync event processing\\n    ')",
        "ProtocolInfo(name='ProtocolAsyncEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"async publish_async(event: 'ProtocolEventMessage') -> None\"], signature_hash='d0d96aa9d5c81abd', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=65, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolEventBusBase'], protocol_type='mixin', docstring='\\n    Protocol for asynchronous event bus operations.\\n\\n    Defines asynchronous event publishing interface for\\n    event bus implementations that operate asynchronously.\\n    Inherits from ProtocolEventBusBase for unified interface.\\n\\n    Key Features:\\n        - Asynchronous event publishing\\n        - Async/await compatibility\\n        - Non-blocking event processing\\n    ')",
        "ProtocolInfo(name='ProtocolRegistryWithBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=['validate_registry_bus() -> bool', 'has_bus_access() -> bool'], signature_hash='397f305f3ca16ce0', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=94, is_runtime_checkable=True, domain='events', properties=[\"event_bus: 'ProtocolEventBusBase | None'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for registry that provides event bus access.\\n\\n    Defines interface for service registries that provide\\n    access to event bus instances for dependency injection.\\n\\n    Key Features:\\n        - Event bus dependency injection\\n        - Registry-based service location\\n        - Support for both sync and async event buses\\n    ')",
        "ProtocolInfo(name='ProtocolLogEmitter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"emit_log_event(level: 'LiteralLogLevel', message: str, data: dict[str, str | int | float | bool]) -> None\"], signature_hash='e2b3ec1f139e3f0d', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=119, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured log emission.\\n\\n    Defines interface for components that can emit structured\\n    log events with typed data and log levels.\\n\\n    Key Features:\\n        - Structured logging support\\n        - Log level management\\n        - Typed log data\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusInMemory', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_in_memory.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_in_memory', methods=[\"async get_event_history() -> list['ProtocolEventMessage']\", 'clear_event_history() -> None', 'async get_subscriber_count() -> int'], signature_hash='d1276beb45ca2c3d', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for in-memory event bus implementations.\\n\\n    Extends basic event bus functionality with in-memory specific\\n    features for testing, debugging, and development environments.\\n\\n    Key Features:\\n        - Event history tracking for debugging\\n        - Subscriber count monitoring\\n        - Memory-based event storage\\n        - Synchronous event processing\\n        - Development and testing support\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class InMemoryEventBusImpl:\\n            async def get_event_history(self) -> list:\\n                # Implementation returns copy of stored history\\n                return self._event_history.copy()\\n\\n            def clear_event_history(self) -> None:\\n                # Implementation clears stored events\\n                self._event_history.clear()\\n\\n            async def get_subscriber_count(self) -> int:\\n                # Implementation returns active subscriber count\\n                return len(self._subscribers)\\n\\n        # Usage in application code\\n        in_memory_bus: \"ProtocolEventBusInMemory\" = InMemoryEventBusImpl()\\n\\n        # Check event processing history\\n        history = in_memory_bus.get_event_history()\\n        print(f\"Processed {len(history)} events\")\\n\\n        # Monitor active subscribers\\n        subscriber_count = in_memory_bus.get_subscriber_count()\\n        print(f\"Active subscribers: {subscriber_count}\")\\n\\n        # Clear history for testing\\n        in_memory_bus.clear_event_history()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusHeaders', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=['content_type() -> str', 'correlation_id() -> UUID', 'message_id() -> UUID', 'timestamp() -> ProtocolDateTime', 'source() -> str', 'event_type() -> str', 'schema_version() -> ProtocolSemVer', 'destination() -> str | None', 'trace_id() -> str | None', 'span_id() -> str | None', 'parent_span_id() -> str | None', 'operation_name() -> str | None', \"priority() -> Literal['low', 'normal', 'high', 'critical'] | None\", 'routing_key() -> str | None', 'partition_key() -> str | None', 'retry_count() -> int | None', 'max_retries() -> int | None', 'ttl_seconds() -> int | None'], signature_hash='13f8b867e43acdd5', line_count=18, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=20, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized headers for ONEX event bus messages.\\n\\n    Enforces strict interoperability across all agents and prevents\\n    integration failures from header naming inconsistencies.\\n    Based on ONEX messaging patterns and distributed tracing requirements.\\n\\n    ID Format Specifications:\\n    - UUID format: \"550e8400-e29b-41d4-a716-446655440000\" (32 hex digits with hyphens)\\n    - OpenTelemetry Trace ID: \"4bf92f3577b34da6a3ce929d0e0e4736\" (32 hex digits, no hyphens)\\n    - OpenTelemetry Span ID: \"00f067aa0ba902b7\" (16 hex digits, no hyphens)\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaEventBusAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=[\"async publish(topic: str, key: bytes | None, value: bytes, headers: 'ProtocolEventBusHeaders') -> None\", 'async subscribe(topic: str, group_id: str, on_message: Callable[[ProtocolEventMessage], Awaitable[None]]) -> Callable[[], Awaitable[None]]', 'async close() -> None'], signature_hash='e84382a94184d294', line_count=3, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=126, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for Event Bus Adapters supporting pluggable Kafka/Redpanda backends.\\n\\n    Implements the ONEX Messaging Design v0.3 Event Bus Adapter interface\\n    enabling drop-in support for both Kafka and Redpanda without code changes.\\n\\n    Environment isolation and node group mini-meshes are supported through\\n    topic naming conventions and group isolation patterns.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class KafkaAdapter:\\n            async def publish(self, topic: str, key: Optional[bytes],\\n                            value: bytes, headers: \"ProtocolEventBusHeaders\") -> None:\\n                # Kafka-specific publishing logic\\n                producer = self._get_producer()\\n                await producer.send(topic, key=key, value=value, headers=headers)\\n\\n            async def subscribe(self, topic: str, group_id: str,\\n                              on_message: Callable) -> Callable:\\n                # Kafka-specific subscription logic\\n                consumer = self._create_consumer(group_id)\\n                consumer.subscribe([topic])\\n                # Return unsubscribe function\\n                return lambda: consumer.unsubscribe()\\n\\n        # Usage in application code\\n        adapter: \"ProtocolKafkaEventBusAdapter\" = KafkaAdapter()\\n\\n        # Publishing events\\n        await adapter.publish(\\n            topic=\"user-events\",\\n            key=b\"user-123\",\\n            value=json.dumps({\"event\": \"user_created\"}).encode(),\\n            headers={\\n                \"content_type\": \"application/json\",\\n                \"correlation_id\": uuid.uuid4(),\\n                \"message_id\": uuid.uuid4(),\\n                \"timestamp\": datetime.now(),\\n                \"source\": \"example-service\",\\n                \"event_type\": \"user.created\",\\n                \"schema_version\": SemVerImplementation(1, 0, 0)  # Implementation example\\n            }\\n        )\\n\\n        # Subscribing to events\\n        async def handle_message(msg: \"ProtocolEventMessage\") -> None:\\n            data = json.loads(msg.value.decode())\\n            print(f\"Received: {data}\")\\n            await msg.ack()\\n\\n        unsubscribe = await adapter.subscribe(\\n            topic=\"user-events\",\\n            group_id=\"user-service\",\\n            on_message=handle_message\\n        )\\n\\n        # Later cleanup\\n        await unsubscribe()\\n        await adapter.close()\\n        ```\\n\\n    Topic Naming Conventions:\\n        - Environment isolation: `{env}-{topic}` (e.g., \"prod-user-events\")\\n        - Node group isolation: `{group}-{topic}` (e.g., \"auth-user-events\")\\n        - Combined: `{env}-{group}-{topic}` (e.g., \"prod-auth-user-events\")\\n    ')",
        "ProtocolInfo(name='ProtocolEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=['adapter() -> ProtocolKafkaEventBusAdapter', 'environment() -> str', 'group() -> str', \"async publish(topic: str, key: bytes | None, value: bytes, headers: 'ProtocolEventBusHeaders | None') -> None\", 'async subscribe(topic: str, group_id: str, on_message: Callable[[ProtocolEventMessage], Awaitable[None]]) -> Callable[[], Awaitable[None]]', 'async broadcast_to_environment(command: str, payload: dict[str, Any], target_environment: str | None) -> None', 'async send_to_group(command: str, payload: dict[str, Any], target_group: str) -> None', 'async close() -> None'], signature_hash='63c88c8ff0271917', line_count=8, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=239, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    ONEX event bus protocol for distributed messaging infrastructure.\\n\\n    Implements the ONEX Messaging Design v0.3:\\n    - Environment isolation (dev, staging, prod)\\n    - Node group mini-meshes\\n    - Kafka/Redpanda adapter pattern\\n    - Standardized topic naming and headers\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusService', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_service', methods=[\"async get_event_bus() -> 'ProtocolEventMessage'\", 'shutdown() -> None', 'is_running() -> bool', 'async get_node_count() -> int', 'async list_nodes() -> list[str]'], signature_hash='998d3d681e65cf36', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol defining the required interface for event bus service implementations.\\n\\n    All event bus service classes must implement these methods to ensure:\\n    - Consistent lifecycle management\\n    - Proper shutdown handling\\n    - Standard event bus access\\n    - Service status monitoring\\n\\n    This protocol prevents runtime errors like missing shutdown() methods.\\n    ')",
        "ProtocolInfo(name='ProtocolHttpEventBusAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_service', methods=[\"async publish(event: 'ProtocolEventMessage') -> bool\", \"async subscribe(handler: Callable[['ProtocolEventMessage'], bool]) -> bool\", \"async unsubscribe(handler: Callable[['ProtocolEventMessage'], bool]) -> bool\", 'is_healthy() -> bool', 'close() -> None'], signature_hash='e461719d49f2c6cb', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=76, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for event bus adapters that wrap HTTP/network event bus services.\\n\\n    This is for lightweight adapters that connect to external event bus services.\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusCredentials', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_types', methods=['validate_credentials() -> bool', 'is_secure() -> bool'], signature_hash='039938e21c790fe5', line_count=9, imports=['typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ContextValue', 'omnibase_spi.protocols.types.ProtocolEvent'], line_number=7, is_runtime_checkable=True, domain='events', properties=['token: str | None', 'username: str | None', 'password: str | None', 'cert: str | None', 'key: str | None', 'ca: str | None', \"extra: dict[str, 'ContextValue'] | None\"], base_protocols=[], protocol_type='functional', docstring='\\n    Canonical credentials protocol for event bus authentication/authorization.\\n    Supports token, username/password, and TLS certs for future event bus support.\\n    ')",
        "ProtocolInfo(name='ProtocolEventPubSub', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_types', methods=['credentials() -> ProtocolEventBusCredentials | None', \"async publish(event: 'ProtocolEvent') -> None\", \"async publish_async(event: 'ProtocolEvent') -> None\", 'async subscribe(callback: Callable[[ProtocolEvent], None]) -> None', 'async subscribe_async(callback: Callable[[ProtocolEvent], None]) -> None', 'unsubscribe(callback: Callable[[ProtocolEvent], None]) -> None', 'async unsubscribe_async(callback: Callable[[ProtocolEvent], None]) -> None', 'clear() -> None', 'bus_id() -> str'], signature_hash='ef55c01aa0ec0eb7', line_count=9, imports=['typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ContextValue', 'omnibase_spi.protocols.types.ProtocolEvent'], line_number=31, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Canonical protocol for simple event pub/sub operations.\\n    Defines basic publish/subscribe interface for event emission and handling.\\n    Provides a simpler alternative to the full distributed ProtocolEventBus.\\n    Supports both synchronous and asynchronous methods for maximum flexibility.\\n    Implementations may provide either or both, as appropriate.\\n    Optionally supports clear() for test/lifecycle management.\\n    All event bus implementations must expose a unique, stable bus_id (str) for diagnostics, registry, and introspection.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConfig', file_path='src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_kafka_adapter', methods=[], signature_hash='80679eab771af945', line_count=9, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_event_bus.ProtocolKafkaEventBusAdapter'], line_number=14, is_runtime_checkable=True, domain='events', properties=['security_protocol: str', 'sasl_mechanism: str', 'sasl_username: str | None', 'sasl_password: str | None', 'ssl_cafile: str | None', 'auto_offset_reset: str', 'enable_auto_commit: bool', 'session_timeout_ms: int', 'request_timeout_ms: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for Kafka configuration parameters.')",
        "ProtocolInfo(name='ProtocolKafkaAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_kafka_adapter', methods=['bootstrap_servers() -> str', 'environment() -> str', 'group() -> str', 'config() -> ProtocolKafkaConfig | None', 'kafka_config() -> ProtocolKafkaConfig', 'build_topic_name(topic: str) -> str'], signature_hash='a80fc83843ab57d1', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_event_bus.ProtocolKafkaEventBusAdapter'], line_number=29, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolKafkaEventBusAdapter'], protocol_type='mixin', docstring='\\n    Protocol for Kafka event bus adapter implementations.\\n\\n    Extends ProtocolKafkaEventBusAdapter with Kafka-specific configuration\\n    and connection management protocols.\\n    ')"
      ]
    },
    "protocols_by_type": {
      "functional": [
        "ProtocolInfo(name='ProtocolFileReader', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_reader.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_reader', methods=['async read_text(path: str) -> str', 'async read_yaml(path: str, data_class: type[T]) -> T', 'async exists(path: str) -> bool'], signature_hash='1d2eb7ed112b2022', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'typing.Any'], line_number=17, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for reading file contents.\\n\\n    This abstraction allows for different implementations:\\n    - FileSystemFileReader: Reads from actual filesystem\\n    - MockFileReader: Returns predefined content for testing\\n    - RemoteFileReader: Could read from S3, HTTP, etc.\\n    ')",
        "ProtocolInfo(name='ProtocolFileTypeHandler', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=['metadata() -> ProtocolNodeMetadata', 'node_name() -> str', 'node_version() -> ProtocolSemVer', 'node_author() -> str', 'node_description() -> str', 'supported_extensions() -> list[str]', 'supported_filenames() -> list[str]', 'node_priority() -> int', 'requires_content_analysis() -> bool', 'async can_handle(path: str, content: str) -> ProtocolCanHandleResult', 'async extract_block(path: str, content: str) -> ProtocolExtractedBlock', \"serialize_block(meta: 'ProtocolExtractedBlock') -> ProtocolSerializedBlock\", 'normalize_rest(rest: str) -> str', \"async stamp(path: str, content: str, options: 'ProtocolStampOptions') -> ProtocolOnexResult\", \"async pre_validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult | None\", \"async post_validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult | None\", \"async validate(path: str, content: str, options: 'ProtocolValidationOptions') -> ProtocolOnexResult\"], signature_hash='6a3eb9d463b5522b', line_count=17, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=36, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for file type nodes in the ONEX stamper engine.\\n    All methods and metadata must use canonical result models per typing_and_protocols rule.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class NodePythonFileProcessor:\\n            @property\\n            def metadata(self) -> ProtocolNodeMetadata:\\n                # Implementation would return configured metadata\\n                ...\\n\\n            @property\\n            def node_name(self) -> str:\\n                # Implementation returns node identifier\\n                ...\\n\\n            def can_handle(self, path: str, content: str) -> ProtocolCanHandleResult:\\n                # Implementation determines if file can be processed\\n                ...\\n\\n            def extract_block(self, path: str, content: str) -> ProtocolExtractedBlock:\\n                # Implementation extracts structured block from file content\\n                ...\\n\\n            def stamp(self, path: str, content: str, options: \"ProtocolStampOptions\") -> ProtocolOnexResult:\\n                # Implementation adds metadata stamp to file\\n                ...\\n\\n            def validate(self, path: str, content: str, options: \"ProtocolValidationOptions\") -> ProtocolOnexResult:\\n                # Implementation validates file content and metadata\\n                ...\\n\\n        # Usage in application\\n        node: \"ProtocolFileTypeHandler\" = NodePythonFileProcessor()\\n\\n        # Check if node can process a file\\n        result = node.can_handle(\"example.py\", \"file_content\")\\n        if result.can_handle:\\n            # Extract, stamp, and validate file\\n            block = node.extract_block(\"example.py\", \"file_content\")\\n            # ... implementation handles file operations\\n        ```\\n\\n    Node Implementation Patterns:\\n        - File type detection: Extension-based, content-based, and heuristic analysis\\n        - Metadata extraction: Language-specific parsing (AST, regex, etc.)\\n        - Stamping workflow: Extract \u2192 Serialize \u2192 Inject \u2192 Validate\\n        - Validation modes: Syntax checking, metadata compliance, strict requirements\\n        - Error handling: Graceful degradation with detailed error messages\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['serialize() -> dict[str, object]', 'validate() -> bool', 'get_type_info() -> str'], signature_hash='c4b3bc95f22f76cb', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=19, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow data values supporting serialization and validation.')",
        "ProtocolInfo(name='ProtocolWorkflowStringValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_string_length() -> int', 'is_empty_string() -> bool'], signature_hash='c4a42f1002217fbb', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=36, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string-based workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_list_length() -> int', 'is_empty_list() -> bool'], signature_hash='84e779c9ee10ed41', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=51, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string list workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowStringDictValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_dict_keys() -> list[str]', 'has_key(key: str) -> bool'], signature_hash='7ae62284b213aff8', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=66, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for string dictionary workflow values.')",
        "ProtocolInfo(name='ProtocolWorkflowNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['is_integer() -> bool', 'is_positive() -> bool'], signature_hash='7983be3306b397b2', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=81, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for numeric workflow values (int or float).')",
        "ProtocolInfo(name='ProtocolWorkflowStructuredValue', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_structure_depth() -> int', \"flatten_structure() -> dict[str, 'ContextValue']\"], signature_hash='9e2728b3c18fd043', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=96, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolWorkflowValue'], protocol_type='functional', docstring='Protocol for structured workflow values with context data.')",
        "ProtocolInfo(name='ProtocolTypedWorkflowData', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['get_type_name() -> str', 'serialize_typed() -> dict[str, Any]'], signature_hash='82fb853101ff2c45', line_count=3, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=114, is_runtime_checkable=True, domain='types', properties=['value: T_WorkflowValue'], base_protocols=['Generic[T_WorkflowValue]'], protocol_type='functional', docstring='Protocol for strongly typed workflow data values.')",
        "ProtocolInfo(name='ProtocolWorkflowMetadata', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_metadata() -> bool', 'is_complete() -> bool'], signature_hash='5ce24225c795cb57', line_count=11, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=186, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'created_by: str', 'environment: str', 'group: str', \"version: 'ProtocolSemVer'\", \"tags: dict[str, 'ContextValue']\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow metadata objects.')",
        "ProtocolInfo(name='ProtocolRetryConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_retry_config() -> bool', 'is_valid_policy() -> bool'], signature_hash='a4a11450acb7c879', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=209, is_runtime_checkable=True, domain='types', properties=['policy: LiteralRetryPolicy', 'max_attempts: int', 'initial_delay_seconds: float', 'max_delay_seconds: float', 'backoff_multiplier: float', 'jitter_enabled: bool', 'retryable_errors: list[str]', 'non_retryable_errors: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry configuration objects.')",
        "ProtocolInfo(name='ProtocolTimeoutConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_timeout_config() -> bool', 'is_reasonable() -> bool'], signature_hash='bbf6d0a83382de76', line_count=7, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=231, is_runtime_checkable=True, domain='types', properties=['timeout_type: LiteralTimeoutType', 'timeout_seconds: int', 'warning_seconds: int | None', 'grace_period_seconds: int | None', 'escalation_policy: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for timeout configuration objects.')",
        "ProtocolInfo(name='ProtocolTaskDependency', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_dependency() -> bool', 'is_conditional() -> bool'], signature_hash='00c25e5cfedd29c5', line_count=6, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=250, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', \"dependency_type: Literal['hard', 'soft', 'conditional']\", 'condition: str | None', 'timeout_seconds: int | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for task dependency objects.')",
        "ProtocolInfo(name='ProtocolWorkflowContext', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_context() -> bool', 'has_required_data() -> bool'], signature_hash='bbb01ee9c1aaeb81', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=268, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'isolation_level: LiteralIsolationLevel', \"data: dict[str, 'ProtocolWorkflowValue']\", \"secrets: dict[str, 'ContextValue']\", 'capabilities: list[str]', 'resource_limits: dict[str, int]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow context objects with isolation.')",
        "ProtocolInfo(name='ProtocolTaskConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_task() -> bool', 'has_valid_dependencies() -> bool'], signature_hash='b3b881ef5fbd80ba', line_count=13, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=290, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', 'task_name: str', 'task_type: LiteralTaskType', 'node_type: LiteralNodeType', 'execution_semantics: LiteralExecutionSemantics', 'priority: LiteralTaskPriority', \"dependencies: list['ProtocolTaskDependency']\", \"retry_config: 'ProtocolRetryConfiguration'\", \"timeout_config: 'ProtocolTimeoutConfiguration'\", 'resource_requirements: dict[str, Any]', \"annotations: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for task configuration objects.')",
        "ProtocolInfo(name='ProtocolWorkflowEvent', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_event() -> bool', 'is_valid_sequence() -> bool'], signature_hash='0d6d6652329cbbb9', line_count=15, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=315, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: LiteralWorkflowEventType', 'workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'sequence_number: int', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'idempotency_key: str', \"payload: dict[str, 'ProtocolWorkflowValue']\", \"metadata: dict[str, 'ContextValue']\", 'causation_id: UUID | None', 'correlation_chain: list[UUID]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow event objects with event sourcing.')",
        "ProtocolInfo(name='ProtocolWorkflowSnapshot', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_snapshot() -> bool', 'is_consistent() -> bool'], signature_hash='a5d5c4124e3b1302', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=342, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', 'instance_id: UUID', 'sequence_number: int', 'state: LiteralWorkflowState', \"context: 'ProtocolWorkflowContext'\", \"tasks: list['ProtocolTaskConfiguration']\", \"created_at: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow snapshot objects.')",
        "ProtocolInfo(name='ProtocolTaskResult', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_result() -> bool', 'is_success() -> bool'], signature_hash='cabe5d5ca139f1ba', line_count=13, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=364, is_runtime_checkable=True, domain='types', properties=['task_id: UUID', 'execution_id: UUID', 'state: LiteralTaskState', \"result_data: dict[str, 'ProtocolWorkflowValue']\", 'error_message: str | None', 'error_code: str | None', 'retry_count: int', 'execution_time_seconds: float', 'resource_usage: dict[str, float]', 'output_artifacts: list[str]', \"events_emitted: list['ProtocolWorkflowEvent']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for task execution results.')",
        "ProtocolInfo(name='ProtocolCompensationAction', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_compensation() -> bool', 'can_execute() -> bool'], signature_hash='a022da442c9efbf9', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=389, is_runtime_checkable=True, domain='types', properties=['compensation_id: UUID', 'task_id: UUID', \"action_type: Literal['rollback', 'cleanup', 'notify', 'custom']\", \"action_data: dict[str, 'ProtocolWorkflowValue']\", 'timeout_seconds: int', \"retry_config: 'ProtocolRetryConfiguration'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for compensation action objects.')",
        "ProtocolInfo(name='ProtocolWorkflowDefinition', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_definition() -> bool', 'is_valid_schema() -> bool'], signature_hash='391c89c69066c78e', line_count=12, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=409, is_runtime_checkable=True, domain='types', properties=['workflow_type: str', \"version: 'ProtocolSemVer'\", 'name: str', 'description: str', \"tasks: list['ProtocolTaskConfiguration']\", \"default_retry_config: 'ProtocolRetryConfiguration'\", \"default_timeout_config: 'ProtocolTimeoutConfiguration'\", \"compensation_actions: list['ProtocolCompensationAction']\", 'validation_rules: dict[str, Any]', 'schema: dict[str, Any]'], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow definition objects.')",
        "ProtocolInfo(name='ProtocolNodeCapability', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_capability() -> bool', 'is_supported() -> bool'], signature_hash='c4bddf7c3983665e', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=433, is_runtime_checkable=True, domain='types', properties=['capability_name: str', \"version: 'ProtocolSemVer'\", 'node_types: list[LiteralNodeType]', 'resource_requirements: dict[str, Any]', 'configuration_schema: dict[str, Any]', 'supported_task_types: list[LiteralTaskType]'], base_protocols=[], protocol_type='functional', docstring='Protocol for node capability objects.')",
        "ProtocolInfo(name='ProtocolWorkflowServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_service_instance() -> bool', 'is_healthy() -> bool'], signature_hash='a8ecd65a95f2b5c5', line_count=9, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=453, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'service_type: str', 'endpoint: str', 'health_check_url: str', \"metadata: dict[str, 'ContextValue']\", \"capabilities: list['ProtocolNodeCapability']\", \"last_heartbeat: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for discovered service instance objects in workflow orchestration.')",
        "ProtocolInfo(name='ProtocolRecoveryPoint', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_recovery_point() -> bool', 'is_restorable() -> bool'], signature_hash='455ffeb61ad39ec7', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=474, is_runtime_checkable=True, domain='types', properties=['recovery_id: UUID', 'workflow_type: str', 'instance_id: UUID', 'sequence_number: int', 'state: LiteralWorkflowState', \"recovery_type: Literal['checkpoint', 'savepoint', 'snapshot']\", \"created_at: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for recovery point objects.')",
        "ProtocolInfo(name='ProtocolReplayStrategy', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_replay_strategy() -> bool', 'is_executable() -> bool'], signature_hash='e50a68b5275cc63c', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=496, is_runtime_checkable=True, domain='types', properties=[\"strategy_type: Literal['full', 'partial', 'from_checkpoint', 'from_sequence']\", 'start_sequence: int | None', 'end_sequence: int | None', 'event_filters: list[str]', 'skip_failed_events: bool', 'validate_state: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for replay strategy objects.')",
        "ProtocolInfo(name='ProtocolEventStream', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_stream() -> bool', 'is_complete_stream() -> bool'], signature_hash='809e8fbe551f11ca', line_count=10, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=516, is_runtime_checkable=True, domain='types', properties=['stream_id: str', 'workflow_type: str', 'instance_id: UUID', 'start_sequence: int', 'end_sequence: int', \"events: list['ProtocolWorkflowEvent']\", 'is_complete: bool', 'next_token: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for event stream objects.')",
        "ProtocolInfo(name='ProtocolEventProjection', file_path='src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py', module_path='omnibase_spi.protocols.types.protocol_workflow_orchestration_types', methods=['validate_projection() -> bool', 'is_up_to_date() -> bool'], signature_hash='7f08a3e32620b07b', line_count=8, imports=['typing.Any', 'typing.Generic', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=538, is_runtime_checkable=True, domain='types', properties=['projection_name: str', 'workflow_type: str', 'last_processed_sequence: int', \"projection_data: dict[str, 'ProtocolWorkflowValue']\", \"created_at: 'ProtocolDateTime'\", \"updated_at: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for event projection objects.')",
        "ProtocolInfo(name='ProtocolSemVer', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['__str__() -> str'], signature_hash='cc48dac04fbba2e2', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=13, is_runtime_checkable=True, domain='types', properties=['major: int', 'minor: int', 'patch: int'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for semantic version objects following SemVer specification.\\n\\n    Provides a structured approach to versioning with major, minor, and patch\\n    components. Used throughout ONEX for protocol versioning, dependency\\n    management, and compatibility checking.\\n\\n    Key Features:\\n        - Major version: Breaking changes\\n        - Minor version: Backward-compatible additions\\n        - Patch version: Backward-compatible fixes\\n        - String representation: \"major.minor.patch\" format\\n\\n    Usage:\\n        version = some_protocol_object.version\\n        if version.major >= 2:\\n            # Use new API features\\n        compatibility_string = str(version)  # \"2.1.3\"\\n    ')",
        "ProtocolInfo(name='ProtocolContextValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_for_context() -> bool', 'serialize_for_context() -> dict[str, object]', 'get_context_type_hint() -> str'], signature_hash='6b1f8bd6d2df4d1a', line_count=3, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=65, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for context data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolSupportedMetadataType', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['__str__() -> str', 'validate_for_metadata() -> bool'], signature_hash='28773c15fb1950dd', line_count=3, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=120, is_runtime_checkable=True, domain='types', properties=['__omnibase_metadata_type_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for types that can be stored in ONEX metadata systems.\\n\\n    This marker protocol defines the contract for objects that can be safely\\n    stored, serialized, and retrieved from metadata storage systems. Objects\\n    implementing this protocol guarantee string convertibility for persistence.\\n\\n    Key Features:\\n        - Marker interface for metadata compatibility\\n        - String conversion guarantee\\n        - Runtime type checking support\\n        - Safe for serialization/deserialization\\n\\n    Usage:\\n        def store_metadata(key: str, value: \"ProtocolSupportedMetadataType\"):\\n            metadata_store[key] = str(value)\\n    ')",
        "ProtocolInfo(name='ProtocolConfigValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_config_value() -> bool', 'has_valid_default() -> bool'], signature_hash='8bc54144e93051ca', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=151, is_runtime_checkable=True, domain='types', properties=['key: str', 'value: ContextValue', \"config_type: Literal['string', 'int', 'float', 'bool', 'list']\", 'default_value: ContextValue | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for type-safe configuration values in ONEX systems.\\n\\n    Provides structured configuration management with type enforcement,\\n    default value handling, and validation support. Used for service\\n    configuration, node parameters, and runtime settings.\\n\\n    Key Features:\\n        - Typed configuration values (string, int, float, bool, list)\\n        - Default value support for fallback behavior\\n        - Key-value structure for configuration management\\n        - Type validation and conversion support\\n\\n    Usage:\\n        config = ProtocolConfigValue(\\n            key=\"max_retries\",\\n            value=3,\\n            config_type=\"int\",\\n            default_value=1\\n        )\\n    ')",
        "ProtocolInfo(name='ProtocolLogContext', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[\"to_dict() -> dict[str, 'ContextValue']\"], signature_hash='048198a88f2f3bf7', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=189, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured logging context objects.\\n\\n    Provides standardized context information for distributed logging\\n    across ONEX services. Context objects carry metadata, correlation\\n    IDs, and structured data for observability and debugging.\\n\\n    Key Features:\\n        - Structured context data with type safety\\n        - Dictionary conversion for serialization\\n        - Compatible with typed ContextValue constraints\\n        - Supports distributed tracing and correlation\\n\\n    Usage:\\n        context = create_log_context()\\n        logger.info(\"Operation completed\", context=context.to_dict())\\n    ')",
        "ProtocolInfo(name='ProtocolLogEntry', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_log_entry() -> bool', 'is_complete() -> bool'], signature_hash='feb28e942088e7f9', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=220, is_runtime_checkable=True, domain='types', properties=['level: LiteralLogLevel', 'message: str', 'correlation_id: UUID', \"timestamp: 'ProtocolDateTime'\", \"context: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured log entry objects in ONEX systems.\\n\\n    Standardizes log entries across all ONEX services with consistent\\n    structure for level, messaging, correlation tracking, and context.\\n    Essential for distributed system observability and debugging.\\n\\n    Key Features:\\n        - Standardized log levels (TRACE through FATAL)\\n        - Correlation ID for distributed tracing\\n        - Structured context with type safety\\n        - Timestamp for chronological ordering\\n\\n    Usage:\\n        entry = create_log_entry(\\n            level=\"INFO\",\\n            message=\"User authenticated successfully\",\\n            correlation_id=request.correlation_id,\\n            context={\"user_id\": user.id, \"action\": \"login\"}\\n        )\\n    ')",
        "ProtocolInfo(name='ProtocolSerializationResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_serialization() -> bool', 'has_data() -> bool'], signature_hash='8a4f553033958959', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=259, is_runtime_checkable=True, domain='types', properties=['success: bool', 'data: str', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for serialization operation results.\\n\\n    Provides standardized results for serialization operations across\\n    ONEX services, including success status, serialized data, and\\n    error handling information.\\n\\n    Key Features:\\n        - Success/failure indication\\n        - Serialized data as string format\\n        - Detailed error messages for debugging\\n        - Consistent result structure across services\\n\\n    Usage:\\n        result = serializer.serialize(data)\\n        if result.success:\\n            send_data(result.data)\\n        else:\\n            logger.error(f\"Serialization failed: {result.error_message}\")\\n    ')",
        "ProtocolInfo(name='ProtocolNodeMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_node_metadata() -> bool', 'is_complete() -> bool'], signature_hash='495b508622cf3cd0', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=295, is_runtime_checkable=True, domain='types', properties=['node_id: str', 'node_type: str', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX node metadata objects.\\n\\n    Defines the essential metadata structure for nodes in the ONEX\\n    distributed system, including identification, type classification,\\n    and extensible metadata storage.\\n\\n    Key Features:\\n        - Unique node identification\\n        - Node type classification (COMPUTE, EFFECT, REDUCER, ORCHESTRATOR)\\n        - Extensible metadata dictionary with type safety\\n        - Runtime node introspection support\\n\\n    Usage:\\n        metadata = node.get_metadata()\\n        if metadata.node_type == \"COMPUTE\":\\n            schedule_computation_task(metadata.node_id)\\n    ')",
        "ProtocolInfo(name='ProtocolCacheStatistics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_statistics() -> bool', 'is_current() -> bool'], signature_hash='2f5e903e3ce6e823', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=329, is_runtime_checkable=True, domain='types', properties=['hit_count: int', 'miss_count: int', 'total_requests: int', 'hit_ratio: float', 'memory_usage_bytes: int', 'entry_count: int', 'eviction_count: int', 'last_accessed: datetime | None', 'cache_size_limit: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive cache service statistics.\\n\\n    Provides detailed performance and usage metrics for cache services\\n    across ONEX systems. Used for monitoring, optimization, and capacity\\n    planning of distributed caching infrastructure.\\n\\n    Key Features:\\n        - Performance metrics (hits, misses, ratios)\\n        - Resource usage tracking (memory, entry counts)\\n        - Operational statistics (evictions, access patterns)\\n        - Capacity management information\\n\\n    Metrics Description:\\n        - hit_count: Number of successful cache retrievals\\n        - miss_count: Number of cache misses requiring data source access\\n        - hit_ratio: Efficiency ratio (hits / total_requests)\\n        - memory_usage_bytes: Current memory consumption\\n        - entry_count: Number of cached entries\\n        - eviction_count: Number of entries removed due to capacity limits\\n        - last_accessed: Timestamp of most recent cache access\\n        - cache_size_limit: Maximum cache capacity (if configured)\\n\\n    Usage:\\n        stats = cache_service.get_statistics()\\n        if stats.hit_ratio < 0.8:\\n            logger.warning(f\"Low cache hit ratio: {stats.hit_ratio:.2%}\")\\n    ')",
        "ProtocolInfo(name='ProtocolMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metadata() -> bool', 'is_up_to_date() -> bool'], signature_hash='245034e1e7cc70b8', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=393, is_runtime_checkable=True, domain='types', properties=[\"data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", \"created_at: 'ProtocolDateTime'\", \"updated_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for structured metadata - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolMetadataOperations', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['get_value(key: str) -> ContextValue', 'has_key(key: str) -> bool', 'keys() -> list[str]', 'update_value(key: str, value: ContextValue) -> None'], signature_hash='82b986211bb98771', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=411, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for metadata operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolActionPayload', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_payload() -> bool', 'has_valid_parameters() -> bool'], signature_hash='cb730f6304cd7ba4', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=424, is_runtime_checkable=True, domain='types', properties=['target_id: str', 'operation: str', \"parameters: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for action payload with specific data.')",
        "ProtocolInfo(name='ProtocolAction', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_action() -> bool', 'is_executable() -> bool'], signature_hash='832a76a2dd18acc1', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=441, is_runtime_checkable=True, domain='types', properties=['type: str', \"payload: 'ProtocolActionPayload'\", \"timestamp: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for reducer actions.')",
        "ProtocolInfo(name='ProtocolState', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_state() -> bool', 'is_consistent() -> bool'], signature_hash='0279e1f59cf90550', line_count=5, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=458, is_runtime_checkable=True, domain='types', properties=[\"metadata: 'ProtocolMetadata'\", 'version: int', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for reducer state.')",
        "ProtocolInfo(name='ProtocolNodeMetadataBlock', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metadata_block() -> bool', 'is_complete() -> bool'], signature_hash='77307ca8a8909125', line_count=12, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=475, is_runtime_checkable=True, domain='types', properties=['uuid: str', 'name: str', 'description: str', \"version: 'ProtocolSemVer'\", \"metadata_version: 'ProtocolSemVer'\", 'namespace: str', \"created_at: 'ProtocolDateTime'\", \"last_modified_at: 'ProtocolDateTime'\", 'lifecycle: str', \"protocol_version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for node metadata block objects.')",
        "ProtocolInfo(name='ProtocolSchemaObject', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_schema() -> bool', 'is_valid_schema() -> bool'], signature_hash='31995d0b18265d88', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=499, is_runtime_checkable=True, domain='types', properties=['schema_id: str', 'schema_type: str', \"schema_data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", 'is_valid: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for schema data objects.')",
        "ProtocolInfo(name='ProtocolErrorInfo', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error_info() -> bool', 'is_retryable() -> bool'], signature_hash='680155ab21f6d6c1', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=518, is_runtime_checkable=True, domain='types', properties=['error_type: str', 'message: str', 'trace: str | None', 'retryable: bool', 'backoff_strategy: str | None', 'max_attempts: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive error information in workflow results.\\n\\n    Provides detailed error context for workflow operations, including\\n    recovery strategies and retry configuration. Essential for resilient\\n    distributed system operation and automated error recovery.\\n\\n    Key Features:\\n        - Error type classification for automated handling\\n        - Human-readable error messages\\n        - Stack trace information for debugging\\n        - Retry configuration and backoff strategies\\n\\n    Usage:\\n        error_info = ProtocolErrorInfo(\\n            error_type=\"TimeoutError\",\\n            message=\"Operation timed out after 30 seconds\",\\n            trace=traceback.format_exc(),\\n            retryable=True,\\n            backoff_strategy=\"exponential\",\\n            max_attempts=3\\n        )\\n\\n        if error_info.retryable:\\n            schedule_retry(operation, error_info.backoff_strategy)\\n    ')",
        "ProtocolInfo(name='ProtocolSystemEvent', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_system_event() -> bool', 'is_well_formed() -> bool'], signature_hash='b752fe1c319e9dea', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=563, is_runtime_checkable=True, domain='types', properties=['type: str', \"payload: dict[str, 'ContextValue']\", 'timestamp: float', 'source: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for system events.')",
        "ProtocolInfo(name='ProtocolNodeResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_result() -> bool', 'is_successful() -> bool'], signature_hash='a62b9df48dec3712', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=581, is_runtime_checkable=True, domain='types', properties=['value: ContextValue | None', 'is_success: bool', 'is_failure: bool', \"error: 'ProtocolErrorInfo | None'\", 'trust_score: float', 'provenance: list[str]', \"metadata: dict[str, 'ContextValue']\", \"events: list['ProtocolSystemEvent']\", \"state_delta: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive node processing results with monadic composition.\\n\\n    Provides rich result information for ONEX node operations, including\\n    success/failure indication, error details, trust scores, provenance\\n    tracking, and state changes. Enables sophisticated result composition\\n    and error handling in distributed workflows.\\n\\n    Key Features:\\n        - Monadic success/failure patterns\\n        - Trust scoring for result confidence\\n        - Provenance tracking for data lineage\\n        - Event emission for observability\\n        - State delta tracking for reducers\\n\\n    Usage:\\n        result = node.process(input_data)\\n\\n        # Monadic composition patterns\\n        if result.is_success:\\n            next_result = next_node.process(result.value)\\n        else:\\n            handle_error(result.error)\\n\\n        # Trust evaluation\\n        if result.trust_score > 0.8:\\n            accept_result(result.value)\\n\\n        # State management\\n        for key, value in result.state_delta.items():\\n            state_manager.update(key, value)\\n    ')",
        "ProtocolInfo(name='ProtocolServiceMetadata', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_service_metadata() -> bool', 'has_capabilities() -> bool'], signature_hash='b1aee76ad9021d1c', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=635, is_runtime_checkable=True, domain='types', properties=[\"data: dict[str, 'ContextValue']\", \"version: 'ProtocolSemVer'\", 'capabilities: list[str]', 'tags: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for service metadata.')",
        "ProtocolInfo(name='ProtocolServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_service_instance() -> bool', 'is_available() -> bool'], signature_hash='73baf0b1e58c6c4a', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=653, is_runtime_checkable=True, domain='types', properties=['service_id: str', 'service_name: str', 'host: str', 'port: int', \"metadata: 'ProtocolServiceMetadata'\", \"health_status: 'LiteralHealthStatus'\", \"last_seen: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service instance information.')",
        "ProtocolInfo(name='ProtocolServiceHealthStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_status() -> bool', 'is_healthy() -> bool'], signature_hash='42b56f0e9021ed60', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=674, is_runtime_checkable=True, domain='types', properties=['service_id: str', \"status: 'LiteralHealthStatus'\", \"last_check: 'ProtocolDateTime'\", \"details: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service health status.')",
        "ProtocolInfo(name='ProtocolCheckpointData', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_checkpoint() -> bool', 'is_restorable() -> bool'], signature_hash='7223da7f1490789d', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=692, is_runtime_checkable=True, domain='types', properties=['checkpoint_id: str', 'workflow_id: str', \"data: dict[str, 'ContextValue']\", \"timestamp: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for checkpoint data.')",
        "ProtocolInfo(name='ProtocolStorageCredentials', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_credentials() -> bool', 'is_secure() -> bool'], signature_hash='51b10e3d705e58a8', line_count=4, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=711, is_runtime_checkable=True, domain='types', properties=['credential_type: str', \"data: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for storage credentials.')",
        "ProtocolInfo(name='ProtocolStorageConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_configuration() -> bool', 'is_connectable() -> bool'], signature_hash='7d97bead057300b5', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=727, is_runtime_checkable=True, domain='types', properties=['backend_type: str', 'connection_string: str', \"options: dict[str, 'ContextValue']\", 'timeout_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage configuration.')",
        "ProtocolInfo(name='ProtocolStorageResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_storage_result() -> bool', 'is_successful() -> bool'], signature_hash='6c3fdcd9705c8c1e', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=745, is_runtime_checkable=True, domain='types', properties=['success: bool', \"data: dict[str, 'ContextValue'] | None\", 'error_message: str | None', 'operation_id: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage operation results.')",
        "ProtocolInfo(name='ProtocolStorageListResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_list_result() -> bool', 'has_items() -> bool'], signature_hash='44dc4baf79fa61e8', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=763, is_runtime_checkable=True, domain='types', properties=['success: bool', \"items: list[dict[str, 'ContextValue']]\", 'total_count: int', 'has_more: bool', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for storage list operation results.')",
        "ProtocolInfo(name='ProtocolStorageHealthStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_status() -> bool', 'is_available() -> bool'], signature_hash='0f17075a95e52338', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=782, is_runtime_checkable=True, domain='types', properties=['is_healthy: bool', \"status_details: dict[str, 'ContextValue']\", 'capacity_info: dict[str, int] | None', \"last_check: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for storage health status.')",
        "ProtocolInfo(name='ProtocolErrorContext', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error_context() -> bool', 'has_trace() -> bool'], signature_hash='fc1a9aeb45cd278f', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=806, is_runtime_checkable=True, domain='types', properties=['correlation_id: UUID', 'operation_name: str', \"timestamp: 'ProtocolDateTime'\", \"context_data: dict[str, 'ContextValue']\", 'stack_trace: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for error context information.')",
        "ProtocolInfo(name='ProtocolRecoveryAction', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_recovery_action() -> bool', 'is_applicable() -> bool'], signature_hash='b4dd10f32844736f', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=825, is_runtime_checkable=True, domain='types', properties=['action_type: LiteralErrorRecoveryStrategy', 'max_attempts: int', 'backoff_multiplier: float', 'timeout_seconds: int', 'fallback_value: ContextValue | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery action information.')",
        "ProtocolInfo(name='ProtocolErrorResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_error() -> bool', 'is_retryable() -> bool'], signature_hash='f43b00e5185a7d46', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=844, is_runtime_checkable=True, domain='types', properties=['error_id: UUID', 'error_type: str', 'message: str', 'severity: LiteralErrorSeverity', 'retryable: bool', \"recovery_action: 'ProtocolRecoveryAction | None'\", \"context: 'ProtocolErrorContext'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized error results.')",
        "ProtocolInfo(name='ProtocolVersionInfo', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_version_info() -> bool', 'is_compatible() -> bool'], signature_hash='782e1803abae123e', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=865, is_runtime_checkable=True, domain='types', properties=['protocol_name: str', \"version: 'ProtocolSemVer'\", \"compatibility_version: 'ProtocolSemVer'\", \"retirement_date: 'ProtocolDateTime | None'\", 'migration_guide_url: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for version metadata.')",
        "ProtocolInfo(name='ProtocolCompatibilityCheck', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_compatibility() -> bool'], signature_hash='28b79d0845287353', line_count=6, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=884, is_runtime_checkable=True, domain='types', properties=['is_compatible: bool', \"required_version: 'ProtocolSemVer'\", \"current_version: 'ProtocolSemVer'\", 'breaking_changes: list[str]', 'migration_required: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for compatibility checking results.')",
        "ProtocolInfo(name='ProtocolSupportedPropertyValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_for_property() -> bool'], signature_hash='f90b560449c5709f', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=936, is_runtime_checkable=True, domain='types', properties=['__omnibase_property_value_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for values that can be stored as ONEX property values.\\n\\n    This marker protocol defines the minimal interface that property values\\n    must implement to be compatible with the ONEX property system.\\n    Properties are used for node configuration, service parameters,\\n    and dynamic system settings.\\n\\n    Key Features:\\n        - Marker interface for property value compatibility\\n        - Runtime type checking with sentinel attribute\\n        - Safe storage in property management systems\\n        - Compatible with configuration and parameter systems\\n\\n    Usage:\\n        def set_property(key: str, value: \"ProtocolSupportedPropertyValue\"):\\n            if isinstance(value, ProtocolSupportedPropertyValue):\\n                property_store[key] = value\\n            else:\\n                raise TypeError(\"Value not compatible with property system\")\\n\\n    This is a marker interface with a sentinel attribute for runtime checks.\\n    ')",
        "ProtocolInfo(name='ProtocolHealthMetrics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metrics() -> bool', 'is_within_thresholds() -> bool'], signature_hash='65d6c20642b0b242', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=969, is_runtime_checkable=True, domain='types', properties=['response_time_ms: float', 'cpu_usage_percent: float', 'memory_usage_percent: float', 'disk_usage_percent: float', 'connection_count: int', 'error_rate_percent: float', 'throughput_per_second: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for health check metrics.')",
        "ProtocolInfo(name='ProtocolHealthCheck', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_health_check() -> bool', 'is_passing() -> bool'], signature_hash='8b43a942cb928a1d', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=990, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'check_level: LiteralHealthCheckLevel', 'dimensions_checked: list[LiteralHealthDimension]', \"overall_status: 'LiteralHealthStatus'\", \"individual_checks: dict[str, 'LiteralHealthStatus']\", \"metrics: 'ProtocolHealthMetrics'\", 'check_duration_ms: float', \"timestamp: 'ProtocolDateTime'\", 'recommendations: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized health checks.')",
        "ProtocolInfo(name='ProtocolHealthMonitoring', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_monitoring_config() -> bool', 'is_reasonable() -> bool'], signature_hash='61110f258afbd769', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1013, is_runtime_checkable=True, domain='types', properties=['check_interval_seconds: int', 'timeout_seconds: int', 'failure_threshold: int', 'recovery_threshold: int', \"alert_on_status: list['LiteralHealthStatus']\", \"escalation_rules: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for health monitoring configuration.')",
        "ProtocolInfo(name='ProtocolMetricsPoint', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metrics_point() -> bool', 'is_valid_measurement() -> bool'], signature_hash='729bb73a03d389d3', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1033, is_runtime_checkable=True, domain='types', properties=['metric_name: str', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", \"tags: dict[str, 'ContextValue']\", \"dimensions: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual metrics points.')",
        "ProtocolInfo(name='ProtocolTraceSpan', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_trace_span() -> bool', 'is_complete() -> bool'], signature_hash='bc372986e988c520', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1053, is_runtime_checkable=True, domain='types', properties=['span_id: UUID', 'trace_id: UUID', 'parent_span_id: UUID | None', 'operation_name: str', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'status: LiteralOperationStatus', \"tags: dict[str, 'ContextValue']\", \"logs: list[dict[str, 'ContextValue']]\"], base_protocols=[], protocol_type='functional', docstring='Protocol for distributed tracing spans.')",
        "ProtocolInfo(name='ProtocolAuditEvent', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_audit_event() -> bool', 'is_complete() -> bool'], signature_hash='eefbfe460bf98aab', line_count=11, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1076, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: str', 'actor: str', 'resource: str', 'action: str', \"timestamp: 'ProtocolDateTime'\", 'outcome: LiteralOperationStatus', \"metadata: dict[str, 'ContextValue']\", \"sensitivity_level: Literal['public', 'internal', 'confidential', 'restricted']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for audit events.')",
        "ProtocolInfo(name='ProtocolSerializable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['model_dump() -> dict[str, str | int | float | bool | list[str | int | float | bool] | dict[str, str | int | float | bool]]'], signature_hash='2194795f8f448463', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1099, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for objects that can be serialized to dictionary format.\\n\\n    Provides standardized serialization contract for ONEX objects that need\\n    to be persisted, transmitted, or cached. The model_dump method ensures\\n    consistent serialization across all ONEX services.\\n\\n    Key Features:\\n        - Standardized serialization interface\\n        - Type-safe dictionary output\\n        - Compatible with JSON serialization\\n        - Consistent across all ONEX services\\n\\n    Usage:\\n        class MyDataObject(ProtocolSerializable):\\n            def model_dump(self) -> dict[str, Any]:\\n                return {\\n                    \"id\": self.id,\\n                    \"name\": self.name,\\n                    \"active\": self.is_active\\n                }\\n\\n        # Serialize for storage\\n        obj = MyDataObject()\\n        serialized = obj.model_dump()\\n        json.dumps(serialized)  # Safe for JSON\\n    ')",
        "ProtocolInfo(name='ProtocolIdentifiable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['id() -> str'], signature_hash='4ade353d3e18ab35', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1144, is_runtime_checkable=True, domain='types', properties=['__omnibase_identifiable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that have an ID.')",
        "ProtocolInfo(name='ProtocolNameable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['name() -> str'], signature_hash='d09ed77d70c89dfa', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1156, is_runtime_checkable=True, domain='types', properties=['__omnibase_nameable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that have a name.')",
        "ProtocolInfo(name='ProtocolConfigurable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['configure() -> None'], signature_hash='e5ad392e3eda865c', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1168, is_runtime_checkable=True, domain='types', properties=['__omnibase_configurable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that can be configured.')",
        "ProtocolInfo(name='ProtocolExecutable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['async execute() -> object'], signature_hash='ad183ce51a769d3c', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1179, is_runtime_checkable=True, domain='types', properties=['__omnibase_executable_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that can be executed.')",
        "ProtocolInfo(name='ProtocolMetadataProvider', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['get_metadata() -> dict[str, str | int | bool | float]'], signature_hash='09e352a679bc8db7', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1190, is_runtime_checkable=True, domain='types', properties=['__omnibase_metadata_provider_marker__: Literal[True]'], base_protocols=[], protocol_type='functional', docstring='Protocol for objects that provide metadata.')",
        "ProtocolInfo(name='ProtocolRetryConfig', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_config() -> bool', 'is_reasonable() -> bool'], signature_hash='83505052f95cfc1f', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1209, is_runtime_checkable=True, domain='types', properties=['max_attempts: int', 'backoff_strategy: LiteralRetryBackoffStrategy', 'base_delay_ms: int', 'max_delay_ms: int', 'timeout_ms: int', 'jitter_factor: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry configuration.')",
        "ProtocolInfo(name='ProtocolRetryPolicy', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_policy() -> bool', 'is_applicable() -> bool'], signature_hash='ee495f9df144b7bf', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1229, is_runtime_checkable=True, domain='types', properties=[\"default_config: 'ProtocolRetryConfig'\", \"error_specific_configs: dict[str, 'ProtocolRetryConfig']\", 'retry_conditions: list[LiteralRetryCondition]', 'retry_budget_limit: int', 'budget_window_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry policy configuration.')",
        "ProtocolInfo(name='ProtocolRetryAttempt', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_attempt() -> bool', 'is_valid_attempt() -> bool'], signature_hash='373a45903ee26931', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1248, is_runtime_checkable=True, domain='types', properties=['attempt_number: int', \"timestamp: 'ProtocolDateTime'\", 'duration_ms: int', 'error_type: str | None', 'success: bool', 'backoff_applied_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for retry attempt records.')",
        "ProtocolInfo(name='ProtocolRetryResult', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_retry_result() -> bool', 'is_final() -> bool'], signature_hash='df2341715f633f5e', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1268, is_runtime_checkable=True, domain='types', properties=['success: bool', 'final_attempt_number: int', 'total_duration_ms: int', 'result: ContextValue | None', 'final_error: Exception | None', \"attempts: list['ProtocolRetryAttempt']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for retry operation results.')",
        "ProtocolInfo(name='ProtocolTimeBased', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_time_based() -> bool', 'is_valid_timing() -> bool'], signature_hash='da50e80e208aaa84', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1291, is_runtime_checkable=True, domain='types', properties=['type: LiteralTimeBasedType', \"start_time: 'ProtocolDateTime | None'\", \"end_time: 'ProtocolDateTime | None'\", 'duration_ms: int | None', 'is_active: bool', 'has_expired: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for time-based operations and measurements.')",
        "ProtocolInfo(name='ProtocolTimeout', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_timeout() -> bool', 'is_reasonable() -> bool'], signature_hash='4722c52e37708b1b', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1311, is_runtime_checkable=True, domain='types', properties=['timeout_ms: int', \"start_time: 'ProtocolDateTime'\", 'warning_threshold_ms: int | None', 'is_expired: bool', 'time_remaining_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for timeout configuration and tracking.')",
        "ProtocolInfo(name='ProtocolDuration', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_duration() -> bool', 'is_measurable() -> bool'], signature_hash='860389bc949e5ae4', line_count=7, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1330, is_runtime_checkable=True, domain='types', properties=[\"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'duration_ms: int', 'is_completed: bool', 'can_measure: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for duration measurement and tracking.')",
        "ProtocolInfo(name='ProtocolAnalyticsMetric', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_metric() -> bool', 'is_valid_measurement() -> bool'], signature_hash='0f4df50ca3878e9b', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1355, is_runtime_checkable=True, domain='types', properties=['name: str', 'type: LiteralAnalyticsMetricType', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", \"tags: dict[str, 'ContextValue']\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual analytics metrics.')",
        "ProtocolInfo(name='ProtocolAnalyticsProvider', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_provider() -> bool', 'is_available() -> bool'], signature_hash='261c94c68e2d6f26', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1376, is_runtime_checkable=True, domain='types', properties=['provider_id: str', 'provider_type: str', 'data_sources: list[str]', 'supported_metrics: list[str]', 'time_windows: list[LiteralAnalyticsTimeWindow]', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for analytics data providers.')",
        "ProtocolInfo(name='ProtocolAnalyticsSummary', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_summary() -> bool', 'is_complete() -> bool'], signature_hash='a69462ab685daa89', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1396, is_runtime_checkable=True, domain='types', properties=['time_window: LiteralAnalyticsTimeWindow', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime'\", \"metrics: list['ProtocolAnalyticsMetric']\", 'insights: list[str]', 'recommendations: list[str]', 'confidence_score: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for analytics summary reports.')",
        "ProtocolInfo(name='ProtocolPerformanceMetric', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_performance_metric() -> bool', 'is_valid() -> bool'], signature_hash='a46f75708493b11f', line_count=10, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1422, is_runtime_checkable=True, domain='types', properties=['metric_name: str', 'category: LiteralPerformanceCategory', 'value: float', 'unit: str', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'threshold_warning: float | None', 'threshold_critical: float | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for performance metric data points.')",
        "ProtocolInfo(name='ProtocolPerformanceMetrics', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_performance_metrics() -> bool', 'is_healthy() -> bool'], signature_hash='d9eedd7e0fa176f0', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1444, is_runtime_checkable=True, domain='types', properties=['service_name: str', \"collection_timestamp: 'ProtocolDateTime'\", \"metrics: list['ProtocolPerformanceMetric']\", 'overall_health_score: float', 'performance_trends: dict[str, float]', 'recommendations: list[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for performance metrics collection.')",
        "ProtocolInfo(name='ProtocolConnectionConfig', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_connection_config() -> bool', 'is_connectable() -> bool'], signature_hash='6483622eaad6a92f', line_count=9, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1469, is_runtime_checkable=True, domain='types', properties=['host: str', 'port: int', 'timeout_ms: int', 'max_retries: int', 'ssl_enabled: bool', 'connection_pool_size: int', 'keep_alive_interval_ms: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for connection configuration.')",
        "ProtocolInfo(name='ProtocolConnectionStatus', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=['validate_connection_status() -> bool', 'is_connected() -> bool'], signature_hash='6ba7394d00462afc', line_count=8, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1490, is_runtime_checkable=True, domain='types', properties=['state: LiteralConnectionState', \"connected_at: 'ProtocolDateTime | None'\", \"last_activity: 'ProtocolDateTime | None'\", 'error_count: int', 'bytes_sent: int', 'bytes_received: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for connection status tracking.')",
        "ProtocolInfo(name='ProtocolValidatable', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[\"async get_validation_context() -> dict[str, 'ContextValue']\", 'get_validation_id() -> str'], signature_hash='c1b954e7dcd3b2dc', line_count=2, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=1516, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Base protocol for objects that can be validated.\\n\\n    This protocol defines the minimal interface that validation targets\\n    should implement to provide context and metadata for validation\\n    operations. By implementing this protocol, objects become compatible\\n    with the ONEX validation framework while maintaining type safety.\\n\\n    Key Features:\\n        - Validation context extraction for rule applicability\\n        - Object identification for validation reporting\\n        - Type safety for validation operations\\n        - Minimal interface requirements for broad compatibility\\n\\n    Usage:\\n        class ConfigurationData(ProtocolValidatable):\\n            def get_validation_context(self) -> dict[str, \"ContextValue\"]:\\n                return {\"type\": \"config\", \"version\": self.version}\\n\\n            def get_validation_id(self) -> str:\\n                return f\"config_{self.name}\"\\n    ')",
        "ProtocolInfo(name='ProtocolFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=['validate_for_file() -> bool', 'serialize_for_file() -> dict[str, object]', 'get_file_content_type_hint() -> str'], signature_hash='7f2329c2fed359c2', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=22, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for file content values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolFileMetadataOperations', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[\"async validate_metadata(metadata: 'ProtocolFileMetadata') -> bool\", \"async serialize_metadata(metadata: 'ProtocolFileMetadata') -> str\", \"async compare_metadata(meta1: 'ProtocolFileMetadata', meta2: 'ProtocolFileMetadata') -> bool\"], signature_hash='eec733a0b369c2e4', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=204, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for file metadata operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolResultOperations', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[\"format_result(result: 'ProtocolOnexResult') -> str\", \"async merge_results(results: list['ProtocolOnexResult']) -> ProtocolOnexResult\", \"validate_result(result: 'ProtocolOnexResult') -> bool\"], signature_hash='3cefd1ede740f3b8', line_count=3, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=217, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for result operations - method-based for services.')",
        "ProtocolInfo(name='ProtocolContainer', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['register(service_key: str, service_instance: object) -> None', 'get_service(service_key: str) -> object', 'has_service(service_key: str) -> bool', 'dispose() -> None'], signature_hash='f53b72d6a9e7fef6', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=26, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection containers.')",
        "ProtocolInfo(name='ProtocolContainerServiceInstance', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['validate_service_instance() -> bool', 'is_ready_for_use() -> bool'], signature_hash='43bdde0bfbbebbfb', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=59, is_runtime_checkable=True, domain='types', properties=['service_key: str', 'instance_type: type', 'lifecycle: LiteralServiceLifecycle', 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection container service instance objects.')",
        "ProtocolInfo(name='ProtocolRegistryWrapper', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['get_service(service_key: str) -> object', 'get_node_version() -> ProtocolSemVer', 'list_services() -> list[str]'], signature_hash='d9bf89630dc42783', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=77, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for registry wrapper objects.')",
        "ProtocolInfo(name='ProtocolContainerToolInstance', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[\"async process(input_data: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\"], signature_hash='9d79cf2677f705f7', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=107, is_runtime_checkable=True, domain='types', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool instance objects in dependency injection container context.')",
        "ProtocolInfo(name='ProtocolContainerFactory', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=['create_container() -> ProtocolContainer', \"create_registry_wrapper(container: 'ProtocolContainer') -> ProtocolRegistryWrapper\"], signature_hash='3124664c5a8a4eb0', line_count=2, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=123, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for container factory objects.')",
        "ProtocolInfo(name='ProtocolContainerServiceFactory', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[\"create_service(dependency_spec: 'ProtocolDependencySpec') -> ProtocolContainerServiceInstance\", \"validate_dependency(dependency_spec: 'ProtocolDependencySpec') -> bool\"], signature_hash='f1b3666a303a4196', line_count=2, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=138, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for dependency injection container service factory objects.')",
        "ProtocolInfo(name='ProtocolEventData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_for_transport() -> bool', 'serialize_for_event() -> dict[str, object]', 'get_event_type_hint() -> str'], signature_hash='80e8597bc3304a1a', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=23, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for event data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolEvent', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_event() -> bool', 'has_required_fields() -> bool'], signature_hash='4ac8fbcb6e22c7d0', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=67, is_runtime_checkable=True, domain='types', properties=['event_type: str', \"event_data: dict[str, 'ProtocolEventData']\", 'correlation_id: UUID', \"timestamp: 'ProtocolDateTime'\", 'source: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for event objects.')",
        "ProtocolInfo(name='ProtocolEventResult', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_result() -> bool', 'is_successful() -> bool'], signature_hash='b414cd82a3bdd8ab', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=86, is_runtime_checkable=True, domain='types', properties=['success: bool', 'event_id: UUID', 'processing_time: float', 'error_message: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for event processing results.')",
        "ProtocolInfo(name='ProtocolSecurityContext', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_security_context() -> bool', 'is_authenticated() -> bool'], signature_hash='b589855d2da23fef', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=104, is_runtime_checkable=True, domain='types', properties=['user_id: str | None', 'permissions: list[str]', 'auth_status: LiteralAuthStatus', \"token_expires_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for security context objects.')",
        "ProtocolInfo(name='ProtocolEventSubscription', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_subscription() -> bool'], signature_hash='669b50dad05ec621', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=122, is_runtime_checkable=True, domain='types', properties=['event_type: str', 'subscriber_id: str', \"filter_criteria: dict[str, 'ContextValue']\", 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for event subscriptions.')",
        "ProtocolInfo(name='ProtocolOnexEvent', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_onex_event() -> bool', 'is_well_formed() -> bool'], signature_hash='6ed608742f7bba97', line_count=9, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=137, is_runtime_checkable=True, domain='types', properties=['event_id: UUID', 'event_type: str', \"timestamp: 'ProtocolDateTime'\", 'source: str', \"payload: dict[str, 'ProtocolEventData']\", 'correlation_id: UUID', \"metadata: dict[str, 'ProtocolEventData']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for ONEX system events.')",
        "ProtocolInfo(name='ProtocolEventHeaders', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['validate_headers() -> bool', 'has_required_headers() -> bool'], signature_hash='2ca7bb15f053696c', line_count=20, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=171, is_runtime_checkable=True, domain='types', properties=['content_type: str', 'correlation_id: UUID', 'message_id: UUID', \"timestamp: 'ProtocolDateTime'\", 'source: str', 'event_type: str', \"schema_version: 'ProtocolSemVer'\", 'destination: str | None', 'trace_id: str | None', 'span_id: str | None', 'parent_span_id: str | None', 'operation_name: str | None', \"priority: 'LiteralEventPriority | None'\", 'routing_key: str | None', 'partition_key: str | None', 'retry_count: int | None', 'max_retries: int | None', 'ttl_seconds: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX event bus message headers.\\n\\n    Standardized headers for ONEX event bus messages ensuring strict\\n    interoperability across all agents and preventing integration failures.\\n    ')",
        "ProtocolInfo(name='ProtocolEventMessage', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['async ack() -> None'], signature_hash='2b90dec2a599d7b5', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=211, is_runtime_checkable=True, domain='types', properties=['topic: str', 'key: MessageKey', 'value: bytes', \"headers: 'ProtocolEventHeaders'\", 'offset: str | None', 'partition: int | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX event bus message objects.\\n\\n    Defines the contract that all event message implementations must satisfy\\n    for Kafka/RedPanda compatibility following ONEX Messaging Design.\\n    ')",
        "ProtocolInfo(name='ProtocolCompletionData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=['to_event_kwargs() -> dict[str, str | bool | int | list[str]]'], signature_hash='f5258530ffbadf95', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=232, is_runtime_checkable=True, domain='types', properties=['message: str | None', 'success: bool | None', 'code: int | None', 'tags: list[str] | None'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for completion event data following ONEX naming conventions.\\n\\n    Defines structure for completion event payloads with optional fields\\n    so producers can send only relevant data.\\n    ')",
        "ProtocolInfo(name='ProtocolCapabilityValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=['validate_for_capability() -> bool', 'serialize_for_capability() -> dict[str, object]', 'get_capability_type_hint() -> str'], signature_hash='a077087a2f380033', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=23, is_runtime_checkable=True, domain='types', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for capability data values supporting validation and serialization.')",
        "ProtocolInfo(name='ProtocolMCPToolParameter', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_parameter() -> bool', 'is_required_parameter() -> bool'], signature_hash='afe6844a9d8627e8', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=35, is_runtime_checkable=True, domain='types', properties=['name: str', 'parameter_type: LiteralMCPParameterType', 'description: str', 'required: bool', 'default_value: ContextValue | None', 'schema: dict[str, Any] | None', \"constraints: dict[str, 'ContextValue']\", 'examples: list[ContextValue]'], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool parameter definition.')",
        "ProtocolInfo(name='ProtocolMCPToolDefinition', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_tool_definition() -> bool', 'is_complete() -> bool'], signature_hash='cf455d00c4634ecf', line_count=14, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=57, is_runtime_checkable=True, domain='types', properties=['name: str', 'tool_type: LiteralMCPToolType', 'description: str', \"version: 'ProtocolSemVer'\", \"parameters: list['ProtocolMCPToolParameter']\", 'return_schema: dict[str, Any] | None', 'execution_endpoint: str', 'timeout_seconds: int', 'retry_count: int', 'requires_auth: bool', 'tags: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool definition.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemMetadata', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_metadata() -> bool', 'has_required_fields() -> bool'], signature_hash='0814cae989ff0c68', line_count=16, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=83, is_runtime_checkable=True, domain='types', properties=['subsystem_id: str', 'name: str', 'subsystem_type: LiteralMCPSubsystemType', \"version: 'ProtocolSemVer'\", 'description: str', 'base_url: str', 'health_endpoint: str', 'documentation_url: str | None', 'repository_url: str | None', 'maintainer: str | None', 'tags: list[str]', 'capabilities: list[str]', 'dependencies: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem metadata.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemRegistration', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_registration() -> bool', 'is_active() -> bool'], signature_hash='df3249a25e7496d6', line_count=18, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=111, is_runtime_checkable=True, domain='types', properties=['registration_id: str', \"subsystem_metadata: 'ProtocolMCPSubsystemMetadata'\", \"tools: list['ProtocolMCPToolDefinition']\", 'api_key: str', 'registration_status: LiteralOperationStatus', 'lifecycle_state: LiteralMCPLifecycleState', 'connection_status: LiteralMCPConnectionStatus', \"health_status: 'LiteralHealthStatus'\", \"registered_at: 'ProtocolDateTime'\", \"last_heartbeat: 'ProtocolDateTime | None'\", 'heartbeat_interval_seconds: int', 'ttl_seconds: int', 'access_count: int', 'error_count: int', 'last_error: str | None', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem registration information.')",
        "ProtocolInfo(name='ProtocolMCPToolExecution', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_execution() -> bool', 'is_completed() -> bool'], signature_hash='a0b268b4eed20527', line_count=15, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=141, is_runtime_checkable=True, domain='types', properties=['execution_id: str', 'tool_name: str', 'subsystem_id: str', \"parameters: dict[str, 'ContextValue']\", 'execution_status: LiteralMCPExecutionStatus', \"started_at: 'ProtocolDateTime'\", \"completed_at: 'ProtocolDateTime | None'\", 'duration_ms: int | None', 'result: dict[str, Any] | None', 'error_message: str | None', 'retry_count: int', 'correlation_id: UUID', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP tool execution tracking.')",
        "ProtocolInfo(name='ProtocolMCPRegistryMetrics', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_metrics() -> bool', 'is_healthy() -> bool'], signature_hash='4ff5226298b7b8b9', line_count=18, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=168, is_runtime_checkable=True, domain='types', properties=['total_subsystems: int', 'active_subsystems: int', 'failed_subsystems: int', 'total_tools: int', 'active_tools: int', 'total_executions: int', 'successful_executions: int', 'failed_executions: int', 'average_execution_time_ms: float', 'peak_concurrent_executions: int', 'registry_uptime_seconds: int', \"last_cleanup_at: 'ProtocolDateTime | None'\", 'subsystem_type_distribution: dict[LiteralMCPSubsystemType, int]', 'tool_type_distribution: dict[LiteralMCPToolType, int]', 'health_status_distribution: dict[LiteralHealthStatus, int]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP registry metrics and statistics.')",
        "ProtocolInfo(name='ProtocolMCPRegistryStatus', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_status() -> bool', 'is_operational() -> bool'], signature_hash='7f1f877ff09b8bde', line_count=13, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=198, is_runtime_checkable=True, domain='types', properties=['registry_id: str', 'status: LiteralOperationStatus', 'message: str', \"version: 'ProtocolSemVer'\", \"started_at: 'ProtocolDateTime'\", \"last_updated: 'ProtocolDateTime'\", \"metrics: 'ProtocolMCPRegistryMetrics'\", 'active_connections: int', \"configuration: dict[str, 'ContextValue']\", 'features_enabled: list[str]', 'maintenance_mode: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for overall MCP registry status.')",
        "ProtocolInfo(name='ProtocolMCPRegistryConfig', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_config() -> bool', 'is_valid_configuration() -> bool'], signature_hash='0df4d8d83e718181', line_count=17, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=223, is_runtime_checkable=True, domain='types', properties=['registry_name: str', 'max_subsystems: int', 'max_tools_per_subsystem: int', 'default_heartbeat_interval: int', 'default_ttl_seconds: int', 'cleanup_interval_seconds: int', 'max_concurrent_executions: int', 'tool_execution_timeout: int', 'health_check_timeout: int', 'require_api_key: bool', 'enable_metrics: bool', 'enable_tracing: bool', 'log_level: str', 'maintenance_mode: bool', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP registry configuration.')",
        "ProtocolInfo(name='ProtocolMCPHealthCheck', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_health_check() -> bool', 'is_passing() -> bool'], signature_hash='b2bea3b70834c4b6', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=252, is_runtime_checkable=True, domain='types', properties=['subsystem_id: str', \"check_time: 'ProtocolDateTime'\", \"health_status: 'LiteralHealthStatus'\", 'response_time_ms: int', 'status_code: int | None', 'status_message: str', 'checks: dict[str, bool]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP subsystem health check result.')",
        "ProtocolInfo(name='ProtocolMCPDiscoveryInfo', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_discovery_info() -> bool', 'is_available() -> bool'], signature_hash='3685610f0465bd06', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=274, is_runtime_checkable=True, domain='types', properties=['service_name: str', 'service_url: str', 'service_type: LiteralMCPSubsystemType', 'available_tools: list[str]', \"health_status: 'LiteralHealthStatus'\", \"last_seen: 'ProtocolDateTime'\", \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP service discovery information.')",
        "ProtocolInfo(name='ProtocolMCPValidationError', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_error() -> bool', 'is_critical() -> bool'], signature_hash='dabe39b02ff7c59e', line_count=8, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=295, is_runtime_checkable=True, domain='types', properties=['error_type: str', 'field_name: str', 'error_message: str', 'invalid_value: ContextValue | None', 'suggested_fix: str | None', 'severity: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP validation errors.')",
        "ProtocolInfo(name='ProtocolMCPValidationResult', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=['validate_validation_result() -> bool', 'has_errors() -> bool'], signature_hash='9144ee698272fdaa', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=315, is_runtime_checkable=True, domain='types', properties=['is_valid: bool', \"errors: list['ProtocolMCPValidationError']\", \"warnings: list['ProtocolMCPValidationError']\", \"validation_time: 'ProtocolDateTime'\", \"validation_version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for MCP validation results.')",
        "ProtocolInfo(name='ProtocolToolClass', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=[\"__call__() -> 'ProtocolToolInstance'\"], signature_hash='a35747994ffec9a9', line_count=3, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=334, is_runtime_checkable=True, domain='types', properties=['__name__: str', '__module__: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool class objects in MCP systems.')",
        "ProtocolInfo(name='ProtocolToolInstance', file_path='src/omnibase_spi/protocols/types/protocol_mcp_types.py', module_path='omnibase_spi.protocols.types.protocol_mcp_types', methods=[\"async execute(parameters: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\", \"async validate_parameters(parameters: dict[str, 'ContextValue']) -> ProtocolMCPValidationResult\", \"health_check() -> dict[str, 'ContextValue']\"], signature_hash='7602719b3f2b89ce', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=346, is_runtime_checkable=True, domain='types', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", 'tool_type: LiteralMCPToolType', 'is_initialized: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for tool instance objects in MCP systems.')",
        "ProtocolInfo(name='ProtocolHttpRequestBuilder', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=[\"url(url: str) -> 'ProtocolHttpRequestBuilder'\", \"async with_query_params(params: dict[str, 'ContextValue']) -> 'ProtocolHttpRequestBuilder'\", \"with_form_data(data: dict[str, 'ContextValue']) -> 'ProtocolHttpRequestBuilder'\", \"async with_file_upload(files: dict[str, bytes]) -> 'ProtocolHttpRequestBuilder'\", \"with_json(data: dict[str, str | int | float | bool]) -> 'ProtocolHttpRequestBuilder'\", \"with_bearer_token(token: str) -> 'ProtocolHttpRequestBuilder'\", \"with_basic_auth(username: str, password: str) -> 'ProtocolHttpRequestBuilder'\", \"with_header(name: str, value: str) -> 'ProtocolHttpRequestBuilder'\", \"with_timeout(timeout_seconds: int) -> 'ProtocolHttpRequestBuilder'\", \"async get() -> 'ProtocolHttpResponse'\", \"async post() -> 'ProtocolHttpResponse'\", \"async put() -> 'ProtocolHttpResponse'\", \"async delete() -> 'ProtocolHttpResponse'\"], signature_hash='927b916221876cef', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=15, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for building complex HTTP requests with fluent interface.\\n\\n    Supports query parameters, form data, file uploads, authentication,\\n    and other advanced HTTP features through method chaining.\\n\\n    Example:\\n        ```python\\n        builder: \"ProtocolHttpRequestBuilder\" = get_request_builder()\\n        response = await builder.url(\"https://api.example.com/upload\")             .with_query_params({\"version\": \"2.0\", \"format\": \"json\"})             .with_bearer_token(\"token123\")             .with_file_upload({\"document\": file_bytes})             .post()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpStreamingResponse', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=['async stream_content(chunk_size: int) -> bytes', 'async stream_json_lines() -> dict[str, str | int | float | bool]', 'async stream_text_lines(encoding: str) -> str', 'async get_full_content() -> bytes'], signature_hash='9d4549d3a6e7ce49', line_count=7, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=199, is_runtime_checkable=True, domain='core', properties=['status_code: int', \"headers: dict[str, 'ContextValue']\", 'url: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for handling streaming HTTP responses.\\n\\n    Supports streaming content, JSON lines, and chunked responses\\n    for efficient processing of large data sets.\\n\\n    Example:\\n        ```python\\n        response: \"ProtocolHttpStreamingResponse\" = await client.stream_get(url)\\n\\n        # Stream raw content\\n        async for chunk in response.stream_content():\\n            process_chunk(chunk)\\n\\n        # Stream JSON lines\\n        async for json_obj in response.stream_json_lines():\\n            process_json_object(json_obj)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpExtendedClient', file_path='src/omnibase_spi/protocols/core/protocol_http_extended.py', module_path='omnibase_spi.protocols.core.protocol_http_extended', methods=['async create_request_builder() -> ProtocolHttpRequestBuilder', \"async stream_request(method: str, url: str, headers: dict[str, 'ContextValue'] | None) -> ProtocolHttpStreamingResponse\", 'async health_check() -> bool', 'async close() -> None'], signature_hash='21632795b22e5df5', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_http_client.ProtocolHttpResponse', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=282, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for extended HTTP client with advanced features.\\n\\n    Provides request builders, streaming responses, connection pooling,\\n    and advanced configuration options for production HTTP clients.\\n\\n    Example:\\n        ```python\\n        client: \"ProtocolHttpExtendedClient\" = get_extended_http_client()\\n\\n        # Use request builder\\n        builder = client.create_request_builder()\\n        response = await builder.url(\"https://api.example.com\")             .with_bearer_token(\"token\")             .get()\\n\\n        # Stream large responses\\n        stream_response = await client.stream_request(\"GET\", \"https://api.example.com/large-data\")\\n        async for chunk in stream_response.stream_content():\\n            process(chunk)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolAnalyticsDataProvider', file_path='src/omnibase_spi/protocols/core/protocol_analytics_provider.py', module_path='omnibase_spi.protocols.core.protocol_analytics_provider', methods=[\"async configure_analytics_provider(provider_config: 'ProtocolAnalyticsProvider') -> bool\", \"async get_analytics_provider_info() -> 'ProtocolAnalyticsProvider'\", \"async collect_metric(metric: 'ProtocolAnalyticsMetric') -> bool\", \"async collect_metrics_batch(metrics: list['ProtocolAnalyticsMetric']) -> int\", \"async query_metrics(metric_names: list[str], time_window: 'LiteralAnalyticsTimeWindow', start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime') -> list['ProtocolAnalyticsMetric']\", \"async generate_analytics_summary(time_window: 'LiteralAnalyticsTimeWindow', data_sources: list[str] | None, metric_types: list['LiteralAnalyticsMetricType'] | None) -> 'ProtocolAnalyticsSummary'\", 'get_supported_metrics() -> list[str]', \"get_supported_time_windows() -> list['LiteralAnalyticsTimeWindow']\", 'async add_data_source(source_name: str, source_config: dict[str, str | int | bool]) -> bool', 'async remove_data_source(source_name: str) -> bool', \"async get_analytics_health() -> dict[str, 'ContextValue']\", \"async create_custom_metric(metric_name: str, metric_type: 'LiteralAnalyticsMetricType', unit: str, description: str) -> bool\", 'async delete_custom_metric(metric_name: str) -> bool', 'set_metric_threshold(metric_name: str, warning_threshold: float, critical_threshold: float) -> bool', 'get_metric_thresholds(metric_name: str) -> dict[str, float] | None', \"generate_insights(summary: 'ProtocolAnalyticsSummary') -> list[str]\", \"generate_recommendations(summary: 'ProtocolAnalyticsSummary') -> list[str]\", \"async export_analytics_data(format_type: str, time_range: tuple['ProtocolDateTime', 'ProtocolDateTime'], metric_filter: list[str] | None) -> bytes | str\"], signature_hash='5f681bcacc13fc6b', line_count=18, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralAnalyticsMetricType', 'omnibase_spi.protocols.types.protocol_core_types.LiteralAnalyticsTimeWindow', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsMetric', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsProvider', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAnalyticsSummary', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime'], line_number=23, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for analytics data providers and collection systems.\\n\\n    Provides consistent analytics patterns, metric collection, aggregation,\\n    and reporting for comprehensive system monitoring and business intelligence.\\n\\n    Key Features:\\n        - Multi-source data collection and aggregation\\n        - Time-windowed analytics with multiple granularities\\n        - Metric type classification (counter, gauge, histogram, summary)\\n        - Real-time and batch analytics processing\\n        - Insight generation and recommendation systems\\n        - Analytics pipeline management and data quality\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class AnalyticsProviderImpl:\\n            def collect_metrics(self, data_sources, time_window):\\n                metrics = []\\n                for source in data_sources:\\n                    raw_data = self._fetch_data(source, time_window)\\n                    processed_metrics = self._process_metrics(raw_data)\\n                    metrics.extend(processed_metrics)\\n\\n                return self._aggregate_metrics(metrics, time_window)\\n\\n            def generate_insights(self, summary):\\n                insights = []\\n                for metric in summary.metrics:\\n                    if metric.value > self._get_threshold(metric.name):\\n                        insights.append(f\"High {metric.name} detected\")\\n\\n                return insights\\n\\n        # Usage in application code\\n        analytics: \"ProtocolAnalyticsDataProvider\" = AnalyticsProviderImpl()\\n\\n        # Configure analytics collection\\n        provider_config = analytics.configure_analytics_provider(\\n            provider_id=\"service_metrics\",\\n            data_sources=[\"database\", \"api\", \"cache\"],\\n            supported_metrics=[\"response_time\", \"error_rate\", \"throughput\"]\\n        )\\n\\n        # Collect and analyze metrics\\n        summary = analytics.generate_analytics_summary(\\n            time_window=\"hourly\",\\n            data_sources=[\"database\", \"api\"]\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolMetricsCollector', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"record_counter(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_gauge(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_histogram(name: str, value: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_timer(name: str, duration_seconds: float, tags: dict[str, 'ContextValue'] | None) -> None\", \"record_metrics_batch(metrics: list['ProtocolMetricsPoint']) -> None\", \"async create_metrics_context(default_tags: dict[str, 'ContextValue']) -> 'ProtocolMetricsCollector'\"], signature_hash='36ae202f85df3dea', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=24, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for metrics collection and reporting.\\n\\n    Provides standardized metrics collection interface for monitoring\\n    service performance, health, and business metrics.\\n\\n    Key Features:\\n        - Counter, gauge, histogram, and timer metrics\\n        - Multi-dimensional metrics with tags\\n        - Batch metrics submission for performance\\n        - Custom metric types and aggregation\\n        - Integration with monitoring systems\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class MetricsCollectorImpl:\\n            def record_counter(self, name, value, tags):\\n                point = MetricsPoint(\\n                    metric_name=name,\\n                    value=value,\\n                    tags=tags,\\n                    timestamp=datetime.utcnow()\\n                )\\n                self._send_to_backend(point)\\n\\n        # Usage in application code\\n        metrics: \"ProtocolMetricsCollector\" = MetricsCollectorImpl()\\n\\n        metrics.record_counter(\\n            name=\"requests_total\",\\n            value=1,\\n            tags={\"endpoint\": \"/api/users\", \"status\": \"200\"}\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolDistributedTracing', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"async start_span(operation_name: str, parent_span_id: 'UUID | None', trace_id: 'UUID | None') -> 'ProtocolTraceSpan'\", \"finish_span(span_id: 'UUID', status: 'LiteralOperationStatus') -> None\", \"add_span_tag(span_id: 'UUID', key: str, value: str) -> None\", \"add_span_log(span_id: 'UUID', message: str, fields: dict[str, object] | None) -> None\", \"extract_trace_context(headers: dict[str, 'ContextValue']) -> tuple['UUID', 'UUID']\", \"inject_trace_context(trace_id: 'UUID', span_id: 'UUID', headers: dict[str, 'ContextValue']) -> None\", \"get_current_span() -> 'ProtocolTraceSpan | None'\"], signature_hash='8f82cb690ddd02bf', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=163, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for distributed tracing across services.\\n\\n    Provides standardized distributed tracing interface for request\\n    flow visibility and performance analysis in microservices.\\n\\n    Key Features:\\n        - Span creation and lifecycle management\\n        - Parent-child span relationships\\n        - Cross-service trace propagation\\n        - Custom span tags and logs\\n        - Integration with tracing systems\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class TracingImpl:\\n            async def start_span(self, operation_name, parent_span_id=None):\\n                span = TraceSpan(\\n                    span_id=uuid.uuid4(),\\n                    operation_name=operation_name,\\n                    parent_span_id=parent_span_id,\\n                    start_time=datetime.utcnow()\\n                )\\n                return span\\n\\n        # Usage in application code\\n        tracing: \"ProtocolDistributedTracing\" = TracingImpl()\\n\\n        span = tracing.start_span(\\n            operation_name=\"process_user_request\",\\n            parent_span_id=request.trace_context.span_id\\n        )\\n\\n        try:\\n            result = process_request()\\n            tracing.finish_span(span.span_id, \"success\")\\n        except Exception as e:\\n            tracing.add_span_tag(span.span_id, \"error\", str(e))\\n            tracing.finish_span(span.span_id, \"failed\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolAuditLogger', file_path='src/omnibase_spi/protocols/core/protocol_observability.py', module_path='omnibase_spi.protocols.core.protocol_observability', methods=[\"log_audit_event(event_type: str, actor: str, resource: str, action: str, outcome: 'LiteralOperationStatus', metadata: dict[str, object] | None, sensitivity_level: str) -> 'ProtocolAuditEvent'\", \"async query_audit_events(start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime', filters: dict[str, 'ContextValue'] | None) -> list['ProtocolAuditEvent']\", 'get_audit_statistics(time_window_hours: int) -> dict[str, object]', \"archive_audit_events(before_date: 'ProtocolDateTime', archive_location: str) -> int\"], signature_hash='e1e1edef990a15fd', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAuditEvent', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetricsPoint', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTraceSpan'], line_number=329, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for audit event logging.\\n\\n    Provides standardized audit logging interface for security,\\n    compliance, and operational event tracking.\\n\\n    Key Features:\\n        - Structured audit event recording\\n        - Sensitivity level classification\\n        - Actor and resource tracking\\n        - Outcome and metadata capture\\n        - Compliance and security integration\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class AuditLoggerImpl:\\n            def log_audit_event(self, event):\\n                if event.sensitivity_level in [\"confidential\", \"restricted\"]:\\n                    self._encrypt_before_storage(event)\\n                self._store_audit_event(event)\\n\\n        # Usage in application code\\n        audit_logger: \"ProtocolAuditLogger\" = AuditLoggerImpl()\\n\\n        audit_logger.log_audit_event(\\n            event_type=\"user_access\",\\n            actor=\"user123\",\\n            resource=\"/api/sensitive-data\",\\n            action=\"read\",\\n            outcome=\"success\",\\n            metadata={\"ip_address\": \"192.168.1.1\"},\\n            sensitivity_level=\"confidential\"\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClient', file_path='src/omnibase_spi/protocols/core/protocol_kafka_client.py', module_path='omnibase_spi.protocols.core.protocol_kafka_client', methods=['async start() -> None', 'async stop() -> None', 'async send_and_wait(topic: str, value: bytes, key: bytes | None) -> None', 'bootstrap_servers() -> list[str]'], signature_hash='bae797905510773b', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=12, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Kafka client implementations.\\n\\n    Provides standardized interface for Kafka producer/consumer operations\\n    that can be implemented by different Kafka client libraries.\\n\\n    Example:\\n        ```python\\n        # Basic usage\\n        kafka_client: \"ProtocolKafkaClient\" = get_kafka_client()\\n        await kafka_client.start()\\n\\n        # Send messages\\n        message_data = b\\'{\"event\": \"user_created\", \"user_id\": 123}\\'\\n        await kafka_client.send_and_wait(\"user-events\", message_data, key=b\"user:123\")\\n\\n        # Get configuration\\n        servers = kafka_client.bootstrap_servers()\\n        print(f\"Connected to: {servers}\")\\n\\n        # Cleanup\\n        await kafka_client.stop()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClientProvider', file_path='src/omnibase_spi/protocols/core/protocol_kafka_client.py', module_path='omnibase_spi.protocols.core.protocol_kafka_client', methods=['async create_kafka_client() -> ProtocolKafkaClient', 'async get_kafka_configuration() -> dict[str, str | int | float | bool]'], signature_hash='1db909234119f467', line_count=2, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=95, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for Kafka client provider.')",
        "ProtocolInfo(name='ProtocolUtilsNodeConfiguration', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration_utils.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration_utils', methods=['get_configuration() -> ProtocolNodeConfiguration', 'get_timeout_ms(timeout_type: str, default_ms: int | None) -> int', 'get_security_config(key: str, default: ContextValue | None) -> ContextValue', 'get_performance_config(key: str, default: ContextValue | None) -> ContextValue', 'get_business_logic_config(key: str, default: ContextValue | None) -> ContextValue', 'async validate_correlation_id(correlation_id: str) -> bool'], signature_hash='6685bf56ab0aff23', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_node_configuration.ProtocolNodeConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node configuration utility operations.\\n\\n    Provides standardized configuration access patterns that nodes\\n    can use without coupling to specific utility implementations.\\n    ')",
        "ProtocolInfo(name='ProtocolOnexEnvelope', file_path='src/omnibase_spi/protocols/core/protocol_onex_envelope.py', module_path='omnibase_spi.protocols.core.protocol_onex_envelope', methods=[\"async create_envelope(payload: 'Any', correlation_id: UUID | None, security_context: 'ProtocolOnexSecurityContext | None', metadata: 'ProtocolOnexMetadata | None') -> 'Any'\", \"async extract_payload(envelope: 'Any') -> 'Any'\", \"get_correlation_id(envelope: 'Any') -> UUID | None\", \"get_security_context(envelope: 'Any') -> 'ProtocolOnexSecurityContext | None'\", \"get_metadata(envelope: 'Any') -> 'ProtocolOnexMetadata | None'\", \"async validate_envelope(envelope: 'Any') -> bool\", \"get_timestamp(envelope: 'Any') -> datetime\", \"get_source_tool(envelope: 'Any') -> str | None\", \"get_target_tool(envelope: 'Any') -> str | None\", \"with_metadata(envelope: 'Any', metadata: 'ProtocolOnexMetadata') -> 'Any'\", \"is_onex_compliant(envelope: 'Any') -> bool\"], signature_hash='1bc06b9eaa0c2231', line_count=11, imports=['datetime.datetime', 'typing.TYPE_CHECKING', 'typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexMetadata', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexSecurityContext'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex envelope pattern.\\n\\n    All ONEX tools must implement this protocol for request envelope handling.\\n    Provides standardized request wrapping with metadata and security context.\\n    ')",
        "ProtocolInfo(name='ProtocolHealthDetails', file_path='src/omnibase_spi/protocols/core/protocol_health_details.py', module_path='omnibase_spi.protocols.core.protocol_health_details', methods=[\"get_health_status() -> 'LiteralHealthStatus'\", 'is_healthy() -> bool', 'get_health_summary() -> str'], signature_hash='f15bbd4281cd96f9', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service-specific health details with self-assessment capability.\\n\\n    This protocol defines the interface for health detail models that can:\\n    - Assess their own health status based on service-specific metrics\\n    - Provide boolean health indicators\\n    - Generate human-readable health summaries\\n\\n    Designed to work with the existing ProtocolHealthCheck and ProtocolHealthMonitor\\n    protocols, allowing service-specific models to contribute to overall health assessment.\\n\\n    Key Features:\\n        - Service-specific health logic encapsulation\\n        - Consistent interface across all health detail models\\n        - Self-contained health assessment capability\\n        - Human-readable status reporting\\n        - Integration with existing health monitoring infrastructure\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ModelPostgresHealthDetails(BaseModel):\\n            postgres_connection_count: int | None\\n            postgres_last_error: str | None\\n            max_connections: int | None\\n\\n            def get_health_status(self) -> \"LiteralHealthStatus\":\\n                if self.postgres_last_error:\\n                    return \"unhealthy\"\\n                if self.postgres_connection_count and self.max_connections:\\n                    if self.postgres_connection_count > (self.max_connections * 0.9):\\n                        return \"warning\"\\n                return \"healthy\"\\n\\n            def is_healthy(self) -> bool:\\n                return self.get_health_status() == \"healthy\"\\n\\n            def get_health_summary(self) -> str:\\n                status = self.get_health_status()\\n                if status == \"unhealthy\":\\n                    return f\"PostgreSQL Error: {self.postgres_last_error}\"\\n                return \"PostgreSQL connections healthy\"\\n        ```\\n\\n    Integration with Health Monitoring:\\n        ```python\\n        async def create_health_check(details: \"ProtocolHealthDetails\") -> ProtocolHealthCheck:\\n            return HealthCheckImpl(\\n                service_name=details.__class__.__name__,\\n                overall_status=details.get_health_status(),\\n                individual_checks={\"service\": details.get_health_status()},\\n                summary=details.get_health_summary()\\n            )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolOnexReply', file_path='src/omnibase_spi/protocols/core/protocol_onex_reply.py', module_path='omnibase_spi.protocols.core.protocol_onex_reply', methods=[\"async create_success_reply(data: Any, correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", \"async create_error_reply(error_message: str, error_code: str | None, error_details: str | None, correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", \"async create_validation_error_reply(validation_errors: list[str], correlation_id: UUID | None, metadata: 'ProtocolOnexMetadata | None') -> Any\", 'extract_data(reply: Any) -> Any | None', \"get_status(reply: Any) -> 'LiteralOnexReplyStatus'\", 'get_error_message(reply: Any) -> str | None', 'get_error_code(reply: Any) -> str | None', 'get_error_details(reply: Any) -> str | None', 'get_correlation_id(reply: Any) -> UUID | None', 'get_metadata(reply: Any) -> ProtocolOnexMetadata | None', 'is_success(reply: Any) -> bool', 'is_error(reply: Any) -> bool', 'get_timestamp(reply: Any) -> ProtocolDateTime', 'async get_processing_time(reply: Any) -> float | None', \"with_metadata(reply: Any, metadata: 'ProtocolOnexMetadata') -> Any\", 'is_onex_compliant(reply: Any) -> bool', 'async validate_reply(reply: Any) -> bool'], signature_hash='64b9fd0903fed960', line_count=17, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_onex_validation.ProtocolOnexMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex reply pattern.\\n\\n    All ONEX tools must implement this protocol for response reply handling.\\n    Provides standardized response wrapping with status and error information.\\n    ')",
        "ProtocolInfo(name='ProtocolPerformanceMetricsCollector', file_path='src/omnibase_spi/protocols/core/protocol_performance_metrics.py', module_path='omnibase_spi.protocols.core.protocol_performance_metrics', methods=[\"async collect_performance_metrics(service_name: str) -> 'ProtocolPerformanceMetrics'\", \"async collect_category_metrics(service_name: str, categories: list['LiteralPerformanceCategory']) -> list['ProtocolPerformanceMetric']\", \"async record_performance_metric(metric: 'ProtocolPerformanceMetric') -> bool\", \"async record_performance_metrics_batch(metrics: list['ProtocolPerformanceMetric']) -> int\", 'set_performance_threshold(metric_name: str, warning_threshold: float | None, critical_threshold: float | None) -> bool', 'get_performance_thresholds(metric_name: str) -> dict[str, float | None]', \"async check_performance_thresholds(metrics: 'ProtocolPerformanceMetrics') -> list[dict[str, 'ProtocolContextValue']]\", \"async analyze_performance_trends(service_name: str, hours_back: int, categories: list['LiteralPerformanceCategory'] | None) -> dict[str, dict[str, float]]\", 'async get_performance_baseline(service_name: str, metric_name: str) -> dict[str, float]', 'async establish_performance_baseline(service_name: str, metric_name: str, baseline_period_hours: int) -> bool', \"async compare_to_baseline(current_metrics: 'ProtocolPerformanceMetrics', baseline_deviation_threshold: float) -> dict[str, dict[str, 'ProtocolContextValue']]\", \"get_performance_recommendations(service_name: str, performance_issues: list[dict[str, 'ProtocolContextValue']]) -> list[str]\", \"async export_performance_report(service_name: str, start_time: 'ProtocolDateTime', end_time: 'ProtocolDateTime', categories: list['LiteralPerformanceCategory'] | None) -> dict[str, 'ProtocolContextValue']\", 'async start_real_time_monitoring(service_name: str, collection_interval_seconds: int, alert_callback: Callable[..., Any] | None) -> str', 'async stop_real_time_monitoring(monitoring_session_id: str) -> bool', \"async get_monitoring_sessions() -> list[dict[str, 'ProtocolContextValue']]\", 'async correlate_cross_service_performance(service_names: list[str], correlation_window_minutes: int) -> dict[str, dict[str, float]]', \"async identify_performance_bottlenecks(service_name: str, analysis_period_hours: int) -> list[dict[str, 'ProtocolContextValue']]\", \"async predict_performance_issues(service_name: str, prediction_horizon_hours: int) -> list[dict[str, 'ProtocolContextValue']]\", \"async get_performance_summary(service_names: list[str], summary_period_hours: int) -> dict[str, 'ProtocolContextValue']\"], signature_hash='e0f6ec9343e79215', line_count=20, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralPerformanceCategory', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolPerformanceMetric', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolPerformanceMetrics'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for performance metrics collection and monitoring.\\n\\n    Provides standardized performance measurement interface for tracking\\n    system health, identifying bottlenecks, and enabling proactive\\n    optimization across ONEX distributed services.\\n\\n    Key Features:\\n        - Multi-category performance metrics (latency, throughput, resource, etc.)\\n        - Real-time and historical performance tracking\\n        - Configurable alerting thresholds and notifications\\n        - Performance trend analysis and baseline management\\n        - Cross-service performance correlation\\n        - Automated performance recommendations\\n\\n    Usage Example:\\n\\n        .. code-block:: python\\n\\n            # Implementation example (not part of SPI)\\n            class PerformanceMetricsImpl:\\n                def collect_performance_metrics(self, service_name):\\n                    metrics = []\\n\\n                    # Collect latency metrics\\n                    response_time = self._measure_response_time()\\n                    metrics.append(PerformanceMetric(\\n                        metric_name=\"response_time\",\\n                        category=\"latency\",\\n                        value=response_time,\\n                        unit=\"ms\"\\n                    ))\\n\\n                    # Collect throughput metrics\\n                    rps = self._calculate_requests_per_second()\\n                    metrics.append(PerformanceMetric(\\n                        metric_name=\"requests_per_second\",\\n                        category=\"throughput\",\\n                        value=rps,\\n                        unit=\"req/s\"\\n                    ))\\n\\n                    return PerformanceMetrics(\\n                        service_name=service_name,\\n                        metrics=metrics,\\n                        overall_health_score=self._calculate_health_score(metrics)\\n                    )\\n\\n            # Usage in application code\\n            perf_collector: \"ProtocolPerformanceMetricsCollector\" = PerformanceMetricsImpl()\\n\\n            # Collect current performance metrics\\n            current_metrics = perf_collector.collect_performance_metrics(\\n                service_name=\"user-service\"\\n            )\\n\\n            # Set performance thresholds\\n            perf_collector.set_performance_threshold(\\n                metric_name=\"response_time\",\\n                warning_threshold=500.0,\\n                critical_threshold=1000.0\\n            )\\n\\n            # Analyze performance trends\\n            trends = perf_collector.analyze_performance_trends(\\n                service_name=\"user-service\",\\n                hours_back=24,\\n                categories=[\"latency\", \"throughput\"]\\n            )\\n    ')",
        "ProtocolInfo(name='ProtocolConnectionManageable', file_path='src/omnibase_spi/protocols/core/protocol_connection_manageable.py', module_path='omnibase_spi.protocols.core.protocol_connection_manageable', methods=['async establish_connection() -> bool', 'async close_connection() -> bool', 'async disconnect() -> bool', 'async reconnect_immediate() -> bool', \"async reconnect_with_strategy(retry_config: 'ProtocolRetryConfig') -> bool\", 'async recover_connection() -> bool', 'async perform_health_check() -> bool', \"async perform_deep_health_check() -> dict[str, 'ContextValue']\", \"async get_connection_state() -> 'LiteralConnectionState'\", \"async get_connection_status() -> 'ProtocolConnectionStatus'\", \"async get_connection_metrics() -> dict[str, 'ContextValue']\", \"async update_connection_config(new_config: 'ProtocolConnectionConfig') -> bool\", 'async enable_auto_reconnect() -> bool', 'async disable_auto_reconnect() -> bool', 'async is_connected() -> bool', 'async is_connecting() -> bool', 'can_recover() -> bool', 'get_last_error() -> str | None', 'async get_connection_uptime() -> int', 'get_idle_time() -> int', 'reset_error_count() -> bool', 'async set_connection_timeout(timeout_ms: int) -> bool', \"async get_connection_pool_stats() -> dict[str, 'ContextValue'] | None\", \"async validate_connection_config(config: 'ProtocolConnectionConfig') -> bool\", \"async test_connection_config(config: 'ProtocolConnectionConfig') -> dict[str, 'ContextValue']\", 'get_supported_features() -> list[str]', 'is_feature_available(feature_name: str) -> bool'], signature_hash='756d4309409bed83', line_count=32, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralConnectionState', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolConnectionConfig', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolConnectionStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryConfig'], line_number=22, is_runtime_checkable=True, domain='core', properties=['connection_id: str', \"config: 'ProtocolConnectionConfig'\", \"status: 'ProtocolConnectionStatus'\", 'can_reconnect: bool', 'auto_reconnect_enabled: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive connection management across ONEX services.\\n\\n    Provides consistent connection lifecycle management, health monitoring,\\n    reconnection strategies, and resilient connection handling for distributed\\n    system reliability and fault tolerance.\\n\\n    Key Features:\\n        - Connection lifecycle management (connect, disconnect, close)\\n        - Real-time connection status monitoring and health checks\\n        - Automatic reconnection with configurable retry strategies\\n        - Connection pool management and resource optimization\\n        - Graceful degradation and circuit breaker patterns\\n        - Connection metrics collection and performance monitoring\\n        - Event-driven connection state notifications\\n        - SSL/TLS security configuration and validation\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class DatabaseConnectionManager:\\n            @property\\n            async def connection_id(self) -> str:\\n                return self._connection_id\\n\\n            @property\\n            def config(self) -> \"ProtocolConnectionConfig\":\\n                return self._config\\n\\n            @property\\n            def status(self) -> \"ProtocolConnectionStatus\":\\n                return self._status\\n\\n            @property\\n            async def can_reconnect(self) -> bool:\\n                return self._can_reconnect\\n\\n            @property\\n            async def auto_reconnect_enabled(self) -> bool:\\n                return self._auto_reconnect_enabled\\n\\n            async def establish_connection(self) -> bool:\\n                try:\\n                    self._status.state = \"connecting\"\\n                    self._connection = await create_db_connection(self._config)\\n                    self._status.state = \"connected\"\\n                    self._status.connected_at = datetime.utcnow()\\n                    return True\\n                except Exception:\\n                    self._status.state = \"failed\"\\n                    self._status.error_count += 1\\n                    return False\\n\\n            async def perform_health_check(self) -> bool:\\n                if not self._connection:\\n                    return False\\n                try:\\n                    await self._connection.ping()\\n                    return True\\n                except Exception:\\n                    self._status.error_count += 1\\n                    return False\\n\\n        # Usage in application code\\n        connection_mgr: \"ProtocolConnectionManageable\" = DatabaseConnectionManager()\\n\\n        # Establish connection with retry\\n        success = await connection_mgr.establish_connection()\\n        if not success:\\n            await connection_mgr.reconnect_with_strategy(retry_config)\\n\\n        # Monitor connection health\\n        if await connection_mgr.perform_health_check():\\n            # Connection is healthy, proceed with operations\\n            pass\\n        else:\\n            # Connection unhealthy, trigger recovery\\n            await connection_mgr.recover_connection()\\n        ```\\n\\n    Connection States:\\n        - disconnected: No active connection established\\n        - connecting: In process of establishing connection\\n        - connected: Active connection ready for operations\\n        - reconnecting: Attempting to restore lost connection\\n        - failed: Connection failed and requires intervention\\n        - closing: Gracefully shutting down connection\\n\\n    Reconnection Strategies:\\n        - immediate: Attempt reconnection without delay\\n        - exponential_backoff: Exponentially increasing delays between attempts\\n        - linear_backoff: Linear delay increases for predictable retry timing\\n        - circuit_breaker: Temporary connection suspension after failure threshold\\n        - manual: Require explicit reconnection request (no auto-retry)\\n\\n    Health Check Levels:\\n        - ping: Basic connectivity test (fastest)\\n        - shallow: Basic query or lightweight operation\\n        - deep: Comprehensive connection validation and feature check\\n        - diagnostic: Full connection diagnostics with performance metrics\\n    ')",
        "ProtocolInfo(name='ProtocolHttpClient', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=[\"async request(method: str, url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async get(url: str, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async post(url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async put(url: str, json: dict[str, str | int | float | bool] | None, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\", \"async delete(url: str, headers: dict[str, 'ContextValue'] | None, timeout: int | None) -> 'ProtocolHttpResponse'\"], signature_hash='9169b86eeb023c10', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=28, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for HTTP client operations.\\n\\n    Generic HTTP client supporting standard HTTP methods with configurable\\n    timeouts, headers, and request/response handling. Implementations can\\n    use aiohttp, httpx, or other HTTP client backends.\\n\\n    Example:\\n        ```python\\n        # GET request\\n        client: \"ProtocolHttpClient\" = get_http_client()\\n        response = await client.request(\"GET\", \"https://api.example.com/users\")\\n        print(f\"Status: {response.status_code}\")\\n        print(f\"Data: {response.body}\")\\n\\n        # POST with JSON payload\\n        payload = {\"name\": \"John\", \"email\": \"john@example.com\"}\\n        headers = {\"Content-Type\": \"application/json\"}\\n        response = await client.request(\\n            \"POST\",\\n            \"https://api.example.com/users\",\\n            json=payload,\\n            headers=headers,\\n            timeout=30\\n        )\\n\\n        # Webhook delivery\\n        webhook_data = {\"event\": \"user.created\", \"user_id\": 123}\\n        response = await client.request(\\n            \"POST\",\\n            \"https://webhook.example.com/events\",\\n            json=webhook_data,\\n            headers={\"X-Event-Type\": \"user.created\"},\\n            timeout=10\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpClientProvider', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=['async create_http_client() -> ProtocolHttpClient', 'get_http_configuration() -> dict[str, str | int | float | bool]'], signature_hash='6502dea088020590', line_count=2, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=175, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for HTTP client provider.')",
        "ProtocolInfo(name='ProtocolVersionManager', file_path='src/omnibase_spi/protocols/core/protocol_version_manager.py', module_path='omnibase_spi.protocols.core.protocol_version_manager', methods=[\"get_protocol_version_info(protocol_name: str) -> 'ProtocolVersionInfo'\", \"async register_protocol_version(protocol_name: str, version: 'ProtocolSemVer', compatibility_version: 'ProtocolSemVer', migration_guide_url: str | None) -> bool\", \"async check_compatibility(protocol_name: str, required_version: 'ProtocolSemVer', current_version: 'ProtocolSemVer') -> 'ProtocolCompatibilityCheck'\", \"get_breaking_changes(protocol_name: str, from_version: 'ProtocolSemVer', to_version: 'ProtocolSemVer') -> list[str]\", \"schedule_retirement(protocol_name: str, version: 'ProtocolSemVer', retirement_date: 'ProtocolDateTime', replacement_version: 'ProtocolSemVer | None') -> bool\", \"get_retired_versions(protocol_name: str) -> list['ProtocolVersionInfo']\", \"is_version_retired(protocol_name: str, version: 'ProtocolSemVer') -> bool\", \"get_recommended_version(protocol_name: str, current_version: 'ProtocolSemVer') -> 'ProtocolSemVer'\", \"generate_migration_plan(protocol_name: str, from_version: 'ProtocolSemVer', to_version: 'ProtocolSemVer') -> dict[str, object]\", \"async validate_version_usage(protocol_name: str, version: 'ProtocolSemVer') -> list[str]\", 'get_version_statistics(time_window_days: int) -> dict[str, object]'], signature_hash='cb230c0c71b8b776', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCompatibilityCheck', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolVersionInfo'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for version management and compatibility checking.\\n\\n    Provides version metadata management, compatibility verification,\\n    and migration guidance for evolving protocol interfaces.\\n\\n    Key Features:\\n        - Semantic version management for protocols\\n        - Backward and forward compatibility checking\\n        - Breaking change detection and migration guidance\\n        - Deprecation lifecycle management\\n        - Version negotiation for service communication\\n        - Migration path documentation and automation\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class VersionManagerImpl:\\n            async def check_compatibility(self, required, current):\\n                if current.major != required.major:\\n                    return CompatibilityCheck(\\n                        is_compatible=False,\\n                        breaking_changes=[\"Major version mismatch\"],\\n                        migration_required=True\\n                    )\\n                return CompatibilityCheck(is_compatible=True)\\n\\n        # Usage in application code\\n        version_manager: \"ProtocolVersionManager\" = VersionManagerImpl()\\n\\n        compatibility = version_manager.check_compatibility(\\n            required_version=SemVer(2, 1, 0),\\n            current_version=SemVer(2, 0, 5)\\n        )\\n\\n        if not compatibility.is_compatible:\\n            raise VersionError(compatibility.breaking_changes)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConsumer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async subscribe_to_topics(topics: list[str], group_id: str) -> None', 'async unsubscribe_from_topics(topics: list[str]) -> None', \"async consume_messages(timeout_ms: int, max_messages: int) -> list['ProtocolKafkaMessage']\", \"async consume_messages_stream(batch_timeout_ms: int) -> list['ProtocolKafkaMessage']\", 'async commit_offsets() -> None', 'async seek_to_beginning(topic: str, partition: int) -> None', 'async seek_to_end(topic: str, partition: int) -> None', 'async seek_to_offset(topic: str, partition: int, offset: int) -> None', 'async get_current_offsets() -> dict[str, dict[int, int]]', 'async close_consumer() -> None'], signature_hash='413a99eb591b19ed', line_count=10, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=32, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for Kafka consumer operations.\\n\\n    Supports topic subscription, message consumption, offset management,\\n    and consumer group coordination for distributed event processing.\\n\\n    Example:\\n        ```python\\n        consumer: \"ProtocolKafkaConsumer\" = get_kafka_consumer()\\n\\n        # Subscribe to topics\\n        await consumer.subscribe_to_topics(\\n            topics=[\"events\", \"notifications\"],\\n            group_id=\"service_processor\"\\n        )\\n\\n        # Consume messages\\n        async for messages in consumer.consume_messages_stream():\\n            for message in messages:\\n                await process_message(message)\\n            await consumer.commit_offsets()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaBatchProducer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=[\"async send_batch(messages: list['ProtocolKafkaMessage']) -> None\", 'async send_to_partition(topic: str, partition: int, key: bytes | None, value: bytes, headers: dict[str, bytes] | None) -> None', 'async send_with_custom_partitioner(topic: str, key: bytes | None, value: bytes, partition_strategy: str, headers: dict[str, bytes] | None) -> None', 'async flush_pending(timeout_ms: int) -> None', 'async get_batch_metrics() -> dict[str, int]'], signature_hash='f7bb3ba11f25ba86', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=194, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for batch Kafka producer operations.\\n\\n    Supports batching multiple messages, custom partitioning strategies,\\n    transaction management, and high-throughput message production.\\n\\n    Example:\\n        ```python\\n        producer: \"ProtocolKafkaBatchProducer\" = get_batch_producer()\\n\\n        # Prepare batch of messages\\n        messages = [\\n            create_kafka_message(\"user.created\", user_data),\\n            create_kafka_message(\"notification.sent\", notification_data)\\n        ]\\n\\n        # Send batch\\n        await producer.send_batch(messages)\\n        await producer.flush_pending()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaTransactionalProducer', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async init_transactions(transaction_id: str) -> None', 'async begin_transaction() -> None', 'async send_transactional(topic: str, value: bytes, key: bytes | None, headers: dict[str, bytes] | None) -> None', 'async commit_transaction() -> None', 'async abort_transaction() -> None'], signature_hash='3b2a4b2c94193dd7', line_count=5, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=302, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for transactional Kafka producer operations.\\n\\n    Supports exactly-once semantics with transaction management,\\n    atomic message production, and consumer-producer coordination.\\n\\n    Example:\\n        ```python\\n        producer: \"ProtocolKafkaTransactionalProducer\" = get_transactional_producer()\\n\\n        # Start transaction\\n        await producer.begin_transaction()\\n\\n        try:\\n            await producer.send_transactional(\"events\", event_data)\\n            await producer.send_transactional(\"audit\", audit_data)\\n            await producer.commit_transaction()\\n        except Exception:\\n            await producer.abort_transaction()\\n            raise\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaExtendedClient', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=['async create_consumer() -> ProtocolKafkaConsumer', 'async create_batch_producer() -> ProtocolKafkaBatchProducer', 'async create_transactional_producer() -> ProtocolKafkaTransactionalProducer', \"async create_topic(topic_name: str, partitions: int, replication_factor: int, config: dict[str, 'ContextValue'] | None) -> None\", 'async delete_topic(topic_name: str) -> None', 'async list_topics() -> list[str]', 'async get_topic_metadata(topic_name: str) -> dict[str, str | int]', 'async health_check() -> bool', 'async close_client() -> None'], signature_hash='58d1354be27c472f', line_count=9, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=395, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for comprehensive Kafka client with all operations.\\n\\n    Combines producer, consumer, and administrative operations\\n    with advanced features like schema registry and monitoring.\\n\\n    Example:\\n        ```python\\n        client: \"ProtocolKafkaExtendedClient\" = get_extended_kafka_client()\\n\\n        # Create consumer and producer\\n        consumer = client.create_consumer()\\n        producer = client.create_batch_producer()\\n\\n        # Administrative operations\\n        await client.create_topic(\"new_events\", partitions=3, replication=2)\\n        topics = await client.list_topics()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHealthMonitor', file_path='src/omnibase_spi/protocols/core/protocol_health_monitor.py', module_path='omnibase_spi.protocols.core.protocol_health_monitor', methods=[\"async perform_health_check(level: 'LiteralHealthCheckLevel', dimensions: list['LiteralHealthDimension']) -> 'ProtocolHealthCheck'\", \"get_current_health_status() -> 'LiteralHealthStatus'\", \"get_health_metrics() -> 'ProtocolHealthMetrics'\", \"configure_monitoring(config: 'ProtocolHealthMonitoring') -> bool\", \"get_monitoring_configuration() -> 'ProtocolHealthMonitoring'\", 'async start_monitoring() -> bool', 'async stop_monitoring() -> bool', 'is_monitoring_active() -> bool', \"get_health_history(hours_back: int) -> list['ProtocolHealthCheck']\", \"async register_health_dependency(dependency_name: str, dependency_monitor: 'ProtocolHealthMonitor') -> bool\", 'async unregister_health_dependency(dependency_name: str) -> bool', \"get_dependency_health_status(dependency_name: str) -> 'LiteralHealthStatus'\", \"set_health_alert_callback(callback: Callable[[str, 'LiteralHealthStatus', 'LiteralHealthStatus'], None]) -> bool\", \"get_aggregated_health_status() -> dict[str, 'LiteralHealthStatus']\"], signature_hash='7ea3d28222eace2f', line_count=14, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthCheckLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthDimension', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthCheck', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthMetrics', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolHealthMonitoring'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized health monitoring across ONEX services.\\n\\n    Provides consistent health check patterns, monitoring configuration,\\n    and availability tracking for distributed system reliability.\\n\\n    Key Features:\\n        - Multi-level health checks (quick to comprehensive)\\n        - Dimensional health assessment (availability, performance, etc.)\\n        - Configurable monitoring intervals and thresholds\\n        - Health metrics collection and trending\\n        - Automated alerting and escalation\\n        - Service dependency health tracking\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class HealthMonitorImpl:\\n            async def perform_health_check(self, level, dimensions):\\n                checks = {}\\n                metrics = self._collect_metrics()\\n\\n                for dimension in dimensions:\\n                    if dimension == \"availability\":\\n                        checks[dimension] = self._check_availability()\\n                    elif dimension == \"performance\":\\n                        checks[dimension] = self._check_performance(metrics)\\n\\n                overall = self._aggregate_status(checks.values())\\n                return HealthCheck(overall_status=overall, individual_checks=checks)\\n\\n        # Usage in application code\\n        health_monitor: \"ProtocolHealthMonitor\" = HealthMonitorImpl()\\n\\n        health_status = health_monitor.perform_health_check(\\n            level=\"standard\",\\n            dimensions=[\"availability\", \"performance\"]\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolLogger', file_path='src/omnibase_spi/protocols/core/protocol_logger.py', module_path='omnibase_spi.protocols.core.protocol_logger', methods=[\"emit(level: LiteralLogLevel, message: str, correlation_id: UUID, context: 'ProtocolLogContext | None') -> None\", \"log(entry: 'ProtocolLogEntry') -> None\", 'is_level_enabled(level: LiteralLogLevel) -> bool'], signature_hash='cf37fc77af098248', line_count=3, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.LiteralLogLevel', 'omnibase_spi.protocols.types.ProtocolLogContext', 'omnibase_spi.protocols.types.ProtocolLogEntry'], line_number=12, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX logging services that can be resolved from the registry.\\n\\n    This protocol defines the interface that all logging implementations must\\n    implement to be compatible with the ONEX logging system.\\n\\n    Example:\\n        class MyLogger:\\n            def emit(self, level: LiteralLogLevel, message: str, correlation_id: UUID) -> None:\\n                ...\\n\\n            def log(self, entry: \"ProtocolLogEntry\") -> None:\\n                ...\\n    ')",
        "ProtocolInfo(name='ProtocolStorageBackend', file_path='src/omnibase_spi/protocols/core/protocol_storage_backend.py', module_path='omnibase_spi.protocols.core.protocol_storage_backend', methods=[\"async store_checkpoint(checkpoint_data: 'ProtocolCheckpointData') -> 'ProtocolStorageResult'\", \"async retrieve_checkpoint(checkpoint_id: str) -> 'ProtocolStorageResult'\", \"async list_checkpoints(workflow_id: str | None, limit: int | None, offset: int | None) -> 'ProtocolStorageListResult'\", \"async delete_checkpoint(checkpoint_id: str) -> 'ProtocolStorageResult'\", \"async cleanup_expired_checkpoints(retention_hours: int) -> 'ProtocolStorageResult'\", \"async get_storage_status() -> 'ProtocolStorageHealthStatus'\", \"async test_connection() -> 'ProtocolStorageResult'\", \"async initialize_storage() -> 'ProtocolStorageResult'\", 'backend_id() -> str', 'backend_type() -> str', 'is_healthy() -> bool'], signature_hash='48bdc22baba35ea4', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCheckpointData', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageCredentials', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageListResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageResult'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for checkpoint storage backends.\\n\\n    Follows the same pattern as ProtocolEventBus for consistency.\\n    Provides pluggable storage interface for different backends\\n    (filesystem, sqlite, postgresql, cloud storage, etc.).\\n\\n    Key Features:\\n        - Checkpoint storage and retrieval\\n        - Listing with filtering and pagination\\n        - Health monitoring and status\\n        - Connection testing\\n        - Retention policy management\\n    ')",
        "ProtocolInfo(name='ProtocolStorageBackendFactory', file_path='src/omnibase_spi/protocols/core/protocol_storage_backend.py', module_path='omnibase_spi.protocols.core.protocol_storage_backend', methods=[\"async get_storage_backend(backend_type: str, storage_config: 'ProtocolStorageConfiguration', credentials: 'ProtocolStorageCredentials | None') -> 'ProtocolStorageBackend'\", 'async list_available_backends() -> list[str]', \"async validate_backend_config(backend_type: str, storage_config: 'ProtocolStorageConfiguration') -> 'ProtocolStorageResult'\", \"async get_default_config(backend_type: str) -> 'ProtocolStorageConfiguration'\"], signature_hash='a43cb57926f6d92c', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCheckpointData', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageConfiguration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageCredentials', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageListResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolStorageResult'], line_number=198, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for creating storage backends.\\n\\n    Follows the same pattern as event bus factory for consistency.\\n    Provides pluggable factory interface for different backend types.\\n    ')",
        "ProtocolInfo(name='ProtocolInputValidator', file_path='src/omnibase_spi/protocols/core/protocol_input_validator.py', module_path='omnibase_spi.protocols.core.protocol_input_validator', methods=[\"async validate_input(value: 'ContextValue', rules: list[str], validation_level: 'LiteralValidationLevel') -> 'ProtocolValidationResult'\", \"async validate_string(value: str, min_length: int | None, max_length: int | None, pattern: str | None, allow_empty: bool) -> 'ProtocolValidationResult'\", \"async validate_numeric(value: float | int, min_value: float | None, max_value: float | None, allow_negative: bool, precision: int | None) -> 'ProtocolValidationResult'\", \"async validate_collection(value: list[object] | dict[str, object], max_size: int | None, item_rules: list[str] | None, unique_items: bool) -> 'ProtocolValidationResult'\", \"async validate_email(email: str, check_mx: bool, allow_international: bool) -> 'ProtocolValidationResult'\", \"async validate_url(url: str, allowed_schemes: list[str] | None, allow_private_ips: bool, max_length: int) -> 'ProtocolValidationResult'\", 'sanitize_input(value: str, remove_html: bool, escape_special_chars: bool, normalize_whitespace: bool) -> str', \"async validate_batch(inputs: list[dict[str, object]], validation_mode: 'LiteralValidationMode') -> list['ProtocolValidationResult']\", 'add_custom_rule(rule_name: str, validator_function: Callable[..., bool], error_message: str) -> bool', \"async check_security_patterns(value: str, check_sql_injection: bool, check_xss: bool, check_path_traversal: bool, check_command_injection: bool) -> 'ProtocolValidationResult'\", 'async get_validation_statistics(time_window_hours: int) -> dict[str, object]', \"async validate_with_rate_limit(value: str, caller_id: str, max_requests_per_minute: int, validation_type: str) -> 'ProtocolValidationResult'\", 'async get_rate_limit_status(caller_id: str, validation_type: str) -> dict[str, object]'], signature_hash='24935cfe97bee435', line_count=13, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized input validation across ONEX services.\\n\\n    Provides comprehensive input validation, sanitization, and security\\n    checking to prevent injection attacks and ensure data integrity.\\n\\n    Key Features:\\n        - Multi-level validation (basic to paranoid)\\n        - Type-specific validation rules\\n        - Size and format constraints\\n        - Security-focused validation patterns\\n        - Custom validation rule support\\n        - Batch validation for performance\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class InputValidatorImpl:\\n            async def validate_input(self, value, rules, level):\\n                result = ValidationResult(is_valid=True, errors=[], warnings=[])\\n\\n                for rule in rules:\\n                    if rule == \"max_length\" and len(str(value)) > 1000:\\n                        result.is_valid = False\\n                        result.errors.append(\"Input exceeds maximum length\")\\n\\n                return result\\n\\n        # Usage in application code\\n        validator: \"ProtocolInputValidator\" = InputValidatorImpl()\\n\\n        result = validator.validate_input(\\n            value=user_input,\\n            rules=[\"required\", \"max_length:255\", \"no_sql_injection\"],\\n            validation_level=\"standard\"\\n        )\\n\\n        if not result.is_valid:\\n            raise ValidationError(result.errors)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolSchemaLoader', file_path='src/omnibase_spi/protocols/core/protocol_schema_loader.py', module_path='omnibase_spi.protocols.core.protocol_schema_loader', methods=[\"async load_onex_yaml(path: str) -> 'ProtocolNodeMetadataBlock'\", 'async load_json_schema(path: str) -> ProtocolSchemaObject', \"async load_schema_for_node(node: 'ProtocolNodeMetadataBlock') -> ProtocolSchemaObject\"], signature_hash='8cd734eeec177e48', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadataBlock', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSchemaObject'], line_number=16, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX schema loaders.\\n    All methods use path strings and return strongly-typed models as appropriate.\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationManager', file_path='src/omnibase_spi/protocols/core/protocol_configuration_manager.py', module_path='omnibase_spi.protocols.core.protocol_configuration_manager', methods=['async load_configuration(config_name: str) -> dict[str, Any]', 'async validate_configuration(config_data: dict[str, Any]) -> bool', 'get_configuration_value(config_name: str, key: str) -> Any', 'set_configuration_value(config_name: str, key: str, value: Any) -> bool', 'async update_configuration_runtime(config_name: str, updates: dict[str, Any]) -> bool', 'async reload_configuration(config_name: str) -> bool', 'async backup_configuration(config_name: str) -> str | None', 'async restore_configuration(config_name: str, backup_path: str) -> bool', 'get_configuration_sources(config_name: str) -> list[dict[str, Any]]', 'add_configuration_source(config_name: str, source_type: str, source_path: str | None) -> bool', 'remove_configuration_source(config_name: str, source_type: str, source_path: str | None) -> bool', 'is_configuration_valid(config_name: str) -> bool', 'get_configuration_health(config_name: str) -> dict[str, Any]', 'list_configurations() -> list[str]', 'get_sensitive_keys(config_name: str) -> list[str]', 'mask_sensitive_values(config_data: dict[str, Any], config_name: str) -> dict[str, Any]'], signature_hash='e0517860c99ce865', line_count=16, imports=['typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable'], line_number=41, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration management implementations.\\n\\n    Configuration managers provide centralized configuration loading, validation,\\n    merging from multiple sources, and runtime reconfiguration capabilities for\\n    ONEX infrastructure components.\\n\\n    Example:\\n        class MyConfigurationManager:\\n            async def load_configuration(self, config_name: str) -> dict[str, Any]:\\n                # Load from multiple sources and merge\\n                return self._merge_configuration_sources(config_name)\\n\\n            async def validate_configuration(self, config_data: dict[str, Any]) -> bool:\\n                # Validate against schema and constraints\\n                return self._apply_validation_rules(config_data)\\n\\n            async def update_configuration_runtime(\\n                self, config_name: str, updates: dict[str, Any]\\n            ) -> bool:\\n                # Apply runtime configuration updates\\n                return await self._apply_runtime_updates(config_name, updates)\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationManagerFactory', file_path='src/omnibase_spi/protocols/core/protocol_configuration_manager.py', module_path='omnibase_spi.protocols.core.protocol_configuration_manager', methods=['async create_default() -> ProtocolConfigurationManager', 'async create_strict() -> ProtocolConfigurationManager', 'async create_runtime_enabled() -> ProtocolConfigurationManager', 'async create_custom() -> ProtocolConfigurationManager'], signature_hash='746a49fc4c2d26af', line_count=4, imports=['typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable'], line_number=378, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration manager factory implementations.\\n\\n    Factories create and configure configuration managers with different\\n    validation levels, source types, and runtime capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolTimeBasedOperations', file_path='src/omnibase_spi/protocols/core/protocol_time_based.py', module_path='omnibase_spi.protocols.core.protocol_time_based', methods=[\"async start_duration_tracking(operation_id: str) -> 'ProtocolDuration'\", \"complete_duration_tracking(operation_id: str) -> 'ProtocolDuration'\", \"get_operation_duration(operation_id: str) -> 'ProtocolDuration'\", \"set_timeout(operation_id: str, timeout_ms: int, warning_threshold_ms: int | None) -> 'ProtocolTimeout'\", 'is_timeout_expired(operation_id: str) -> bool', 'is_timeout_warning(operation_id: str) -> bool', 'get_timeout_remaining(operation_id: str) -> int', 'clear_timeout(operation_id: str) -> bool', \"async create_time_based_operation(operation_type: 'LiteralTimeBasedType', duration_ms: int) -> 'ProtocolTimeBased'\", 'is_operation_active(operation_id: str) -> bool', 'has_operation_expired(operation_id: str) -> bool', 'get_active_operations() -> list[str]', 'cleanup_expired_operations() -> int', 'get_time_based_metrics() -> dict[str, int | float]', 'reset_time_tracking() -> None', \"schedule_interval_operation(operation_id: str, interval_ms: int) -> 'ProtocolTimeBased'\", \"set_deadline(operation_id: str, deadline: 'ProtocolDateTime') -> 'ProtocolTimeBased'\", 'get_deadline_remaining(operation_id: str) -> int'], signature_hash='20f89dde0c530281', line_count=18, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralTimeBasedType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDuration', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTimeBased', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolTimeout'], line_number=21, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for time-based operations and measurements across ONEX services.\\n\\n    Provides consistent time tracking patterns, timeout management, and\\n    duration measurement for distributed system operations and monitoring.\\n\\n    Key Features:\\n        - Duration measurement for operation timing\\n        - Timeout management with early warning thresholds\\n        - Time-based scheduling and interval management\\n        - Deadline tracking for time-sensitive operations\\n        - Active time window management\\n        - Expiration detection and handling\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class TimeBasedOperationImpl:\\n            async def start_duration_tracking(self, operation_id):\\n                duration = DurationRecord(  # implements ProtocolDuration\\n                    start_time=datetime.now(),\\n                    end_time=None,\\n                    is_completed=False\\n                )\\n                self._active_durations[operation_id] = duration\\n                return duration\\n\\n            def set_timeout(self, operation_id, timeout_ms):\\n                timeout = TimeoutTracker(  # implements ProtocolTimeout\\n                    timeout_ms=timeout_ms,\\n                    start_time=datetime.now(),\\n                    warning_threshold_ms=timeout_ms * 0.8\\n                )\\n                self._active_timeouts[operation_id] = timeout\\n                return timeout\\n\\n        # Usage in application code\\n        time_ops: \"ProtocolTimeBasedOperations\" = TimeBasedOperationImpl()\\n\\n        # Start tracking an operation\\n        duration = time_ops.start_duration_tracking(\"data_processing\")\\n        timeout = time_ops.set_timeout(\"data_processing\", 30000)  # 30 seconds\\n\\n        # Check status during operation\\n        if time_ops.is_timeout_warning(\"data_processing\"):\\n            logger.warning(\"Operation approaching timeout\")\\n\\n        # Complete operation\\n        time_ops.complete_duration_tracking(\"data_processing\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflow', file_path='src/omnibase_spi/protocols/core/protocol_workflow_reducer.py', module_path='omnibase_spi.protocols.core.protocol_workflow_reducer', methods=['async run() -> Any'], signature_hash='c351b423870fb688', line_count=1, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAction', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolState'], line_number=21, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for workflow objects - replaces LlamaIndex dependency.')",
        "ProtocolInfo(name='ProtocolWorkflowReducer', file_path='src/omnibase_spi/protocols/core/protocol_workflow_reducer.py', module_path='omnibase_spi.protocols.core.protocol_workflow_reducer', methods=['initial_state() -> ProtocolState', \"dispatch(state: 'ProtocolState', action: 'ProtocolAction') -> ProtocolState\", \"async dispatch_async(state: 'ProtocolState', action: 'ProtocolAction') -> ProtocolNodeResult\", 'async create_workflow() -> ProtocolWorkflow | None', \"async validate_state_transition(from_state: 'ProtocolState', action: 'ProtocolAction', to_state: 'ProtocolState') -> bool\", 'async get_state_schema() -> dict[str, Any] | None', 'async get_action_schema() -> dict[str, Any] | None'], signature_hash='6e4486f082db472e', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolAction', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolState'], line_number=30, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Enhanced reducer protocol with workflow support.\\n\\n    Extends the basic reducer pattern to support:\\n    - Asynchronous workflow-based state transitions\\n    - Observable state changes via ProtocolNodeResult\\n    - Complex orchestration through workflow patterns\\n    - Monadic composition with error handling\\n    - Event emission for monitoring and coordination\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class UserWorkflowReducer:\\n            def initial_state(self) -> ProtocolState:\\n                return {\\n                    \"users\": {},\\n                    \"session_count\": 0,\\n                    \"last_activity\": None\\n                }\\n\\n            def dispatch(self, state: \"ProtocolState\", action: \"ProtocolAction\") -> ProtocolState:\\n                # Synchronous state transitions\\n                if action[\"type\"] == \"INCREMENT_SESSION\":\\n                    return {**state, \"session_count\": state[\"session_count\"] + 1}\\n                return state\\n\\n            async def dispatch_async(self, state: \"ProtocolState\",\\n                                   action: \"ProtocolAction\") -> ProtocolNodeResult:\\n                # Asynchronous workflow-based transitions\\n                if action[\"type\"] == \"CREATE_USER\":\\n                    try:\\n                        # Complex workflow: validate, create, notify\\n                        user_data = await self._validate_user(action[\"payload\"])\\n                        user_id = await self._create_user_in_db(user_data)\\n                        await self._send_welcome_email(user_id)\\n\\n                        new_state = {\\n                            **state,\\n                            \"users\": {**state[\"users\"], user_id: user_data}\\n                        }\\n\\n                        return ProtocolNodeResult(\\n                            value=new_state,\\n                            is_success=True,\\n                            events=[{\"type\": \"user_created\", \"user_id\": user_id}]\\n                        )\\n                    except Exception as e:\\n                        return ProtocolNodeResult(\\n                            is_failure=True,\\n                            error={\"message\": str(e), \"retryable\": True}\\n                        )\\n\\n        # Usage in application\\n        reducer: \"ProtocolWorkflowReducer\" = UserWorkflowReducer()\\n\\n        # Get initial state\\n        state = reducer.initial_state()\\n\\n        # Synchronous dispatch\\n        action = {\"type\": \"INCREMENT_SESSION\"}\\n        new_state = reducer.dispatch(state, action)\\n\\n        # Asynchronous dispatch\\n        async_action = {\\n            \"type\": \"CREATE_USER\",\\n            \"payload\": {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\\n        }\\n        result = await reducer.dispatch_async(state, async_action)\\n\\n        if result.is_success:\\n            final_state = result.value\\n            print(f\"User created, events: {result.events}\")\\n        else:\\n            print(f\"Error: {result.error}\")\\n        ```\\n\\n    State Management Patterns:\\n        - Immutable state updates (always return new state objects)\\n        - Event sourcing support through ProtocolNodeResult.events\\n        - Error propagation via monadic composition\\n        - Observable state changes for UI/monitoring integration\\n    ')",
        "ProtocolInfo(name='ProtocolValidationRule', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"is_applicable(target: ValidationTarget, context: dict[str, 'ContextValue']) -> bool\", \"async validate(target: ValidationTarget, context: dict[str, 'ContextValue']) -> 'ProtocolValidationResult'\", 'async get_dependencies() -> list[str]'], signature_hash='74be7864c32d7f2e', line_count=9, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=33, is_runtime_checkable=True, domain='core', properties=['rule_id: str', 'rule_name: str', 'rule_description: str', \"rule_version: 'ProtocolSemVer'\", \"severity: 'LiteralValidationSeverity'\", \"category: 'LiteralValidationCategory'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for individual validation rules.\\n\\n    Defines the structure for validation rules that can be applied\\n    to validate different aspects of ONEX components, configurations,\\n    and data structures.\\n\\n    Key Features:\\n        - Rule identification and metadata\\n        - Severity levels for validation outcomes\\n        - Conditional rule application\\n        - Rule composition and dependencies\\n\\n    Usage Example:\\n        ```python\\n        rule: \"ProtocolValidationRule\" = SomeValidationRule()\\n        if rule.is_applicable(target_object):\\n            result = rule.validate(target_object, context)\\n            if not result.is_valid:\\n                handle_validation_failure(result.errors)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationRuleSet', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async get_applicable_rules(target: ValidationTarget, context: dict[str, 'ContextValue']) -> list['ProtocolValidationRule']\", \"resolve_dependencies(rules: list['ProtocolValidationRule']) -> list['ProtocolValidationRule']\", \"async validate_rule_set(context: dict[str, 'ContextValue']) -> bool\"], signature_hash='856e336f1cc7461b', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=105, is_runtime_checkable=True, domain='core', properties=['rule_set_id: str', 'rule_set_name: str', \"rule_set_version: 'ProtocolSemVer'\", \"rules: list['ProtocolValidationRule']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for collections of validation rules.\\n\\n    Manages groups of related validation rules with dependency resolution,\\n    conditional execution, and rule composition capabilities.\\n\\n    Key Features:\\n        - Rule collection management\\n        - Dependency resolution and ordering\\n        - Conditional rule set application\\n        - Performance optimization through rule batching\\n\\n    Usage Example:\\n        ```python\\n        rule_set: \"ProtocolValidationRuleSet\" = ComplianceRuleSet()\\n        applicable_rules = rule_set.get_applicable_rules(target, context)\\n        execution_order = rule_set.resolve_dependencies(applicable_rules)\\n\\n        for rule in execution_order:\\n            result = rule.validate(target, context)\\n            if not result.is_valid:\\n                handle_rule_failure(rule, result)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationSession', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async start_validation(validation_name: str, targets: list[ValidationTarget], metadata: 'ProtocolMetadata | None') -> None\", \"async execute_validation_rules(rule_set: 'ProtocolValidationRuleSet', level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async get_session_progress() -> dict[str, 'ContextValue']\", \"async get_session_summary() -> dict[str, 'ContextValue']\", 'cancel_validation() -> bool', 'end_validation() -> None'], signature_hash='8ef319560a8c7cca', line_count=11, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=179, is_runtime_checkable=True, domain='core', properties=['session_id: str', 'session_name: str', \"start_time: 'ProtocolDateTime'\", \"end_time: 'ProtocolDateTime | None'\", 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for validation execution sessions.\\n\\n    Manages the execution context and state for validation operations,\\n    providing session isolation, progress tracking, and result aggregation.\\n\\n    Key Features:\\n        - Session isolation and state management\\n        - Progress tracking and cancellation\\n        - Result aggregation and reporting\\n        - Performance metrics and diagnostics\\n\\n    Usage Example:\\n        ```python\\n        session: \"ProtocolValidationSession\" = ValidationSession()\\n        session.start_validation(\"component_validation\", targets)\\n\\n        try:\\n            results = session.execute_validation_rules(rule_set, level, mode)\\n            summary = session.get_session_summary()\\n            if not summary.overall_success:\\n                handle_validation_failures(results)\\n        finally:\\n            session.end_validation()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolValidationProvider', file_path='src/omnibase_spi/protocols/core/protocol_validation_provider.py', module_path='omnibase_spi.protocols.core.protocol_validation_provider', methods=[\"async register_validation_rule(rule: 'ProtocolValidationRule') -> bool\", 'async unregister_validation_rule(rule_id: str) -> bool', \"async get_validation_rule(rule_id: str) -> 'ProtocolValidationRule | None'\", \"async list_validation_rules(category_filter: 'LiteralValidationCategory | None', severity_filter: 'LiteralValidationSeverity | None') -> list['ProtocolValidationRule']\", \"async create_rule_set(rule_set_name: str, rule_ids: list[str], rule_set_metadata: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationRuleSet'\", \"async create_validation_session(session_name: str, session_metadata: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationSession'\", \"async get_active_sessions() -> list['ProtocolValidationSession']\", 'cleanup_completed_sessions(older_than_hours: int) -> int', \"async validate(targets: list[ValidationTarget], rule_sets: list['ProtocolValidationRuleSet'], level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async validate_with_session(session: 'ProtocolValidationSession', targets: list[ValidationTarget], rule_sets: list['ProtocolValidationRuleSet'], level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> list['ProtocolValidationResult']\", \"async validate_single(target: ValidationTarget, rule_set: 'ProtocolValidationRuleSet', level: 'LiteralValidationLevel', mode: 'LiteralValidationMode', context: dict[str, 'ContextValue'] | None) -> 'ProtocolValidationResult'\", \"is_validation_successful(results: list['ProtocolValidationResult']) -> bool\", \"async get_critical_issues(results: list['ProtocolValidationResult']) -> list['ProtocolValidationResult']\", \"async get_validation_summary(results: list['ProtocolValidationResult']) -> dict[str, 'ContextValue']\", \"async generate_quality_report(session: 'ProtocolValidationSession', results: list['ProtocolValidationResult'], report_format: str) -> str\", \"async get_provider_metrics() -> dict[str, 'ContextValue']\", \"optimize_rule_execution(rule_sets: list['ProtocolValidationRuleSet']) -> list['ProtocolValidationRuleSet']\", 'clear_validation_cache() -> bool', \"configure_provider(configuration: dict[str, 'ContextValue']) -> bool\", \"async get_provider_health() -> dict[str, 'ContextValue']\", 'async reset_provider_state() -> bool'], signature_hash='cbcbb52d9085ce35', line_count=26, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.TypeAlias', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationCategory', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationLevel', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationMode', 'omnibase_spi.protocols.types.protocol_core_types.LiteralValidationSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolValidatable', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=285, is_runtime_checkable=True, domain='core', properties=['provider_id: str', 'provider_name: str', \"provider_version: 'ProtocolSemVer'\", \"supported_levels: list['LiteralValidationLevel']\", \"supported_modes: list['LiteralValidationMode']\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for comprehensive validation model providers in ONEX systems.\\n\\n    This protocol defines the interface for validation providers that orchestrate\\n    validation workflows, manage validation rules and rule sets, and provide\\n    comprehensive quality assurance capabilities for ONEX services and components.\\n\\n    The validation provider serves as the central orchestration point for all\\n    validation activities, managing rule execution, result aggregation, and\\n    quality reporting across different validation levels and modes.\\n\\n    Key Features:\\n        - Multi-level validation orchestration (BASIC, STANDARD, COMPREHENSIVE, PARANOID)\\n        - Multiple execution modes (strict, lenient, smoke, regression, integration)\\n        - Dynamic rule management and composition\\n        - Session-based validation execution with progress tracking\\n        - Comprehensive result reporting and quality metrics\\n        - Performance optimization and caching\\n        - Plugin architecture for custom validation rules\\n\\n    Validation Levels:\\n        - BASIC: Essential validation only (fast performance)\\n        - STANDARD: Normal validation with common checks\\n        - COMPREHENSIVE: Thorough validation with detailed analysis\\n        - PARANOID: Maximum validation with all possible checks\\n\\n    Validation Modes:\\n        - strict: Fail on any validation error\\n        - lenient: Allow warnings but fail on errors\\n        - smoke: Basic functionality validation\\n        - regression: Validate against known good states\\n        - integration: Cross-system validation testing\\n\\n    Usage Example:\\n        ```python\\n        # Initialize validation provider\\n        provider: \"ProtocolValidationProvider\" = SomeValidationProvider()\\n\\n        # Register validation rules\\n        compliance_rules = provider.create_rule_set(\\n            \"compliance_validation\",\\n            [\"namespace_isolation\", \"protocol_purity\", \"import_validation\"]\\n        )\\n\\n        # Execute comprehensive validation\\n        session = provider.create_validation_session(\"component_audit\")\\n        results = provider.validate_with_session(\\n            session=session,\\n            targets=[component1, component2],\\n            rule_sets=[compliance_rules],\\n            level=\"COMPREHENSIVE\",\\n            mode=\"strict\"\\n        )\\n\\n        # Process results\\n        if not provider.is_validation_successful(results):\\n            failures = provider.get_critical_issues(results)\\n            handle_validation_failures(failures)\\n\\n        # Generate quality report\\n        report = provider.generate_quality_report(session, results)\\n        save_validation_report(report)\\n        ```\\n\\n    Integration Patterns:\\n        - Works with existing ProtocolValidationResult from protocol_core_types\\n        - Integrates with ONEX observability and monitoring systems\\n        - Supports custom rule development and plugin architecture\\n        - Compatible with CI/CD pipeline integration\\n        - Provides metrics for quality dashboards and alerting\\n    ')",
        "ProtocolInfo(name='ProtocolRetryable', file_path='src/omnibase_spi/protocols/core/protocol_retryable.py', module_path='omnibase_spi.protocols.core.protocol_retryable', methods=[\"async execute_with_retry(operation: Callable[..., Any], config: 'ProtocolRetryConfig') -> 'ProtocolRetryResult'\", \"configure_retry_policy(policy: 'ProtocolRetryPolicy') -> bool\", \"get_retry_policy() -> 'ProtocolRetryPolicy'\", \"should_retry(error: Exception, attempt_number: int, config: 'ProtocolRetryConfig') -> bool\", \"calculate_backoff_delay(attempt_number: int, strategy: 'LiteralRetryBackoffStrategy', base_delay_ms: int, max_delay_ms: int) -> int\", \"record_retry_attempt(attempt: 'ProtocolRetryAttempt') -> None\", \"get_retry_metrics() -> dict[str, 'ContextValue']\", 'reset_retry_budget() -> None', 'get_retry_budget_status() -> dict[str, int]', \"add_retry_condition(condition: 'LiteralRetryCondition', error_types: list[type[BaseException]]) -> bool\", \"remove_retry_condition(condition: 'LiteralRetryCondition') -> bool\", \"get_retry_conditions() -> list['LiteralRetryCondition']\"], signature_hash='4c8020f2e03012f7', line_count=12, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralRetryBackoffStrategy', 'omnibase_spi.protocols.types.protocol_core_types.LiteralRetryCondition', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryAttempt', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryConfig', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryPolicy', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRetryResult'], line_number=23, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized retry functionality across ONEX services.\\n\\n    Provides consistent retry patterns, backoff strategies, and policy\\n    management for resilient distributed system operations.\\n\\n    Key Features:\\n        - Configurable retry policies with multiple backoff strategies\\n        - Conditional retry logic based on error types and contexts\\n        - Retry attempt tracking with success/failure metrics\\n        - Backoff strategies: linear, exponential, fibonacci, fixed, jitter\\n        - Circuit breaker integration for fail-fast scenarios\\n        - Retry budget management to prevent resource exhaustion\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class RetryableServiceImpl:\\n            async def execute_with_retry(self, operation, config):\\n                for attempt in range(config.max_attempts):\\n                    try:\\n                        result = operation()\\n                        self._record_success(attempt)\\n                        return ProtocolRetryResult(success=True, result=result)\\n                    except Exception as e:\\n                        if not self._should_retry(e, attempt, config):\\n                            break\\n                        self._apply_backoff(attempt, config.backoff_strategy)\\n\\n                return ProtocolRetryResult(success=False, final_error=e)\\n\\n        # Usage in application code\\n        retryable: \"ProtocolRetryable\" = RetryableServiceImpl()\\n\\n        retry_config = \"ProtocolRetryConfig\"(\\n            max_attempts=5,\\n            backoff_strategy=\"fibonacci\",\\n            base_delay_ms=1000,\\n            max_delay_ms=30000\\n        )\\n\\n        result = retryable.execute_with_retry(\\n            operation=lambda: external_api_call(),\\n            config=retry_config\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolNodeConfiguration', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['get_config_value(key: str, default: ContextValue | None) -> ContextValue', 'get_timeout_ms(timeout_type: str, default_ms: int | None) -> int', 'get_security_config(key: str, default: ContextValue | None) -> ContextValue', 'get_business_logic_config(key: str, default: ContextValue | None) -> ContextValue', 'get_performance_config(key: str, default: ContextValue | None) -> ContextValue', 'has_config(key: str) -> bool', \"get_all_config() -> dict[str, 'ContextValue']\", 'async validate_config(config_key: str) -> bool', 'async validate_required_configs(required_keys: list[str]) -> dict[str, bool]', \"get_config_schema() -> dict[str, 'ContextValue']\"], signature_hash='7077782ae4c79847', line_count=10, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=13, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node configuration management.\\n\\n    Provides standardized configuration access for all ONEX nodes\\n    without coupling to specific configuration implementations.\\n\\n    Example:\\n        ```python\\n        # Basic usage\\n        config: \"ProtocolNodeConfiguration\" = get_node_config()\\n\\n        # Get configuration values\\n        api_url = config.get_config_value(\"api.base_url\", \"http://localhost:8080\")\\n        timeout = config.get_timeout_ms(\"api_call\", 5000)\\n\\n        # Domain-specific configurations\\n        auth_settings = config.get_security_config(\"authentication\")\\n        perf_limits = config.get_performance_config(\"memory.max_heap_mb\")\\n\\n        # Check configuration availability\\n        if config.has_config(\"feature.experimental\"):\\n            experimental_mode = config.get_config_value(\"feature.experimental\")\\n\\n        # Validate configurations\\n        is_valid = config.validate_config(\"api.base_url\")\\n        required_keys = [\"database.host\", \"database.port\", \"api.key\"]\\n        validation_results = config.validate_required_configs(required_keys)\\n\\n        # Get configuration schema\\n        schema = config.get_config_schema()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolNodeConfigurationProvider', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['async load_configuration(node_type: str, node_id: str) -> ProtocolNodeConfiguration', 'async reload_configuration() -> None', 'async validate_configuration() -> bool'], signature_hash='5e3442f0c0d2ad2e', line_count=3, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=181, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration provider implementations.\\n\\n    Allows different configuration backends (environment, files, databases)\\n    to be used interchangeably through dependency injection.\\n    ')",
        "ProtocolInfo(name='ProtocolConfigurationError', file_path='src/omnibase_spi/protocols/core/protocol_node_configuration.py', module_path='omnibase_spi.protocols.core.protocol_node_configuration', methods=['__str__() -> str', 'is_key_error(config_key: str) -> bool', 'get_error_context() -> dict[str, str | None]'], signature_hash='fea8191f0efacad5', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=226, is_runtime_checkable=True, domain='core', properties=['message: str', 'key: str | None', 'source: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for configuration-related errors.\\n\\n    Provides structured error information for configuration failures\\n    with support for error formatting and context details.\\n\\n    Example:\\n        ```python\\n        error: \"ProtocolConfigurationError\" = ConfigError(\\n            message=\"Missing required configuration\",\\n            key=\"database.host\",\\n            source=\"environment\"\\n        )\\n\\n        # String representation\\n        error_msg = str(error)  # \"Config error in environment: Missing required configuration (key: database.host)\"\\n\\n        # Check if error is for specific key\\n        if error.is_key_error(\"database.host\"):\\n            # Handle specific key error\\n            ...\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolNodeChangeCallback', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[\"__call__(node_info: 'ProtocolNodeInfo', change_type: str) -> None\"], signature_hash='17af6ac61c672534', line_count=1, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=24, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for node change callback functions.')",
        "ProtocolInfo(name='ProtocolNodeRegistry', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=['environment() -> str', 'consul_endpoint() -> str | None', 'config() -> ProtocolNodeRegistryConfig | None', \"async register_node(node_info: 'ProtocolNodeInfo', ttl_seconds: int) -> bool\", 'async unregister_node(node_id: str) -> bool', \"async update_node_health(node_id: str, health_status: 'LiteralHealthStatus', metadata: dict[str, 'ContextValue']) -> bool\", 'async heartbeat(node_id: str) -> bool', \"async discover_nodes(node_type: 'LiteralNodeType | None', environment: str | None, group: str | None, health_filter: 'LiteralHealthStatus | None') -> list['ProtocolNodeInfo']\", 'async get_node(node_id: str) -> ProtocolNodeInfo | None', \"async get_nodes_by_group(group: str) -> list['ProtocolNodeInfo']\", 'async get_gateway_for_group(group: str) -> ProtocolNodeInfo | None', \"async watch_node_changes(callback: 'ProtocolNodeChangeCallback', node_type: 'LiteralNodeType | None', group: str | None) -> ProtocolWatchHandle\", \"async stop_watch(watch_handle: 'ProtocolWatchHandle') -> None\"], signature_hash='3958da80247eb054', line_count=13, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=69, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node discovery and registration services.\\n\\n    Supports the ONEX Messaging Design v0.3 patterns:\\n    - Environment isolation (dev, staging, prod)\\n    - Node group mini-meshes\\n    - Consul-based discovery integration\\n    - Health monitoring and heartbeat tracking\\n\\n    Implementations may use Consul, etcd, or other discovery backends.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class RegistryConsulNode:\\n            @property\\n            def environment(self) -> str: ...\\n\\n            @property\\n            def consul_endpoint(self) -> str: ...\\n\\n            @property\\n            def watches(self) -> dict[str, object]: ...\\n\\n            async def register_node(self, node_info: \"ProtocolNodeInfo\", ttl_seconds: int) -> bool:\\n                # Register node in Consul with TTL health check\\n                service_id = f\"{node_info.node_id}-{self.environment}\"\\n                return await self.consul.agent.service.register(\\n                    name=f\"{self.environment}-{node_info.group}-{node_info.node_type}\",\\n                    service_id=service_id,\\n                    address=node_info.endpoint.split(\\':\\')[0],\\n                    port=int(node_info.endpoint.split(\\':\\')[1]),\\n                    tags=[node_info.group, str(node_info.version)],\\n                    meta=node_info.metadata,\\n                    check=consul.Check.ttl(f\"{ttl_seconds}s\")\\n                )\\n\\n            async def discover_nodes(self, node_type: Optional[LiteralNodeType] = None,\\n                                   environment: Optional[str] = None,\\n                                   group: Optional[str] = None) -> list[\"ProtocolNodeInfo\"]:\\n                # Discover nodes from Consul catalog\\n                env = environment or self.environment\\n                service_filter = f\"{env}-\"\\n                if group:\\n                    service_filter += f\"{group}-\"\\n                if node_type:\\n                    service_filter += str(node_type)\\n\\n                services = await self.consul.catalog.services()\\n                matching_nodes = []\\n\\n                for service_name in services:\\n                    if service_name.startswith(service_filter):\\n                        service_info = await self.consul.catalog.service(service_name)\\n                        for node in service_info:\\n                            matching_nodes.append(self._convert_to_node_info(node))\\n\\n                return matching_nodes\\n\\n        # Usage in application\\n        registry: \"ProtocolNodeRegistry\" = RegistryConsulNode(\"prod\", \"consul.company.com:8500\")\\n\\n        # Register current node\\n        node_info = NodeInfo(\\n            node_id=\"worker-001\",\\n            node_type=\"COMPUTE\",\\n            node_name=\"Data Processor\",\\n            environment=\"prod\",\\n            group=\"analytics\",\\n            version=ProtocolSemVer(1, 2, 3),\\n            health_status=\"healthy\",\\n            endpoint=\"10.0.1.15:8080\",\\n            metadata={\"cpu_cores\": 8, \"memory_gb\": 32},\\n            registered_at=datetime.now(),\\n            last_heartbeat=datetime.now()\\n        )\\n\\n        success = await registry.register_node(node_info, ttl_seconds=60)\\n        if success:\\n            print(f\"Registered {node_info.node_name} successfully\")\\n\\n        # Discover compute nodes in analytics group\\n        compute_nodes = await registry.discover_nodes(\\n            node_type=\"COMPUTE\",\\n            environment=\"prod\",\\n            group=\"analytics\"\\n        )\\n\\n        print(f\"Found {len(compute_nodes)} compute nodes in analytics group\")\\n\\n        # Set up node change monitoring\\n        async def on_node_change(node: \"ProtocolNodeInfo\", change_type: str):\\n            print(f\"Node {node.node_name} changed: {change_type}\")\\n            if change_type == \"unhealthy\":\\n                # Implement failover logic\\n                await handle_node_failure(node)\\n\\n        watch_handle = await registry.watch_node_changes(\\n            callback=on_node_change,\\n            node_type=\"COMPUTE\",\\n            group=\"analytics\"\\n        )\\n\\n        # Send periodic heartbeats\\n        while True:\\n            await registry.heartbeat(node_info.node_id)\\n            await asyncio.sleep(30)  # Heartbeat every 30 seconds\\n        ```\\n\\n    Node Discovery Patterns:\\n        - Environment-based isolation: `prod-analytics-COMPUTE`\\n        - Group-based discovery: Find all nodes in a node group\\n        - Health-based filtering: Only discover healthy nodes\\n        - Type-based filtering: Find specific node types (COMPUTE, ORCHESTRATOR, etc.)\\n        - Watch-based monitoring: Real-time notifications of node changes\\n    ')",
        "ProtocolInfo(name='ProtocolErrorHandler', file_path='src/omnibase_spi/protocols/core/protocol_error_handler.py', module_path='omnibase_spi.protocols.core.protocol_error_handler', methods=[\"async handle_error(error: Exception, context: 'ProtocolErrorContext') -> 'ProtocolErrorResult'\", \"get_error_recovery_strategy(error_result: 'ProtocolErrorResult') -> 'ProtocolRecoveryAction'\", \"classify_error_severity(error: Exception, context: 'ProtocolErrorContext') -> 'LiteralErrorSeverity'\", \"should_retry_error(error_result: 'ProtocolErrorResult', attempt_count: int) -> bool\", \"get_backoff_delay_seconds(error_result: 'ProtocolErrorResult', attempt_count: int) -> float\", \"record_error_metrics(error_result: 'ProtocolErrorResult', recovery_outcome: str) -> None\", 'activate_circuit_breaker(service_name: str, error_threshold: int) -> bool', 'get_circuit_breaker_status(service_name: str) -> str', 'reset_circuit_breaker(service_name: str) -> bool', 'get_error_statistics(time_window_minutes: int) -> dict[str, object]'], signature_hash='111929d89f0c0180', line_count=10, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralErrorSeverity', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolErrorContext', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolErrorResult', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolRecoveryAction'], line_number=20, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized error handling across ONEX services.\\n\\n    Provides consistent error handling patterns, recovery strategies,\\n    and observability for distributed system reliability.\\n\\n    Key Features:\\n        - Standardized error classification and severity\\n        - Automatic recovery strategy selection\\n        - Error context capture and correlation\\n        - Circuit breaker pattern support\\n        - Comprehensive error observability\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ErrorHandlerImpl:\\n            def handle_error(self, error, context):\\n                error_result = self._classify_error(error)\\n                recovery_action = self.get_error_recovery_strategy(error_result)\\n                if recovery_action.action_type == \"retry\":\\n                    return self._retry_with_backoff(error_result, recovery_action)\\n                elif recovery_action.action_type == \"circuit_breaker\":\\n                    return self._activate_circuit_breaker(error_result)\\n                else:\\n                    return self._handle_terminal_error(error_result)\\n\\n        # Usage in application code\\n        error_handler: \"ProtocolErrorHandler\" = ErrorHandlerImpl()\\n\\n        try:\\n            result = risky_operation()\\n        except Exception as e:\\n            error_context = create_error_context(operation_name=\"risky_operation\")\\n            return error_handler.handle_error(e, error_context)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolServiceDiscovery', file_path='src/omnibase_spi/protocols/core/protocol_service_discovery.py', module_path='omnibase_spi.protocols.core.protocol_service_discovery', methods=[\"async register_service(service_name: str, service_id: str, host: str, port: int, metadata: 'ProtocolServiceMetadata', health_check_url: str | None, tags: list[str] | None) -> bool\", 'async deregister_service(service_id: str) -> bool', \"async discover_services(service_name: str, healthy_only: bool, tags: list[str] | None, limit: int | None, offset: int | None) -> tuple[list['ProtocolServiceInstance'], bool]\", \"async get_service_health(service_id: str) -> 'ProtocolServiceHealthStatus'\", 'async set_key_value(key: str, value: str) -> bool', 'async get_key_value(key: str) -> str | None', 'async delete_key(key: str) -> bool', 'async list_keys(prefix: str) -> list[str]', 'async health_check() -> bool', 'async close() -> None'], signature_hash='fb74c40ac07fe611', line_count=10, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceInstance', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolServiceMetadata'], line_number=19, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service discovery systems.\\n\\n    Abstracts service registration, discovery, and health checking\\n    from specific implementations like Consul, etcd, or in-memory fallbacks.\\n\\n    Key Features:\\n        - Service registration and deregistration\\n        - Service discovery with health filtering\\n        - Key-value store functionality\\n        - Health monitoring capabilities\\n        - Clean resource management\\n    ')",
        "ProtocolInfo(name='ProtocolOnexNode', file_path='src/omnibase_spi/protocols/core/protocol_onex_node.py', module_path='omnibase_spi.protocols.core.protocol_onex_node', methods=['run() -> Any', \"get_node_config() -> 'ProtocolNodeConfiguration'\", 'get_input_model() -> type[Any]', 'get_output_model() -> type[Any]'], signature_hash='94540a976d94afb8', line_count=4, imports=['typing.TYPE_CHECKING', 'typing.Any', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.core.protocol_node_configuration.ProtocolNodeConfiguration'], line_number=10, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for ONEX node implementations.\\n\\n    All ONEX nodes must implement these methods to be compatible with the\\n    dynamic node loading system and container orchestration.\\n\\n    This protocol defines the standard interface that node_loader.py expects\\n    when loading and validating nodes.\\n\\n    Key Features:\\n        - Standard execution interface\\n        - Configuration metadata access\\n        - Input/output type definitions\\n        - Runtime compatibility validation\\n\\n    Breaking Changes (v2.0):\\n        - get_input_type() \u2192 get_input_model() for clarity\\n        - get_output_type() \u2192 get_output_model() for clarity\\n\\n    Migration Guide:\\n        For existing implementations, rename your methods:\\n        ```python\\n        # Old (v1.x)\\n        def get_input_type(self) -> type[Any]: ...\\n        def get_output_type(self) -> type[Any]: ...\\n\\n        # New (v2.0+)\\n        def get_input_model(self) -> type[Any]: ...\\n        def get_output_model(self) -> type[Any]: ...\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolContractService', file_path='src/omnibase_spi/protocols/core/protocol_contract_service.py', module_path='omnibase_spi.protocols.core.protocol_contract_service', methods=[\"async load_contract(contract_path: str) -> 'ProtocolMetadata'\", \"async validate_contract(contract_data: 'ProtocolMetadata') -> 'ProtocolValidationResult'\", \"async get_cached_contract(contract_path: str) -> 'ProtocolMetadata | None'\", \"cache_contract(contract_path: str, contract_data: 'ProtocolMetadata') -> bool\", 'clear_cache(contract_path: str | None) -> int', \"extract_node_id(contract_data: 'ProtocolMetadata') -> str\", \"extract_version(contract_data: 'ProtocolMetadata') -> 'ProtocolSemVer'\", \"extract_dependencies(contract_data: 'ProtocolMetadata') -> list[dict[str, 'ContextValue']]\", \"extract_tool_class_name(contract_data: 'ProtocolMetadata') -> str\", \"extract_event_patterns(contract_data: 'ProtocolMetadata') -> list[str]\", 'async get_cache_statistics() -> dict[str, object]', 'async health_check() -> dict[str, object]'], signature_hash='10682b829966dc3e', line_count=12, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=22, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for contract service operations following ONEX standards.\\n\\n    Provides contract management including loading, parsing, validation,\\n    caching, and metadata extraction for ONEX-compliant systems.\\n\\n    Key Features:\\n        - Contract loading and parsing from YAML files\\n        - Contract validation and structure verification\\n        - Contract caching for performance optimization\\n        - Contract metadata extraction and processing\\n        - Version management and dependency resolution\\n        - Event pattern extraction\\n        - Health monitoring\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ContractServiceImpl:\\n            async def load_contract(self, contract_path: str) -> dict:\\n                with open(contract_path) as f:\\n                    import yaml\\n                    return yaml.safe_load(f)\\n\\n            async def validate_contract(self, contract_data: dict) -> dict:\\n                # Validate contract structure and content\\n                is_valid = self._validate_structure(contract_data)\\n                return {\\n                    \\'is_valid\\': is_valid,\\n                    \\'errors\\': [],\\n                    \\'warnings\\': []\\n                }\\n\\n        # Usage in application code\\n        contract_service: \"ProtocolContractService\" = ContractServiceImpl()\\n\\n        contract = contract_service.load_contract(\\'/path/to/contract.yaml\\')\\n        validation_result = contract_service.validate_contract(contract)\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolErrorSanitizer', file_path='src/omnibase_spi/protocols/core/protocol_error_sanitizer.py', module_path='omnibase_spi.protocols.core.protocol_error_sanitizer', methods=['sanitize_message(message: str) -> str', 'sanitize_exception(exception: Exception) -> Exception', 'sanitize_dict(data: dict[str, Any]) -> dict[str, Any]', 'sanitize_list(data: list[Any]) -> list[Any]', 'sanitize_file_path(path: str) -> str', 'get_cache_info() -> dict[str, Any]'], signature_hash='a7a3fecd3c225449', line_count=6, imports=['typing.Any', 'typing.Protocol', 'typing.runtime_checkable'], line_number=36, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for error message sanitization implementations.\\n\\n    Error sanitizers protect sensitive information by masking or removing\\n    confidential data from error messages, logs, and exception details\\n    while preserving debugging context.\\n\\n    Example:\\n        class MyErrorSanitizer:\\n            def sanitize_message(self, message: str) -> str:\\n                # Remove passwords, API keys, etc.\\n                return self._apply_sanitization_patterns(message)\\n\\n            def sanitize_exception(self, exception: Exception) -> Exception:\\n                sanitized_message = self.sanitize_message(str(exception))\\n                return type(exception)(sanitized_message)\\n    ')",
        "ProtocolInfo(name='ProtocolErrorSanitizerFactory', file_path='src/omnibase_spi/protocols/core/protocol_error_sanitizer.py', module_path='omnibase_spi.protocols.core.protocol_error_sanitizer', methods=['async create_default() -> ProtocolErrorSanitizer', 'async create_strict() -> ProtocolErrorSanitizer', 'async create_lenient() -> ProtocolErrorSanitizer', 'async create_custom() -> ProtocolErrorSanitizer'], signature_hash='fc5b155f4d4c8c12', line_count=4, imports=['typing.Any', 'typing.Protocol', 'typing.runtime_checkable'], line_number=126, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for error sanitizer factory implementations.\\n\\n    Factories create and configure error sanitizers with different\\n    security levels and pattern sets.\\n    ')",
        "ProtocolInfo(name='ProtocolCircuitBreakerConfig', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['failure_threshold() -> int', 'recovery_timeout_seconds() -> float', 'half_open_max_calls() -> int', 'success_threshold() -> int', 'metrics_window_seconds() -> float', 'request_timeout_seconds() -> float'], signature_hash='d76f76c058088f1a', line_count=6, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=51, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Configuration protocol for circuit breaker settings.')",
        "ProtocolInfo(name='ProtocolCircuitBreakerMetrics', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['total_requests() -> int', 'successful_requests() -> int', 'failed_requests() -> int', 'timeout_requests() -> int', \"current_state() -> 'LiteralProtocolCircuitBreakerState'\", 'state_changes() -> int', 'last_state_change() -> float | None', 'last_success_time() -> float | None', 'last_failure_time() -> float | None', 'average_response_time_ms() -> float', 'requests_in_window() -> int', 'failures_in_window() -> int', 'successes_in_window() -> int', 'half_open_requests() -> int', 'half_open_successes() -> int', 'half_open_failures() -> int', 'get_failure_rate() -> float', 'get_success_rate() -> float', 'reset_window() -> None'], signature_hash='af388124a55536e5', line_count=19, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=86, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='Real-time circuit breaker metrics.')",
        "ProtocolInfo(name='ProtocolCircuitBreaker', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=['service_name() -> str', \"get_state() -> 'LiteralProtocolCircuitBreakerState'\", 'get_metrics() -> ProtocolCircuitBreakerMetrics', 'async call(func: Callable[[], Awaitable[T]], fallback: Callable[[], Awaitable[T]] | None, timeout: float | None) -> T', 'async record_success(execution_time_ms: float | None) -> None', 'async record_failure(exception: Exception | None) -> None', 'async record_timeout() -> None'], signature_hash='260273100ac1c20a', line_count=7, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=188, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for circuit breaker fault tolerance implementations.\\n\\n    Circuit breakers prevent cascading failures by monitoring external\\n    service calls and temporarily stopping requests when failure thresholds\\n    are exceeded.\\n\\n    Example:\\n        class MyCircuitBreaker:\\n            def get_state(self) -> \"LiteralProtocolCircuitBreakerState\":\\n                return self._current_state\\n\\n            async def call(self, func, fallback=None, timeout=None):\\n                if self.get_state() == \"open\":\\n                    if fallback:\\n                        return await fallback()\\n                    raise Exception(\"Circuit breaker is open\")\\n\\n                try:\\n                    result = await func()\\n                    await self.record_success()\\n                    return result\\n                except Exception as e:\\n                    await self.record_failure(e)\\n                    raise\\n    ')",
        "ProtocolInfo(name='ProtocolCircuitBreakerFactory', file_path='src/omnibase_spi/protocols/core/protocol_circuit_breaker.py', module_path='omnibase_spi.protocols.core.protocol_circuit_breaker', methods=[\"get_circuit_breaker(service_name: str, config: 'ProtocolCircuitBreakerConfig | None') -> ProtocolCircuitBreaker | None\", \"async register_circuit_breaker(service_name: str, circuit_breaker: 'ProtocolCircuitBreaker') -> None\", 'remove_circuit_breaker(service_name: str) -> bool', \"get_all_circuit_breakers() -> dict[str, 'ProtocolCircuitBreaker']\"], signature_hash='c73c2de64a7fbb00', line_count=4, imports=['typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable'], line_number=287, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for circuit breaker factory implementations.\\n\\n    Factories manage circuit breaker instances and provide\\n    consistent configuration across services.\\n    ')",
        "ProtocolInfo(name='ProtocolClientConfigProvider', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=['async get_http_client_config(client_name: str) -> ProtocolHttpClientConfig', 'async get_http_auth_config(auth_name: str) -> ProtocolHttpAuthConfig', 'async get_kafka_client_config(client_name: str) -> ProtocolKafkaClientConfig', 'async get_kafka_producer_config(producer_name: str) -> ProtocolKafkaProducerConfig', 'async get_kafka_consumer_config(consumer_name: str) -> ProtocolKafkaConsumerConfig', 'async validate_configurations() -> list[str]', 'async reload_configurations() -> None', 'async get_configuration_summary() -> dict[str, dict[str, str | int | bool]]'], signature_hash='06697e3181df5285', line_count=8, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=162, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for client configuration provider.\\n\\n    Provides access to typed configuration objects for HTTP and Kafka clients\\n    with support for environment-based overrides and configuration validation.\\n\\n    Example:\\n        ```python\\n        provider: \"ProtocolClientConfigProvider\" = get_config_provider()\\n\\n        http_config = provider.get_http_client_config(\"api_client\")\\n        kafka_config = provider.get_kafka_client_config(\"event_processor\")\\n\\n        # Validate configurations\\n        await provider.validate_configurations()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolCanonicalSerializer', file_path='src/omnibase_spi/protocols/core/protocol_canonical_serializer.py', module_path='omnibase_spi.protocols.core.protocol_canonical_serializer', methods=[\"canonicalize_metadata_block(block: 'ProtocolNodeMetadata', volatile_fields: tuple[str, ...], placeholder: str) -> str\", 'normalize_body(body: str) -> str', \"canonicalize_for_hash(block: 'ProtocolNodeMetadata', body: str, volatile_fields: tuple[str, ...], placeholder: str) -> str\"], signature_hash='68958e2b7797b8df', line_count=3, imports=['typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ProtocolNodeMetadata'], line_number=31, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for canonical serialization and normalization of metadata blocks.\\n    Enforces protocol-compliant, deterministic serialization for stamping, hashing, and idempotency.\\n    All field references must use canonical Enums (e.g., NodeMetadataField), not string literals.\\n    Implementations may support YAML, JSON, or other formats.\\n\\n    NOTE: This protocol uses TYPE_CHECKING and forward references for data types to avoid circular imports\\n    while maintaining strong typing. This is the canonical pattern for all ONEX protocol interfaces.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowManageable', file_path='src/omnibase_spi/protocols/core/protocol_workflow_manageable.py', module_path='omnibase_spi.protocols.core.protocol_workflow_manageable', methods=[\"async create_workflow_instance(workflow_type: str, instance_id: UUID, initial_context: dict[str, 'ContextValue'], correlation_metadata: 'ProtocolMetadata', configuration: dict[str, 'ContextValue'] | None) -> 'ProtocolWorkflowSnapshot'\", \"async start_workflow_execution(workflow_type: str, instance_id: UUID, execution_context: dict[str, 'ContextValue']) -> bool\", 'async pause_workflow_execution(workflow_type: str, instance_id: UUID, reason: str | None) -> bool', 'async resume_workflow_execution(workflow_type: str, instance_id: UUID) -> bool', 'async terminate_workflow_execution(workflow_type: str, instance_id: UUID, termination_reason: str, force: bool) -> bool', \"async transition_workflow_state(workflow_type: str, instance_id: UUID, target_state: 'LiteralWorkflowState', event_metadata: dict[str, 'ContextValue'] | None, causation_id: UUID | None) -> bool\", \"async get_workflow_state(workflow_type: str, instance_id: UUID) -> 'LiteralWorkflowState'\", \"async get_workflow_snapshot(workflow_type: str, instance_id: UUID, include_task_details: bool) -> 'ProtocolWorkflowSnapshot'\", \"async schedule_workflow_task(workflow_type: str, instance_id: UUID, task_definition: dict[str, 'ContextValue'], dependencies: list[UUID] | None) -> UUID\", \"async update_task_state(workflow_type: str, instance_id: UUID, task_id: UUID, new_state: 'LiteralTaskState', result_data: dict[str, 'ContextValue'] | None) -> bool\", \"async get_task_dependencies_status(workflow_type: str, instance_id: UUID, task_id: UUID) -> dict[UUID, 'LiteralTaskState']\", \"async handle_workflow_event(workflow_event: 'ProtocolWorkflowEvent') -> bool\", \"async publish_workflow_event(workflow_type: str, instance_id: UUID, event_type: 'LiteralWorkflowEventType', event_data: dict[str, 'ContextValue'], causation_id: UUID | None, correlation_chain: list[UUID] | None) -> UUID\", \"async get_workflow_execution_metrics(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async get_workflow_performance_summary(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", 'async initiate_compensation(workflow_type: str, instance_id: UUID, compensation_reason: str, failed_task_id: UUID | None) -> bool', \"async check_compensation_status(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async validate_workflow_consistency(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\", \"async get_workflow_health_status(workflow_type: str, instance_id: UUID) -> dict[str, 'ContextValue']\"], signature_hash='41515d0e03025a5e', line_count=19, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=69, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for entities that can be managed within workflow orchestration.\\n\\n    This protocol defines the contract for workflow lifecycle management,\\n    state transitions, execution monitoring, and event coordination within\\n    the ONEX distributed orchestration framework.\\n\\n    Key Capabilities:\\n        - Complete workflow lifecycle management\\n        - Event-driven state transitions with FSM support\\n        - Real-time execution monitoring and metrics\\n        - Workflow instance isolation and correlation\\n        - Compensation action support for saga patterns\\n        - Distributed task coordination and dependency resolution\\n    ')",
        "ProtocolInfo(name='ProtocolOnexValidation', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[\"async validate_envelope(envelope: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_reply(reply: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_contract_compliance(contract_data: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async validate_security_context(security_context: 'ProtocolOnexSecurityContext') -> ProtocolOnexValidationResult\", \"async validate_metadata(metadata: 'ProtocolOnexMetadata') -> ProtocolOnexValidationResult\", \"async validate_full_onex_pattern(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> ProtocolOnexValidationResult\", \"async check_required_fields(data: 'ProtocolOnexContractData', required_fields: list[str]) -> list[str]\", 'async validate_semantic_versioning(version: str) -> bool', \"async validate_correlation_id_consistency(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> bool\", \"async validate_timestamp_sequence(envelope: 'ProtocolOnexContractData', reply: 'ProtocolOnexContractData') -> bool\", 'get_validation_schema(validation_type: LiteralValidationType) -> ProtocolOnexSchema', \"async validate_against_schema(data: 'ProtocolOnexContractData', schema: 'ProtocolOnexSchema') -> ProtocolOnexValidationResult\", \"generate_validation_report(results: list['ProtocolOnexValidationResult']) -> ProtocolOnexValidationReport\", \"is_production_ready(validation_results: list['ProtocolOnexValidationResult']) -> bool\"], signature_hash='0f1d573f6cf6f3d7', line_count=14, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=98, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for Onex validation and compliance checking.\\n\\n    All ONEX tools must implement this protocol for Onex pattern validation.\\n    Provides standardized validation for envelopes, replies, and contract compliance.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['error_message() -> str | None'], signature_hash='599905a66343b975', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=45, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool'], base_protocols=[], protocol_type='functional', docstring='Base protocol for all memory operation responses.')",
        "ProtocolInfo(name='ProtocolMemoryRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"related_memories() -> list['ProtocolMemoryRecord']\"], signature_hash='23a60770d9a3c1f3', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=67, is_runtime_checkable=True, domain='memory', properties=[\"memory: 'ProtocolMemoryRecord | None'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolBatchOperationResult', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['execution_time_ms() -> int'], signature_hash='7015a3ae0035dc6a', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=87, is_runtime_checkable=True, domain='memory', properties=['operation_index: int', 'success: bool', 'result_id: UUID | None', \"error: 'ProtocolMemoryError | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for individual batch operation results.')",
        "ProtocolInfo(name='ProtocolBatchMemoryStoreResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['partial_success() -> bool'], signature_hash='1506c0dbd32ccb3a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=102, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolBatchOperationResult']\", 'total_processed: int', 'successful_count: int', 'failed_count: int', 'batch_execution_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for batch memory storage responses.')",
        "ProtocolInfo(name='ProtocolSemanticSearchResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async query_embedding() -> list[float] | None'], signature_hash='47a7415708d3b6bd', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=128, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolSearchResult']\", 'total_matches: int', 'search_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for semantic search responses.')",
        "ProtocolInfo(name='ProtocolPatternAnalysisResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['confidence_scores() -> list[float]'], signature_hash='b9aef8dcc783f286', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=142, is_runtime_checkable=True, domain='memory', properties=['patterns_found: int', \"analysis_results: 'ProtocolAnalysisResults'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for pattern analysis responses.')",
        "ProtocolInfo(name='ProtocolWorkflowExecutionResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"agent_statuses() -> 'ProtocolAgentStatusMap'\"], signature_hash='f1eaa662fe533e24', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=180, is_runtime_checkable=True, domain='memory', properties=['workflow_id: UUID', 'execution_status: str'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for workflow execution responses.')",
        "ProtocolInfo(name='ProtocolAgentCoordinationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"agent_responses() -> 'ProtocolAgentResponseMap'\"], signature_hash='1aae9ac4c21ec107', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=193, is_runtime_checkable=True, domain='memory', properties=['coordination_id: UUID', 'coordination_status: str'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for agent coordination responses.')",
        "ProtocolInfo(name='ProtocolPaginationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[\"page_info() -> 'ProtocolPageInfo'\"], signature_hash='c0c5189e2eb4250d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=206, is_runtime_checkable=True, domain='memory', properties=['total_count: int', 'has_next_page: bool', 'has_previous_page: bool', 'next_cursor: str | None', 'previous_cursor: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for paginated response metadata.')",
        "ProtocolInfo(name='ProtocolMemoryMetrics', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['throughput_ops_per_second() -> float', 'error_rate_percent() -> float', \"custom_metrics() -> 'ProtocolCustomMetrics'\"], signature_hash='e4fee6766ba520a7', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=222, is_runtime_checkable=True, domain='memory', properties=['operation_type: str', 'execution_time_ms: int', 'memory_usage_mb: float', \"timestamp: 'datetime'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for memory system performance metrics.')",
        "ProtocolInfo(name='ProtocolStreamingMemoryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async stream_content() -> AsyncIterator[bytes]', 'compression_ratio() -> float | None'], signature_hash='ec8c1b6faa676117', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=256, is_runtime_checkable=True, domain='memory', properties=['stream_id: UUID', 'chunk_count: int', 'total_size_bytes: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='functional', docstring='Protocol for streaming memory operation responses.')",
        "ProtocolInfo(name='ProtocolStreamingRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=['async stream_memory_content(memory_id: UUID) -> AsyncIterator[bytes]'], signature_hash='09f26d5797860c26', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=274, is_runtime_checkable=True, domain='memory', properties=[\"memory_metadata: list['ProtocolMemoryRecord']\"], base_protocols=['ProtocolStreamingMemoryResponse'], protocol_type='functional', docstring='Protocol for streaming memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolKeyValueStore', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['keys() -> list[str]', 'async get_value(key: str) -> str | None', 'has_key(key: str) -> bool', 'async validate_store() -> bool'], signature_hash='ac1b1a6e880a7f1f', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=40, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Base protocol for key-value storage structures with validation.')",
        "ProtocolInfo(name='ProtocolCoordinationMetadata', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metadata_keys() -> list[str]', 'async get_metadata_value(key: str) -> str | None', 'async validate_metadata() -> bool'], signature_hash='49fe1ed42efa7947', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=134, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for coordination metadata structures.')",
        "ProtocolInfo(name='ProtocolAnalysisResults', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['result_keys() -> list[str]', 'async get_result_value(key: str) -> str | None', 'has_result_key(key: str) -> bool'], signature_hash='250df27571aff957', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=152, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for analysis result structures.')",
        "ProtocolInfo(name='ProtocolAggregatedData', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['data_keys() -> list[str]', 'async get_data_value(key: str) -> str | None', 'async validate_data() -> bool'], signature_hash='0346848e77855909', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=170, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for aggregated data structures.')",
        "ProtocolInfo(name='ProtocolMemoryErrorContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['context_keys() -> list[str]', 'async get_context_value(key: str) -> str | None', 'add_context(key: str, value: str) -> None'], signature_hash='b3f4da92cfd5cfa3', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=188, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for error context structures.')",
        "ProtocolInfo(name='ProtocolPageInfo', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['info_keys() -> list[str]', 'async get_info_value(key: str) -> str | None', 'has_next_page() -> bool'], signature_hash='67c607fecb7047d1', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=206, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for pagination information structures.')",
        "ProtocolInfo(name='ProtocolCustomMetrics', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metric_names() -> list[str]', 'async get_metric_value(name: str) -> float | None', 'has_metric(name: str) -> bool'], signature_hash='bc0f2052ebede274', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=224, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for custom metrics structures.')",
        "ProtocolInfo(name='ProtocolAggregationSummary', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['summary_keys() -> list[str]', 'async get_summary_value(key: str) -> float | None', 'calculate_total() -> float', 'async validate_record_data() -> bool'], signature_hash='612ac2f3a9369af5', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=242, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for aggregation summary structures.')",
        "ProtocolInfo(name='ProtocolMemoryRecord', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['embedding() -> list[float] | None', 'related_memories() -> list[UUID]'], signature_hash='e1ccef920653da8f', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=267, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID', 'content: str', 'content_type: str', \"created_at: 'datetime'\", \"updated_at: 'datetime'\", 'access_level: LiteralMemoryAccessLevel', 'source_agent: str', \"expires_at: 'datetime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for memory record data structure.')",
        "ProtocolInfo(name='ProtocolSearchResult', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['highlighted_content() -> str | None'], signature_hash='b1d90daf0ba048ef', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=291, is_runtime_checkable=True, domain='memory', properties=[\"memory_record: 'ProtocolMemoryRecord'\", 'relevance_score: float', 'match_type: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for search result data structure.')",
        "ProtocolInfo(name='ProtocolSearchFilters', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['tags() -> list[str] | None'], signature_hash='9df61c28ab89700d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=305, is_runtime_checkable=True, domain='memory', properties=['content_types: list[str] | None', 'access_levels: list[str] | None', 'source_agents: list[str] | None', \"date_range_start: 'datetime | None'\", \"date_range_end: 'datetime | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for search filter specifications.')",
        "ProtocolInfo(name='ProtocolAgentStatusMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['agent_ids() -> list[UUID]', 'async get_agent_status(agent_id: UUID) -> str | None', 'async set_agent_status(agent_id: UUID, status: str) -> None', 'async get_all_statuses() -> dict[UUID, str]'], signature_hash='9397aa791b6dc543', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=321, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for agent status mapping structures.')",
        "ProtocolInfo(name='ProtocolAgentResponseMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['responding_agents() -> list[UUID]', 'async get_agent_response(agent_id: UUID) -> str | None', 'add_agent_response(agent_id: UUID, response: str) -> None', 'async get_all_responses() -> dict[UUID, str]'], signature_hash='77579e967fda063a', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=343, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for agent response mapping structures.')",
        "ProtocolInfo(name='ProtocolErrorCategoryMap', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['category_names() -> list[str]', 'async get_category_count(category: str) -> int', 'increment_category(category: str) -> None', 'async get_all_counts() -> dict[str, int]'], signature_hash='99b3c714fee57796', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=365, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for error category counting structures.')",
        "ProtocolInfo(name='ProtocolWorkflowManager', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async execute_workflow(request: 'ProtocolWorkflowExecutionRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolWorkflowExecutionResponse'\", \"async pause_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async resume_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async cancel_workflow(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async get_workflow_status(workflow_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='6b909b2ff4348696', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=29, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for workflow management operations.\\n\\n    Handles workflow execution, monitoring, and lifecycle management\\n    without agent coordination complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolAgentCoordinator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async coordinate_agents(request: 'ProtocolAgentCoordinationRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolAgentCoordinationResponse'\", \"async register_agent(agent_id: UUID, agent_capabilities: list[str], agent_metadata: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async unregister_agent(agent_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async get_agent_status(agent_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async list_available_agents(capability_filter: list[str] | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='f16072fe301c0566', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=155, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for agent coordination operations.\\n\\n    Handles agent management, coordination, and communication\\n    without workflow execution complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolClusterCoordinator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async broadcast_update(update_type: str, update_data: 'ProtocolMemoryMetadata', target_nodes: list[UUID] | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async synchronize_state(node_ids: list[UUID], synchronization_scope: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async get_cluster_status(include_node_details: bool, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async perform_cluster_maintenance(maintenance_type: str, maintenance_parameters: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='17f282a5212e4f95', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=285, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for cluster-wide coordination operations.\\n\\n    Handles distributed memory operations, synchronization, and\\n    cluster state management.\\n    ')",
        "ProtocolInfo(name='ProtocolLifecycleManager', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async apply_retention_policies(policy_scope: 'ProtocolMemoryMetadata', dry_run: bool, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async archive_memories(memory_ids: list[UUID], archive_destination: str, archive_format: str, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async cleanup_expired_memories(cleanup_scope: 'ProtocolMemoryMetadata', safety_threshold_hours: int, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async restore_archived_memories(archive_reference: str, restore_destination: str | None, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='9b9866f31c5a3800', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=401, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Focused interface for memory lifecycle management operations.\\n\\n    Handles memory retention policies, archival, and cleanup\\n    without orchestration complexity.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryOrchestrator', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async health_check(check_scope: str, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='73e2ffc28de7cf0e', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=525, is_runtime_checkable=True, domain='memory', properties=[\"workflow_manager: 'ProtocolWorkflowManager'\", \"agent_coordinator: 'ProtocolAgentCoordinator'\", \"cluster_coordinator: 'ProtocolClusterCoordinator'\", \"lifecycle_manager: 'ProtocolLifecycleManager'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Composite interface combining all orchestration capabilities.\\n\\n    This interface can be implemented by combining the smaller focused\\n    interfaces above, or implemented directly for comprehensive orchestration.\\n    ')",
        "ProtocolInfo(name='ProtocolComputeNodeComposite', file_path='src/omnibase_spi/protocols/memory/protocol_memory_composable.py', module_path='omnibase_spi.protocols.memory.protocol_memory_composable', methods=[\"async process_semantics(content: str, processing_options: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async analyze_patterns(data_source: 'ProtocolMemoryMetadata', analysis_type: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async generate_embeddings(content_items: list[str], embedding_model: str | None, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='d16e85c559c27180', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_requests.ProtocolAgentCoordinationRequest', 'protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'protocol_memory_responses.ProtocolAgentCoordinationResponse', 'protocol_memory_responses.ProtocolMemoryResponse', 'protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=563, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Composite interface that can split compute operations into focused areas.\\n\\n    Allows implementation as separate semantic processing, pattern analysis,\\n    and embedding generation services that can be coordinated independently.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['operation_type() -> str'], signature_hash='00530f390437b78f', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=40, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"request_timestamp: 'datetime'\"], base_protocols=[], protocol_type='functional', docstring='Base protocol for all memory operation requests.')",
        "ProtocolInfo(name='ProtocolMemoryStoreRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"metadata() -> 'ProtocolMemoryMetadata | None'\"], signature_hash='4e2023dde9aee1f3', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=53, is_runtime_checkable=True, domain='memory', properties=['content: str', 'content_type: str', 'access_level: str', 'source_agent: str', \"expires_at: 'datetime | None'\"], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for memory storage requests.')",
        "ProtocolInfo(name='ProtocolMemoryRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['related_depth() -> int'], signature_hash='b0a03098fdbd50aa', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=69, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID', 'include_related: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolMemoryListRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['include_content() -> bool'], signature_hash='bdea28e77b495260', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=83, is_runtime_checkable=True, domain='memory', properties=[\"pagination: 'ProtocolPaginationRequest'\", \"filters: 'ProtocolSearchFilters | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for paginated memory list requests.')",
        "ProtocolInfo(name='ProtocolBatchMemoryStoreRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['transaction_isolation() -> str', 'parallel_execution() -> bool'], signature_hash='8e6446af0573ecc5', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=97, is_runtime_checkable=True, domain='memory', properties=[\"memory_records: list['ProtocolAggregatedData']\", 'batch_size: int', 'fail_on_first_error: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for batch memory storage requests.')",
        "ProtocolInfo(name='ProtocolBatchMemoryRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['related_depth() -> int'], signature_hash='4935f4f8a409577b', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=117, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'include_related: bool', 'fail_on_missing: bool', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for batch memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolSemanticSearchRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['embedding_model() -> str | None'], signature_hash='e84a3075135c054d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=132, is_runtime_checkable=True, domain='memory', properties=['query: str', 'limit: int', 'similarity_threshold: float', \"filters: 'ProtocolSearchFilters | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for semantic search requests.')",
        "ProtocolInfo(name='ProtocolPatternAnalysisRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"analysis_parameters() -> 'ProtocolAnalysisParameters'\"], signature_hash='c851cce0aa698593', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=148, is_runtime_checkable=True, domain='memory', properties=['data_source: str', \"analysis_type: 'LiteralAnalysisType'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for pattern analysis requests.')",
        "ProtocolInfo(name='ProtocolWorkflowExecutionRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['async target_agents() -> list[UUID]'], signature_hash='c30c0d5affbb8144', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=190, is_runtime_checkable=True, domain='memory', properties=['workflow_type: str', \"workflow_configuration: 'ProtocolWorkflowConfiguration'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for workflow execution requests.')",
        "ProtocolInfo(name='ProtocolAgentCoordinationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[\"coordination_metadata() -> 'ProtocolCoordinationMetadata'\"], signature_hash='67a9c21068b8d46a', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=204, is_runtime_checkable=True, domain='memory', properties=['agent_ids: list[UUID]', 'coordination_task: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for agent coordination requests.')",
        "ProtocolInfo(name='ProtocolPaginationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['sort_by() -> str | None', 'sort_order() -> str'], signature_hash='b5511d52f55c9235', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=218, is_runtime_checkable=True, domain='memory', properties=['limit: int', 'offset: int', 'cursor: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for paginated request parameters.')",
        "ProtocolInfo(name='ProtocolMemoryMetricsRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['include_detailed_breakdown() -> bool'], signature_hash='c2e40d3bed8bf607', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=237, is_runtime_checkable=True, domain='memory', properties=['metric_types: list[str]', \"time_window_start: 'datetime | None'\", \"time_window_end: 'datetime | None'\", 'aggregation_level: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for metrics collection requests.')",
        "ProtocolInfo(name='ProtocolStreamingMemoryRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['compression_enabled() -> bool'], signature_hash='2b2a141de9a04f6c', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=253, is_runtime_checkable=True, domain='memory', properties=['stream_type: str', 'chunk_size: int', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='functional', docstring='Protocol for streaming memory operations.')",
        "ProtocolInfo(name='ProtocolStreamingRetrieveRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=['max_content_size() -> int | None'], signature_hash='7cf2b5b8869627f7', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=267, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'include_metadata: bool'], base_protocols=['ProtocolStreamingMemoryRequest'], protocol_type='functional', docstring='Protocol for streaming memory retrieval requests.')",
        "ProtocolInfo(name='ProtocolMemoryEffectNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async store_memory(request: 'ProtocolMemoryStoreRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryStoreResponse'\", \"async retrieve_memory(request: 'ProtocolMemoryRetrieveRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryRetrieveResponse'\", \"async update_memory(memory_id: UUID, updates: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async delete_memory(memory_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async list_memories(request: 'ProtocolMemoryListRequest', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryListResponse'\", \"async batch_store_memories(request: 'ProtocolBatchMemoryStoreRequest', security_context: 'ProtocolMemorySecurityContext | None', rate_limit_config: 'ProtocolRateLimitConfig | None', timeout_seconds: float | None) -> 'ProtocolBatchMemoryStoreResponse'\", \"async batch_retrieve_memories(request: 'ProtocolBatchMemoryRetrieveRequest', security_context: 'ProtocolMemorySecurityContext | None', rate_limit_config: 'ProtocolRateLimitConfig | None', timeout_seconds: float | None) -> 'ProtocolBatchMemoryRetrieveResponse'\"], signature_hash='13fe2e2d1e420133', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=59, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory effect operations in ONEX architecture.\\n\\n    Handles storage, retrieval, and persistence of memory records\\n    with transactional guarantees and consistency management.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryComputeNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async semantic_search(request: 'ProtocolSemanticSearchRequest') -> 'ProtocolSemanticSearchResponse'\", \"async generate_embedding(text: str, model: str | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async analyze_patterns(request: 'ProtocolPatternAnalysisRequest', timeout_seconds: float | None) -> 'ProtocolPatternAnalysisResponse'\", \"async extract_insights(memory_ids: list[UUID], analysis_type: 'LiteralAnalysisType', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async compare_semantics(content_a: str, content_b: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='cc5e7cecf45b38b4', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=250, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory compute operations in ONEX architecture.\\n\\n    Handles intelligence processing, semantic analysis, and pattern recognition\\n    with advanced AI capabilities and embedding generation.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryReducerNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async consolidate_memories(request: 'ProtocolConsolidationRequest', timeout_seconds: float | None) -> 'ProtocolConsolidationResponse'\", \"async deduplicate_memories(memory_scope: 'ProtocolMemoryMetadata', similarity_threshold: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async aggregate_data(aggregation_criteria: 'ProtocolAggregationCriteria', time_window_start: str | None, time_window_end: str | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async compress_memories(memory_ids: list[UUID], compression_algorithm: 'LiteralCompressionAlgorithm', quality_threshold: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async optimize_storage(optimization_strategy: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='b489809eb2b56e76', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=366, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory reducer operations in ONEX architecture.\\n\\n    Handles memory consolidation, aggregation, and optimization\\n    with data reduction and compression capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryOrchestratorNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async execute_workflow(request: 'ProtocolWorkflowExecutionRequest', timeout_seconds: float | None) -> 'ProtocolWorkflowExecutionResponse'\", \"async coordinate_agents(request: 'ProtocolAgentCoordinationRequest', timeout_seconds: float | None) -> 'ProtocolAgentCoordinationResponse'\", \"async broadcast_update(update_type: str, update_data: 'ProtocolMemoryMetadata', target_agents: list[UUID] | None, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async synchronize_state(agent_ids: list[UUID], synchronization_scope: 'ProtocolMemoryMetadata', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\", \"async manage_lifecycle(lifecycle_policies: 'ProtocolMemoryMetadata', correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryResponse'\"], signature_hash='bb418eb2a4f7bc41', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=491, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory orchestrator operations in ONEX architecture.\\n\\n    Handles workflow coordination, agent management, and distributed\\n    memory operations across the entire ONEX cluster.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryHealthNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_operations.py', module_path='omnibase_spi.protocols.memory.protocol_memory_operations', methods=[\"async check_health(correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\", \"async collect_metrics(request: 'ProtocolMemoryMetricsRequest') -> 'ProtocolMemoryMetricsResponse'\", \"async get_status(include_detailed: bool, correlation_id: UUID | None) -> 'ProtocolMemoryResponse'\"], signature_hash='9a9ecf5b60282761', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralAnalysisType', 'omnibase_spi.protocols.memory.protocol_memory_base.LiteralCompressionAlgorithm', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolAggregationCriteria', 'omnibase_spi.protocols.memory.protocol_memory_base.ProtocolMemoryMetadata', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolAgentCoordinationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolBatchMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolConsolidationRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryListRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryMetricsRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryRetrieveRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolMemoryStoreRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolPatternAnalysisRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolSemanticSearchRequest', 'omnibase_spi.protocols.memory.protocol_memory_requests.ProtocolWorkflowExecutionRequest', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolAgentCoordinationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolBatchMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolConsolidationResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryListResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryMetricsResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryRetrieveResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolMemoryStoreResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolPatternAnalysisResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolSemanticSearchResponse', 'omnibase_spi.protocols.memory.protocol_memory_responses.ProtocolWorkflowExecutionResponse', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolMemorySecurityContext', 'omnibase_spi.protocols.memory.protocol_memory_security.ProtocolRateLimitConfig'], line_number=614, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for memory health monitoring and system observability.\\n\\n    Provides health checks, metrics collection, and system status\\n    monitoring across all memory nodes.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=[\"error_context() -> 'ProtocolMemoryErrorContext'\", 'recoverable() -> bool', 'retry_strategy() -> str | None'], signature_hash='d2e8036e9c6eb99f', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=35, is_runtime_checkable=True, domain='memory', properties=['error_code: str', 'error_message: str', \"error_timestamp: 'datetime'\", 'correlation_id: UUID | None', 'error_category: LiteralErrorCategory'], base_protocols=[], protocol_type='functional', docstring='Protocol for standardized memory operation errors.')",
        "ProtocolInfo(name='ProtocolMemoryErrorResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'retry_after_seconds() -> int | None'], signature_hash='0609454bef4723f1', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=61, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', \"error: 'ProtocolMemoryError'\", 'suggested_action: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for error responses from memory operations.')",
        "ProtocolInfo(name='ProtocolMemoryValidationError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['invalid_fields() -> list[str]'], signature_hash='57ff53c7110c5d62', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=82, is_runtime_checkable=True, domain='memory', properties=['validation_failures: list[str]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory validation errors.')",
        "ProtocolInfo(name='ProtocolMemoryAuthorizationError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['missing_permissions() -> list[str]'], signature_hash='8aa7b11c77575821', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=94, is_runtime_checkable=True, domain='memory', properties=['required_permissions: list[str]', 'user_permissions: list[str]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory authorization errors.')",
        "ProtocolInfo(name='ProtocolMemoryNotFoundError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['async search_suggestions() -> list[str]'], signature_hash='a03d69802b284022', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=107, is_runtime_checkable=True, domain='memory', properties=['requested_memory_id: UUID', 'suggested_alternatives: list[UUID]'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory not found errors.')",
        "ProtocolInfo(name='ProtocolMemoryTimeoutError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['progress_percentage() -> float | None'], signature_hash='d343b40cc4db24ef', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=120, is_runtime_checkable=True, domain='memory', properties=['timeout_seconds: float', 'operation_type: str', 'partial_results: str | None'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory operation timeout errors.')",
        "ProtocolInfo(name='ProtocolMemoryCapacityError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['usage_percentage() -> float'], signature_hash='250c31a2214ffeb6', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=134, is_runtime_checkable=True, domain='memory', properties=['resource_type: str', 'current_usage: float', 'maximum_capacity: float'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory capacity/resource errors.')",
        "ProtocolInfo(name='ProtocolMemoryCorruptionError', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['async backup_available() -> bool'], signature_hash='eea1c9a64d9bf361', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=148, is_runtime_checkable=True, domain='memory', properties=['corruption_type: str', 'affected_memory_ids: list[UUID]', 'recovery_possible: bool'], base_protocols=['ProtocolMemoryError'], protocol_type='functional', docstring='Protocol for memory corruption/integrity errors.')",
        "ProtocolInfo(name='ProtocolErrorRecoveryStrategy', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['success_probability() -> float', 'async execute_recovery() -> bool'], signature_hash='d2b263fc86ec6dea', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=162, is_runtime_checkable=True, domain='memory', properties=['strategy_type: str', 'recovery_steps: list[str]', 'estimated_recovery_time: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery strategies.')",
        "ProtocolInfo(name='ProtocolMemoryErrorRecoveryResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'recovery_details() -> str | None'], signature_hash='fe991153c7c51868', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=180, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', 'recovery_attempted: bool', 'recovery_successful: bool', \"recovery_strategy: 'ProtocolErrorRecoveryStrategy | None'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for error recovery operation responses.')",
        "ProtocolInfo(name='ProtocolBatchErrorSummary', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['failure_rate() -> float', 'most_common_error() -> str | None'], signature_hash='c40c5e4fd40f838b', line_count=5, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=202, is_runtime_checkable=True, domain='memory', properties=['total_operations: int', 'failed_operations: int', \"error_categories: 'ProtocolErrorCategoryMap'\"], base_protocols=[], protocol_type='functional', docstring='Protocol for batch operation error summaries.')",
        "ProtocolInfo(name='ProtocolBatchErrorResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_errors.py', module_path='omnibase_spi.protocols.memory.protocol_memory_errors', methods=['error_message() -> str | None', 'retry_after_seconds() -> int | None', 'partial_success_recovery() -> ProtocolErrorRecoveryStrategy | None'], signature_hash='00e5b4036f3019fb', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.LiteralErrorCategory', 'datetime.datetime', 'protocol_memory_base.ProtocolErrorCategoryMap', 'protocol_memory_base.ProtocolMemoryErrorContext'], line_number=221, is_runtime_checkable=True, domain='memory', properties=['correlation_id: UUID | None', \"response_timestamp: 'datetime'\", 'success: bool', \"error: 'ProtocolMemoryError'\", 'suggested_action: str', \"batch_summary: 'ProtocolBatchErrorSummary'\", \"individual_errors: list['ProtocolMemoryError']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for batch operation error responses.')",
        "ProtocolInfo(name='ProtocolErrorCategory', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['error_type() -> str', 'error_code() -> str', 'error_severity() -> str', 'is_recoverable() -> bool', 'recovery_strategy() -> str', 'requires_user_intervention() -> bool', 'compliance_impact() -> str | None'], signature_hash='f29ebce5442f398e', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=20, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Error category classification for memory operations.\\n\\n    Categorizes errors as transient, permanent, security, validation,\\n    or infrastructure to enable appropriate error handling strategies.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryRetryPolicy', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['max_retries() -> int', 'initial_delay_seconds() -> float', 'backoff_strategy() -> str', 'backoff_multiplier() -> float', 'max_delay_seconds() -> float', 'jitter_enabled() -> bool', 'retry_on_error_types() -> list[str]', 'circuit_breaker_enabled() -> bool', 'circuit_breaker_threshold() -> int'], signature_hash='0f7d1d87feeaab84', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=65, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Retry policy configuration for memory operation error recovery.\\n\\n    Defines retry behavior, backoff strategies, and retry limits\\n    for different types of memory operations and error conditions.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryCompensationAction', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['action_id() -> UUID', 'action_type() -> str', 'target_operation_id() -> UUID', 'compensation_order() -> int', 'is_idempotent() -> bool', 'timeout_seconds() -> float', \"action_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='46b4f75906cb7421', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=120, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Compensation action for failed operations.\\n\\n    Defines rollback, cleanup, and compensation actions to maintain\\n    data consistency when operations fail partially or completely.\\n    ')",
        "ProtocolInfo(name='ProtocolOperationContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=['operation_id() -> UUID', 'operation_type() -> str', 'parent_operation_id() -> UUID | None', 'correlation_id() -> UUID', \"started_at() -> 'datetime'\", \"timeout_at() -> 'datetime | None'\", 'dependencies() -> list[UUID]', \"compensation_actions() -> list['ProtocolMemoryCompensationAction']\", \"operation_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='679ac57ecd4f62b8', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=165, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Context information for operation tracking and error recovery.\\n\\n    Maintains operation state, dependencies, and recovery information\\n    for comprehensive error handling and rollback capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryErrorHandler', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=[\"async categorize_error(error: Exception, operation_context: 'ProtocolOperationContext', correlation_id: UUID | None) -> 'ProtocolErrorCategory'\", \"async should_retry_operation(error_category: 'ProtocolErrorCategory', retry_policy: 'ProtocolMemoryRetryPolicy', current_attempt: int, operation_context: 'ProtocolOperationContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async execute_retry(operation_context: 'ProtocolOperationContext', retry_policy: 'ProtocolMemoryRetryPolicy', retry_attempt: int, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async execute_compensation_actions(operation_context: 'ProtocolOperationContext', compensation_actions: list['ProtocolMemoryCompensationAction'], correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async create_error_report(error: Exception, error_category: 'ProtocolErrorCategory', operation_context: 'ProtocolOperationContext', recovery_actions: list[str], correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async handle_circuit_breaker(operation_type: str, error_rate: float, failure_threshold: int, time_window_seconds: int, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async recover_from_partial_failure(operation_context: 'ProtocolOperationContext', successful_operations: list[UUID], failed_operations: list[UUID], recovery_strategy: str, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='3c35d243e71f85ea', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=220, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Error handling and recovery for memory operations.\\n\\n    Provides comprehensive error categorization, retry handling,\\n    compensation execution, and error reporting capabilities.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryHealthMonitor', file_path='src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py', module_path='omnibase_spi.protocols.memory.protocol_memory_error_handling', methods=[\"async monitor_operation_health(operation_types: list[str], monitoring_window_minutes: int, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async detect_degradation_patterns(metric_types: list[str], baseline_period_hours: int, detection_sensitivity: float, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async generate_early_warning(warning_type: str, severity_level: str, affected_operations: list[str], warning_metadata: 'ProtocolMemoryMetadata', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async create_health_dashboard(dashboard_scope: str, time_window_hours: int, correlation_id: UUID | None, timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='a0b3323d0e28ed0f', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=411, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Health monitoring and early warning system for memory operations.\\n\\n    Monitors system health, detects degradation patterns, and provides\\n    early warnings to prevent cascading failures.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingChunk', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['chunk_id() -> UUID', 'stream_id() -> UUID', 'sequence_number() -> int', 'total_chunks() -> int | None', 'chunk_data() -> bytes', 'chunk_size() -> int', 'is_final_chunk() -> bool', 'checksum() -> str', 'compression_type() -> str | None', \"chunk_metadata() -> 'ProtocolMemoryMetadata'\"], signature_hash='031655173c749925', line_count=10, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=19, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for streaming data chunks.\\n\\n    Represents individual chunks in a streaming operation with\\n    metadata for reconstruction and error handling.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingConfig', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['chunk_size_bytes() -> int', 'max_concurrent_chunks() -> int', 'buffer_size_mb() -> float', 'compression_enabled() -> bool', 'compression_level() -> int', 'timeout_per_chunk_seconds() -> float', 'retry_failed_chunks() -> bool', 'max_retries_per_chunk() -> int', 'enable_checksum_validation() -> bool'], signature_hash='c1cf4cb1c49f29b5', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=79, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Configuration for streaming operations.\\n\\n    Defines parameters for chunking, compression, buffering,\\n    and streaming behavior optimization.\\n    ')",
        "ProtocolInfo(name='ProtocolCursorPagination', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=['cursor() -> str | None', 'limit() -> int', 'sort_field() -> str', 'sort_direction() -> str', \"filters() -> 'ProtocolMemoryMetadata'\", 'include_total_count() -> bool'], signature_hash='76a9f813254e884d', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=134, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Cursor-based pagination for large datasets.\\n\\n    Provides efficient pagination for large memory collections\\n    with stable ordering and consistent performance.\\n    ')",
        "ProtocolInfo(name='ProtocolStreamingMemoryNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async stream_memory_content(memory_id: UUID, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator['ProtocolStreamingChunk', None]\", \"async upload_memory_stream(content_stream: AsyncGenerator['ProtocolStreamingChunk', None], target_memory_id: UUID, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async paginate_memories_cursor(pagination_config: 'ProtocolCursorPagination', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async stream_search_results(search_query: str, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator[ProtocolMemoryMetadata, None]\", \"async compress_memory_content(memory_id: UUID, compression_algorithm: str, compression_level: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async decompress_memory_content(memory_id: UUID, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async stream_embedding_vectors(memory_ids: list[UUID], vector_chunk_size: int, compression_enabled: bool, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> AsyncGenerator['ProtocolStreamingChunk', None]\", \"async batch_upload_embedding_vectors(vector_stream: AsyncGenerator['ProtocolStreamingChunk', None], target_memory_ids: list[UUID], vector_dimensions: int, streaming_config: 'ProtocolStreamingConfig', security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='7a831da04d1dcf44', line_count=8, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=174, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Streaming operations for memory content processing.\\n\\n    Handles large content streaming, chunked uploads/downloads,\\n    and cursor-based pagination for memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryCache', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async cache_memory(memory_id: UUID, cache_ttl_seconds: int, cache_level: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\", \"async invalidate_cache(memory_id: UUID, invalidation_scope: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\", \"async warm_cache(memory_ids: list[UUID], warming_strategy: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async get_cache_stats(cache_scope: str, security_context: 'ProtocolMemorySecurityContext | None') -> 'ProtocolMemoryMetadata'\"], signature_hash='4cb9fa04a3f33eec', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=403, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Caching protocol for memory operations performance optimization.\\n\\n    Provides intelligent caching with TTL, invalidation patterns,\\n    and cache warming strategies for memory access optimization.\\n    ')",
        "ProtocolInfo(name='ProtocolPerformanceOptimization', file_path='src/omnibase_spi/protocols/memory/protocol_memory_streaming.py', module_path='omnibase_spi.protocols.memory.protocol_memory_streaming', methods=[\"async analyze_performance_patterns(operation_types: list[str], time_window_hours: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async optimize_memory_access_patterns(memory_ids: list[UUID], optimization_strategy: str, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\", \"async create_performance_baseline(operation_type: str, baseline_duration_hours: int, security_context: 'ProtocolMemorySecurityContext | None', timeout_seconds: float | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='ed0495936f8ca04d', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncGenerator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_security.ProtocolMemorySecurityContext'], line_number=507, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Performance optimization protocol for memory operations.\\n\\n    Provides performance monitoring, optimization suggestions,\\n    and automated optimization for memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemorySecurityContext', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['user_id() -> UUID | None', 'session_id() -> UUID | None', 'permissions() -> list[str]', 'access_level() -> str', 'audit_enabled() -> bool', 'rate_limit_key() -> str | None', 'pii_detection_enabled() -> bool'], signature_hash='253a5b9586d4a221', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=20, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Security context for memory operations.\\n\\n    Provides authentication, authorization, and audit trail information\\n    for all memory operations with sub-millisecond PII detection.\\n    ')",
        "ProtocolInfo(name='ProtocolAuditTrail', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['operation_id() -> UUID', 'operation_type() -> str', 'resource_id() -> UUID | None', 'user_id() -> UUID | None', \"timestamp() -> 'datetime'\", 'source_ip() -> str | None', 'user_agent() -> str | None', \"operation_metadata() -> 'ProtocolMemoryMetadata'\", 'compliance_tags() -> list[str]'], signature_hash='1bd648fbd30404ff', line_count=9, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=65, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Audit trail information for compliance and security monitoring.\\n\\n    Captures detailed operation logs for security analysis and compliance\\n    reporting with comprehensive event tracking.\\n    ')",
        "ProtocolInfo(name='ProtocolRateLimitConfig', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['requests_per_minute() -> int', 'requests_per_hour() -> int', 'burst_limit() -> int', 'batch_size_limit() -> int', 'data_size_limit_mb() -> float', 'concurrent_operations_limit() -> int'], signature_hash='602b66cd6e896d8a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=120, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Rate limiting configuration for memory operations.\\n\\n    Defines rate limits and throttling policies to prevent abuse\\n    and ensure fair resource utilization.\\n    ')",
        "ProtocolInfo(name='ProtocolInputValidation', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=['max_content_length() -> int', 'allowed_content_types() -> list[str]', 'forbidden_patterns() -> list[str]', 'require_sanitization() -> bool', 'pii_detection_threshold() -> float', 'encoding_requirements() -> list[str]'], signature_hash='4760b757c2040e8a', line_count=6, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=160, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Input validation requirements for memory operations.\\n\\n    Defines validation rules and sanitization requirements for\\n    all memory operation inputs to prevent injection attacks.\\n    ')",
        "ProtocolInfo(name='ProtocolMemorySecurityNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=[\"async validate_access(security_context: 'ProtocolMemorySecurityContext', operation_type: str, resource_id: UUID | None, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async detect_pii(content: str, detection_threshold: float, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async validate_input(input_data: 'ProtocolMemoryMetadata', validation_config: 'ProtocolInputValidation', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async check_rate_limits(security_context: 'ProtocolMemorySecurityContext', operation_type: str, rate_limit_config: 'ProtocolRateLimitConfig', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async create_audit_trail(audit_info: 'ProtocolAuditTrail', security_context: 'ProtocolMemorySecurityContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async encrypt_sensitive_data(data: 'ProtocolMemoryMetadata', encryption_level: str, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async decrypt_sensitive_data(encrypted_data: 'ProtocolMemoryMetadata', security_context: 'ProtocolMemorySecurityContext', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='6291fe47d6c99db9', line_count=7, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=200, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Security validation and monitoring for memory operations.\\n\\n    Provides security validation, PII detection, access control,\\n    and audit trail management for all memory operations.\\n    ')",
        "ProtocolInfo(name='ProtocolMemoryComplianceNode', file_path='src/omnibase_spi/protocols/memory/protocol_memory_security.py', module_path='omnibase_spi.protocols.memory.protocol_memory_security', methods=[\"async validate_gdpr_compliance(operation_type: str, data_subject_id: UUID | None, legal_basis: str, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async validate_hipaa_compliance(operation_type: str, phi_categories: list[str], covered_entity_id: UUID, correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async generate_compliance_report(report_type: str, time_period_start: 'datetime', time_period_end: 'datetime', compliance_frameworks: list[str], correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\", \"async handle_data_subject_request(request_type: str, data_subject_id: UUID, request_details: 'ProtocolMemoryMetadata', correlation_id: UUID | None) -> 'ProtocolMemoryMetadata'\"], signature_hash='ae24bd135574581b', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.ProtocolMemoryMetadata'], line_number=370, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Compliance monitoring and enforcement for memory operations.\\n\\n    Ensures memory operations comply with regulatory requirements\\n    including GDPR, HIPAA, SOX, and other compliance frameworks.\\n    ')",
        "ProtocolInfo(name='ProtocolHandlerDiscovery', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[\"async discover_nodes() -> list['ProtocolHandlerInfo']\", 'get_source_name() -> str'], signature_hash='9536b27500805286', line_count=2, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=53, is_runtime_checkable=True, domain='file_handling', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for discovering file type nodes.\\n\\n    Implementations of this protocol can discover nodes from various sources\\n    (entry points, configuration files, environment variables, etc.) without\\n    requiring hardcoded imports in the core registry.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class EntryPointNodeDiscovery:\\n            @property\\n            def group_name(self) -> str: ...\\n\\n            @property\\n            def discovered_nodes(self) -> list[Any]: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from Python entry points\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        class ConfigFileNodeDiscovery:\\n            @property\\n            def config_path(self) -> Any: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from configuration file\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        class EnvironmentNodeDiscovery:\\n            @property\\n            def env_prefix(self) -> str: ...\\n\\n            async def discover_nodes(self) -> list[\"ProtocolHandlerInfo\"]:\\n                # Discover nodes from environment variables\\n                ...\\n\\n            def get_source_name(self) -> str:\\n                ...\\n\\n        # Usage in application\\n        registry: \"ProtocolNodeDiscoveryRegistry\" = NodeDiscoveryRegistryImpl()\\n\\n        # Register multiple discovery sources\\n        entry_point_discovery: \"ProtocolHandlerDiscovery\" = EntryPointNodeDiscovery(group_name=\"your.entry.point.group\")\\n        config_discovery: \"ProtocolHandlerDiscovery\" = ConfigFileNodeDiscovery(config_path=\"path/to/config.yaml\")\\n        env_discovery: \"ProtocolHandlerDiscovery\" = EnvironmentNodeDiscovery(env_prefix=\"YOUR_NODE_PREFIX_\")\\n\\n        registry.register_discovery_source(entry_point_discovery)\\n        registry.register_discovery_source(config_discovery)\\n        registry.register_discovery_source(env_discovery)\\n\\n        # Discover and register all nodes\\n        registry.discover_and_register_nodes()\\n\\n        # Print discovered nodes\\n        ...\\n        ```\\n\\n    Discovery Implementation Patterns:\\n        - Entry Points: Use setuptools entry points for plugin architecture\\n        - Configuration Files: YAML/JSON configuration with dynamic imports\\n        - Environment Variables: Runtime node registration via env vars\\n        - Directory Scanning: Automatic discovery from node directories\\n        - Metadata Caching: Cache node metadata for performance\\n        - Error Handling: Graceful fallback when nodes fail to load\\n    ')",
        "ProtocolInfo(name='ProtocolNodeDiscoveryRegistry', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[\"async register_discovery_source(discovery: 'ProtocolHandlerDiscovery') -> None\", 'async discover_and_register_nodes() -> None', \"async register_node_info(node_info: 'ProtocolHandlerInfo') -> None\"], signature_hash='70adf825b6dbfa40', line_count=3, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=148, is_runtime_checkable=True, domain='core', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for node registries that support dynamic discovery.\\n\\n    This protocol extends the basic node registry with discovery capabilities,\\n    allowing nodes to be registered from multiple sources without hardcoded imports.\\n        ...\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolRouter', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=[\"async select_tool_implementation(tool_name: str, parameters: dict[str, 'ContextValue'], routing_policy: str | None) -> ProtocolMCPToolDefinition | None\", \"async get_available_implementations(tool_name: str) -> list['ProtocolMCPToolDefinition']\", \"async check_implementation_health(tool_def: 'ProtocolMCPToolDefinition') -> bool\", 'async get_routing_statistics() -> dict[str, Any]'], signature_hash='3c9fecc2c0b5ba6a', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=23, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool routing and selection.\\n\\n    Handles intelligent routing of tool execution requests\\n    to appropriate subsystem implementations based on load,\\n    health, and routing policies.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolExecutor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=[\"async execute_tool(tool_def: 'ProtocolMCPToolDefinition', subsystem: 'ProtocolMCPSubsystemRegistration', parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID, timeout_seconds: int | None) -> dict[str, Any]\", \"async execute_with_retry(tool_def: 'ProtocolMCPToolDefinition', subsystem: 'ProtocolMCPSubsystemRegistration', parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID, max_retries: int | None) -> dict[str, Any]\", 'async cancel_execution(execution_id: str) -> bool', \"async get_execution_status(execution_id: str) -> 'LiteralMCPExecutionStatus | None'\"], signature_hash='f20a5ff7272f53bf', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=90, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool execution management.\\n\\n    Handles the actual execution of tools through HTTP proxying,\\n    including retry logic, timeout handling, and result processing.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolProxy', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy', methods=['router() -> ProtocolMCPToolRouter', 'executor() -> ProtocolMCPToolExecutor', \"async proxy_tool_execution(tool_name: str, parameters: dict[str, 'ContextValue'], correlation_id: UUID, timeout_seconds: int | None, routing_policy: str | None, preferred_subsystem: str | None) -> dict[str, Any]\", 'async proxy_batch_execution(requests: list[dict[str, Any]], correlation_id: UUID, max_parallel: int) -> list[dict[str, Any]]', \"async get_active_executions(tool_name: str | None) -> list['ProtocolMCPToolExecution']\", \"async get_execution_history(tool_name: str | None, subsystem_id: str | None, correlation_id: UUID | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async cancel_execution(execution_id: str) -> bool', 'async cancel_all_executions(tool_name: str | None, subsystem_id: str | None) -> int', 'async get_execution_metrics(time_range_hours: int, tool_name: str | None) -> dict[str, Any]', 'async get_load_balancing_stats() -> dict[str, Any]', 'async configure_caching(tool_name: str, cache_ttl_seconds: int, cache_key_fields: list[str]) -> bool', 'async clear_cache(tool_name: str | None) -> int', 'async validate_proxy_configuration() -> dict[str, Any]'], signature_hash='9c253e41b435b24b', line_count=13, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPExecutionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution'], line_number=180, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP tool proxy protocol for distributed tool execution.\\n\\n    Combines routing, execution, and result management to provide\\n    a complete tool proxy solution for the MCP registry system.\\n\\n    Key Features:\\n        - **Intelligent Routing**: Route tools to optimal subsystem implementations\\n        - **Load Balancing**: Distribute load across multiple implementations\\n        - **Fault Tolerance**: Handle failures with retry and failover logic\\n        - **Execution Tracking**: Track all tool executions with detailed metrics\\n        - **Performance Monitoring**: Monitor execution performance and success rates\\n        - **Cancellation Support**: Cancel long-running executions\\n        - **Result Caching**: Optional result caching for expensive operations\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistry', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['config() -> ProtocolMCPRegistryConfig', \"async register_subsystem(subsystem_metadata: Any, tools: list['ProtocolMCPToolDefinition'], api_key: str, configuration: dict[str, 'ContextValue'] | None) -> str\", 'async unregister_subsystem(registration_id: str) -> bool', \"async update_subsystem_heartbeat(registration_id: str, health_status: str | None, metadata: dict[str, 'ContextValue'] | None) -> bool\", 'async get_subsystem_registration(registration_id: str) -> ProtocolMCPSubsystemRegistration | None', \"async get_all_subsystems(subsystem_type: 'LiteralMCPSubsystemType | None', status_filter: 'LiteralOperationStatus | None') -> list['ProtocolMCPSubsystemRegistration']\", \"async discover_tools(tool_type: 'LiteralMCPToolType | None', tags: list[str] | None, subsystem_id: str | None) -> list['ProtocolMCPToolDefinition']\", 'async get_tool_definition(tool_name: str) -> ProtocolMCPToolDefinition | None', \"async get_all_tool_implementations(tool_name: str) -> list['ProtocolMCPToolDefinition']\", \"async execute_tool(tool_name: str, parameters: dict[str, 'ContextValue'], correlation_id: UUID, timeout_seconds: int | None, preferred_subsystem: str | None) -> dict[str, Any]\", 'async get_tool_execution(execution_id: str) -> ProtocolMCPToolExecution | None', \"async get_tool_executions(tool_name: str | None, subsystem_id: str | None, correlation_id: UUID | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async cancel_tool_execution(execution_id: str) -> bool', \"async validate_subsystem_registration(subsystem_metadata: Any, tools: list['ProtocolMCPToolDefinition']) -> ProtocolMCPValidationResult\", \"async validate_tool_parameters(tool_name: str, parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async perform_health_check(registration_id: str) -> ProtocolMCPHealthCheck', 'async get_subsystem_health(registration_id: str) -> ProtocolMCPHealthCheck | None', 'async cleanup_expired_registrations() -> int', \"async update_subsystem_configuration(registration_id: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async get_registry_status() -> ProtocolMCPRegistryStatus', 'async get_registry_metrics() -> ProtocolMCPRegistryMetrics'], signature_hash='4617f20bcacdc26c', line_count=21, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=35, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Core MCP registry protocol for distributed tool coordination.\\n\\n    Manages subsystem registration, tool discovery, and execution routing\\n    across multiple MCP-enabled subsystems in the ONEX ecosystem.\\n\\n    Key Features:\\n        - **Multi-Subsystem Coordination**: Register and coordinate multiple MCP subsystems\\n        - **Dynamic Tool Discovery**: Discover and route tools across registered subsystems\\n        - **Load Balancing**: Distribute tool execution across multiple implementations\\n        - **Health Monitoring**: Monitor subsystem health and handle failures gracefully\\n        - **Execution Tracking**: Track tool execution metrics and performance\\n        - **Security**: API key authentication and request validation\\n        - **TTL Management**: Automatic cleanup of expired registrations\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistryAdmin', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['async set_maintenance_mode(enabled: bool) -> bool', 'async force_subsystem_cleanup(registration_id: str) -> bool', \"async update_registry_configuration(configuration: dict[str, 'ContextValue']) -> bool\", 'async export_registry_state() -> dict[str, Any]', 'async import_registry_state(state_data: dict[str, Any]) -> bool', 'async get_system_diagnostics() -> dict[str, Any]'], signature_hash='3982cb436f41c70d', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=365, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Administrative protocol for MCP registry management.\\n\\n    Provides privileged operations for registry administration,\\n    configuration management, and system maintenance.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPRegistryMetricsOperations', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_registry', methods=['async get_execution_metrics(time_range_hours: int, tool_name: str | None, subsystem_id: str | None) -> dict[str, Any]', 'async get_performance_trends(metric_name: str, time_range_hours: int) -> dict[str, Any]', 'async get_error_analysis(time_range_hours: int) -> dict[str, Any]', 'async get_capacity_metrics() -> dict[str, Any]'], signature_hash='b11a172bf2c49b9f', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPToolType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryConfig', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryMetrics', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPRegistryStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=401, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for advanced MCP registry metrics and analytics.\\n\\n    Provides detailed performance metrics, trend analysis,\\n    and operational insights for the registry system.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPHealthMonitor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_monitor', methods=[\"async perform_health_check(subsystem: 'ProtocolMCPSubsystemRegistration', check_tools: bool) -> ProtocolMCPHealthCheck\", 'async monitor_subsystem_health(subsystem_id: str, interval_seconds: int, callback: Callable[[Any], Any] | None) -> bool', 'async stop_health_monitoring(subsystem_id: str) -> bool', 'async get_health_status(subsystem_id: str) -> ProtocolMCPHealthCheck | None', \"async get_health_history(subsystem_id: str, hours: int, limit: int) -> list['ProtocolMCPHealthCheck']\", 'async detect_health_anomalies(subsystem_id: str | None, time_window_hours: int) -> list[dict[str, Any]]'], signature_hash='84c98ec30d7dc313', line_count=6, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=19, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP health monitoring operations.\\n\\n    Handles health checks, status monitoring, and failure detection\\n    for MCP subsystems and registry components.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPMonitor', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_monitor', methods=['health_monitor() -> ProtocolMCPHealthMonitor', 'async start_comprehensive_monitoring(registry_config: dict[str, Any], monitoring_config: dict[str, Any] | None) -> bool', 'async stop_all_monitoring() -> bool', 'async collect_system_metrics(time_range_minutes: int) -> dict[str, Any]', 'async generate_alerts(alert_config: dict[str, Any] | None) -> list[dict[str, Any]]', 'async monitor_subsystem_performance(subsystem_id: str, interval_seconds: int, callback: Callable[[Any], Any] | None) -> bool', 'async analyze_performance_trends(subsystem_id: str | None, time_range_hours: int, metrics: list[str] | None) -> dict[str, Any]', 'async generate_health_report(time_range_hours: int, include_recommendations: bool) -> dict[str, Any]', 'async configure_alerting(alert_handlers: list[Callable[[Any], Any]], thresholds: dict[str, Any], escalation_rules: dict[str, Any] | None) -> bool', 'async get_monitoring_status() -> dict[str, Any]', 'async generate_dashboard_data(dashboard_config: dict[str, Any] | None) -> dict[str, Any]', 'async export_monitoring_data(format_type: str, time_range_hours: int, include_raw_data: bool) -> dict[str, Any]'], signature_hash='89a38814ec662176', line_count=12, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=120, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP monitoring protocol for system observability.\\n\\n    Provides complete monitoring capabilities including health monitoring,\\n    performance tracking, alerting, and operational dashboards.\\n\\n    Key Features:\\n        - **Comprehensive Health Monitoring**: Monitor all subsystems and tools\\n        - **Performance Metrics**: Track execution times, success rates, and throughput\\n        - **Intelligent Alerting**: Generate alerts based on thresholds and anomalies\\n        - **Dashboard Generation**: Create operational dashboards and reports\\n        - **Historical Analysis**: Analyze trends and patterns over time\\n        - **Automated Recovery**: Trigger automated recovery actions\\n        - **Multi-Level Monitoring**: Registry, subsystem, and tool-level monitoring\\n    ')",
        "ProtocolInfo(name='ProtocolMCPSubsystemClient', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client', methods=['config() -> ProtocolMCPSubsystemConfig', 'registration_id() -> str | None', \"lifecycle_state() -> 'LiteralMCPLifecycleState'\", \"async connection_status() -> 'LiteralMCPConnectionStatus'\", 'async register_subsystem() -> str', 'async unregister_subsystem() -> bool', 'async start_heartbeat(interval: int | None) -> bool', 'async stop_heartbeat() -> bool', \"async send_heartbeat(health_status: str | None, metadata: dict[str, 'ContextValue'] | None) -> bool\", \"async register_tool_handler(tool_name: str, handler: Callable[[dict[str, 'ContextValue']], dict[str, Any]]) -> bool\", 'async unregister_tool_handler(tool_name: str) -> bool', 'async get_registered_tools() -> list[str]', \"async execute_tool_locally(tool_name: str, parameters: dict[str, 'ContextValue'], execution_id: str, correlation_id: UUID) -> dict[str, Any]\", 'async validate_configuration() -> ProtocolValidationResult', \"async validate_tool_parameters(tool_name: str, parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async perform_local_health_check() -> ProtocolMCPHealthCheck', 'async get_subsystem_status() -> dict[str, Any]', \"async update_configuration(configuration: dict[str, 'ContextValue']) -> bool\", 'async get_registration_info() -> ProtocolMCPSubsystemRegistration | None', 'async test_registry_connection() -> bool', \"async get_tool_execution_history(tool_name: str | None, limit: int) -> list['ProtocolMCPToolExecution']\", 'async shutdown_gracefully(timeout_seconds: int) -> bool'], signature_hash='b03ffff027a793e1', line_count=22, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPConnectionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPLifecycleState', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=45, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    MCP subsystem client protocol for registry integration.\\n\\n    Provides the client-side interface for subsystems to register with\\n    and interact with the central MCP registry infrastructure.\\n\\n    Key Features:\\n        - **Automatic Registration**: Register subsystem and tools with central registry\\n        - **Heartbeat Management**: Maintain connection with periodic health updates\\n        - **Tool Handler Registration**: Register local handlers for tool execution\\n        - **Health Monitoring**: Perform local health checks and report status\\n        - **Configuration Validation**: Validate subsystem configuration before registration\\n        - **Error Recovery**: Handle connection failures and retry logic\\n        - **Lifecycle Management**: Manage subsystem lifecycle states\\n    ')",
        "ProtocolInfo(name='ProtocolMCPServiceDiscovery', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_discovery', methods=[\"async discover_mcp_services(service_type: 'LiteralMCPSubsystemType | None', timeout_seconds: int) -> list['ProtocolMCPDiscoveryInfo']\", \"async discover_registries(timeout_seconds: int) -> list['ProtocolMCPDiscoveryInfo']\", \"async register_service_for_discovery(service_info: 'ProtocolMCPDiscoveryInfo', ttl_seconds: int) -> bool\", 'async unregister_service_from_discovery(service_name: str) -> bool', \"async monitor_service_changes(callback: Callable[[Any], Any], service_type: 'LiteralMCPSubsystemType | None') -> bool\"], signature_hash='d6d98e508ca6e6f5', line_count=5, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPDiscoveryInfo', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=24, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP service discovery operations.\\n\\n    Handles discovery of MCP services across the network using\\n    various discovery mechanisms (DNS-SD, Consul, etcd, etc.).\\n    ')",
        "ProtocolInfo(name='ProtocolMCPDiscovery', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_discovery', methods=['service_discovery() -> ProtocolMCPServiceDiscovery', \"async discover_available_subsystems(service_type: 'LiteralMCPSubsystemType | None', health_check: bool, timeout_seconds: int) -> list['ProtocolMCPSubsystemRegistration']\", \"async discover_available_tools(service_type: 'LiteralMCPSubsystemType | None', tool_tags: list[str] | None, health_check: bool) -> dict[str, list[str]]\", 'async find_optimal_registry(criteria: dict[str, Any] | None, timeout_seconds: int) -> ProtocolMCPDiscoveryInfo | None', \"async coordinate_multi_registry(registries: list['ProtocolMCPDiscoveryInfo'], coordination_strategy: str) -> dict[str, Any]\", 'async monitor_network_changes(callback: Callable[[Any], Any], service_types: list[LiteralMCPSubsystemType] | None, change_types: list[str] | None) -> bool', 'async get_network_topology(include_health: bool) -> dict[str, Any]', \"async test_service_connectivity(service_info: 'ProtocolMCPDiscoveryInfo', test_tools: bool) -> dict[str, Any]\", \"async get_service_health_status(service_name: str) -> 'LiteralHealthStatus | None'\", \"async update_service_cache(force_refresh: bool, service_type: 'LiteralMCPSubsystemType | None') -> int\", \"async configure_discovery_backend(backend_type: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async get_discovery_statistics() -> dict[str, Any]'], signature_hash='d6eb496561939ced', line_count=12, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPSubsystemType', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPDiscoveryInfo', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration'], line_number=107, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP discovery protocol for distributed service coordination.\\n\\n    Provides complete discovery capabilities including service discovery,\\n    health monitoring, and automatic registry coordination.\\n\\n    Key Features:\\n        - **Multi-Protocol Discovery**: Support DNS-SD, Consul, etcd, and other backends\\n        - **Health-Aware Discovery**: Filter services based on health status\\n        - **Registry Selection**: Intelligent selection of optimal registry\\n        - **Multi-Registry Coordination**: Coordinate multiple registries with various strategies\\n        - **Change Monitoring**: Real-time monitoring of network changes\\n        - **Geographic Awareness**: Region and location-aware service discovery\\n        - **Load Balancing**: Distribute load across discovered services\\n    ')",
        "ProtocolInfo(name='ProtocolMCPToolValidator', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_validator', methods=[\"async validate_tool_definition(tool_def: 'ProtocolMCPToolDefinition') -> ProtocolMCPValidationResult\", \"async validate_tool_parameters(tool_def: 'ProtocolMCPToolDefinition', parameters: dict[str, 'ContextValue']) -> ProtocolValidationResult\", 'async validate_parameter_schema(schema: dict[str, Any]) -> ProtocolMCPValidationResult', \"async sanitize_parameters(tool_def: 'ProtocolMCPToolDefinition', parameters: dict[str, 'ContextValue']) -> dict[str, 'ContextValue']\"], signature_hash='ba5b53d8b4897860', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationError', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=25, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for MCP tool validation operations.\\n\\n    Handles validation of tool definitions, parameters,\\n    and execution requests for security and correctness.\\n    ')",
        "ProtocolInfo(name='ProtocolMCPValidator', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_validator', methods=['tool_validator() -> ProtocolMCPToolValidator', \"async validate_subsystem_registration(subsystem_metadata: 'ProtocolMCPSubsystemMetadata', tools: list['ProtocolMCPToolDefinition'], api_key: str) -> ProtocolMCPValidationResult\", \"async validate_execution_request(tool_name: str, parameters: dict[str, 'ContextValue'], subsystem_id: str | None) -> ProtocolValidationResult\", 'async validate_api_key(api_key: str, subsystem_id: str | None) -> bool', \"async validate_configuration(configuration: dict[str, 'ContextValue']) -> ProtocolMCPValidationResult\", 'async validate_network_access(base_url: str, endpoints: list[str]) -> ProtocolMCPValidationResult', \"async sanitize_subsystem_metadata(metadata: 'ProtocolMCPSubsystemMetadata') -> ProtocolMCPSubsystemMetadata\", \"async detect_security_issues(parameters: dict[str, 'ContextValue'], tool_definition: 'ProtocolMCPToolDefinition | None') -> list['ProtocolMCPValidationError']\", \"async validate_compatibility(subsystem_version: str, registry_version: str, tools: list['ProtocolMCPToolDefinition']) -> ProtocolMCPValidationResult\", \"async validate_performance_constraints(tools: list['ProtocolMCPToolDefinition'], expected_load: dict[str, Any] | None) -> ProtocolMCPValidationResult\", 'async get_validation_rules() -> dict[str, Any]', 'async update_validation_rules(rules: dict[str, Any]) -> bool'], signature_hash='9d60a58069452c27', line_count=12, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationError', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPValidationResult', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=97, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Comprehensive MCP validation protocol for all MCP operations.\\n\\n    Provides validation for subsystem registrations, tool definitions,\\n    execution parameters, and system configurations.\\n\\n    Key Features:\\n        - **Schema Validation**: Validate against JSON schemas and type definitions\\n        - **Security Validation**: Detect potential security issues in parameters\\n        - **Business Rule Validation**: Enforce business rules and constraints\\n        - **Performance Validation**: Check for performance-impacting configurations\\n        - **Compatibility Validation**: Ensure compatibility across versions\\n        - **Sanitization**: Clean and normalize input data\\n        - **Detailed Error Reporting**: Provide actionable error messages and suggestions\\n    ')",
        "ProtocolInfo(name='ProtocolToolDiscoveryService', file_path='src/omnibase_spi/protocols/mcp/protocol_tool_discovery_service.py', module_path='omnibase_spi.protocols.mcp.protocol_tool_discovery_service', methods=[\"resolve_tool_from_contract(metadata: 'ProtocolMetadata', registry: object, contract_path: str) -> 'ProtocolToolInstance'\", \"async discover_tool_class_from_module(module_path: str, tool_class_name: str) -> 'ProtocolToolClass'\", \"instantiate_tool_with_container(tool_class: 'ProtocolToolClass', container: object) -> 'ProtocolToolInstance'\", \"resolve_tool_from_registry(registry: object, tool_class_name: str) -> 'ProtocolToolInstance | None'\", 'build_module_path_from_contract(contract_path: str) -> str', 'async validate_module_path(module_path: str) -> bool', 'convert_class_name_to_registry_key(class_name: str) -> str'], signature_hash='fc6fae4cbb14f090', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolToolClass', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolToolInstance'], line_number=19, is_runtime_checkable=True, domain='mcp', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for tool discovery service operations.\\n\\n    Provides duck typing interface for tool class discovery, validation,\\n    instantiation, and registry resolution in MCP-compliant systems.\\n\\n    Key Features:\\n        - Tool resolution from contract specifications\\n        - Dynamic tool class discovery from modules\\n        - Container-based tool instantiation\\n        - Registry-based tool resolution\\n        - Secure module path validation\\n        - Tool metadata management\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ToolDiscoveryServiceImpl:\\n            def resolve_tool_from_contract(self, metadata, registry, contract_path):\\n                # Load tool configuration from contract\\n                module_path = self.build_module_path_from_contract(contract_path)\\n                tool_class = self.discover_tool_class_from_module(module_path, metadata.get(\\'tool_class\\'))\\n                return self.instantiate_tool_with_container(tool_class, registry)\\n\\n        # Usage in application code\\n        discovery_service: \"ProtocolToolDiscoveryService\" = ToolDiscoveryServiceImpl()\\n\\n        tool = discovery_service.resolve_tool_from_contract(\\n            metadata={\\'tool_class\\': \\'MyTool\\'},\\n            registry=container,\\n            contract_path=\\'/path/to/contract.yaml\\'\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolServiceDependency', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_dependency() -> bool', 'is_satisfied() -> bool'], signature_hash='7c8393268f554d42', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=58, is_runtime_checkable=True, domain='container', properties=['dependency_name: str', 'dependency_interface: str', \"dependency_version: 'ProtocolSemVer | None'\", 'is_required: bool', 'is_circular: bool', 'injection_point: str', 'default_value: Any | None', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service dependency information.')",
        "ProtocolInfo(name='ProtocolServiceRegistration', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_registration() -> bool', 'is_active() -> bool'], signature_hash='870f2a3a23690d98', line_count=14, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=80, is_runtime_checkable=True, domain='container', properties=['registration_id: str', \"service_metadata: 'ProtocolServiceRegistrationMetadata'\", 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralInjectionScope', \"dependencies: list['ProtocolServiceDependency']\", \"registration_status: Literal['registered', 'unregistered', 'failed', 'pending', 'conflict', 'invalid']\", 'health_status: ServiceHealthStatus', \"registration_time: 'ProtocolDateTime'\", \"last_access_time: 'ProtocolDateTime | None'\", 'access_count: int', 'instance_count: int', 'max_instances: int | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for service registration information.')",
        "ProtocolInfo(name='ProtocolRegistryServiceInstance', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['validate_instance() -> bool', 'is_active() -> bool'], signature_hash='6756e40ec4e49a67', line_count=12, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=108, is_runtime_checkable=True, domain='container', properties=['instance_id: str', 'service_registration_id: str', 'instance: Any', 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralInjectionScope', \"created_at: 'ProtocolDateTime'\", \"last_accessed: 'ProtocolDateTime'\", 'access_count: int', 'is_disposed: bool', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='functional', docstring='Protocol for service registry managed instance information.')",
        "ProtocolInfo(name='ProtocolServiceValidator', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['async validate_service(service: Any, interface: Type[Any]) -> ProtocolValidationResult', \"async validate_dependencies(dependencies: list['ProtocolServiceDependency']) -> ProtocolValidationResult\"], signature_hash='8146cb0d189702de', line_count=2, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=179, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for service validation operations.')",
        "ProtocolInfo(name='ProtocolServiceFactory', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['async create_instance(interface: Type[T], context: dict[str, Any]) -> T', 'async dispose_instance(instance: Any) -> None'], signature_hash='0c36b9b016a8b47f', line_count=2, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=196, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for service factory operations.')",
        "ProtocolInfo(name='ProtocolServiceRegistry', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=['config() -> ProtocolServiceRegistryConfig', 'validator() -> ProtocolServiceValidator | None', 'factory() -> ProtocolServiceFactory | None', \"async register_service(interface: Type[TInterface], implementation: Type[TImplementation], lifecycle: LiteralServiceLifecycle, scope: LiteralInjectionScope, configuration: dict[str, 'ContextValue'] | None) -> str\", \"async register_instance(interface: Type[TInterface], instance: TInterface, scope: 'LiteralInjectionScope', metadata: dict[str, 'ContextValue'] | None) -> str\", \"async register_factory(interface: Type[TInterface], factory: 'ProtocolServiceFactory', lifecycle: 'LiteralServiceLifecycle', scope: 'LiteralInjectionScope') -> str\", 'async unregister_service(registration_id: str) -> bool', \"async resolve_service(interface: Type[TInterface], scope: 'LiteralInjectionScope | None', context: dict[str, 'ContextValue'] | None) -> TInterface\", \"async resolve_named_service(interface: Type[TInterface], name: str, scope: 'LiteralInjectionScope | None') -> TInterface\", \"async resolve_all_services(interface: Type[TInterface], scope: 'LiteralInjectionScope | None') -> list[TInterface]\", \"async try_resolve_service(interface: Type[TInterface], scope: 'LiteralInjectionScope | None') -> TInterface | None\", 'async get_registration(registration_id: str) -> ProtocolServiceRegistration | None', \"async get_registrations_by_interface(interface: Type[T]) -> list['ProtocolServiceRegistration']\", \"async get_all_registrations() -> list['ProtocolServiceRegistration']\", \"async get_active_instances(registration_id: str | None) -> list['ProtocolRegistryServiceInstance']\", \"async dispose_instances(registration_id: str, scope: 'LiteralInjectionScope | None') -> int\", \"async validate_registration(registration: 'ProtocolServiceRegistration') -> bool\", \"async detect_circular_dependencies(registration: 'ProtocolServiceRegistration') -> list[str]\", 'async get_dependency_graph(service_id: str) -> ProtocolDependencyGraph | None', 'async get_registry_status() -> ProtocolServiceRegistryStatus', 'async validate_service_health(registration_id: str) -> ProtocolValidationResult', \"async update_service_configuration(registration_id: str, configuration: dict[str, 'ContextValue']) -> bool\", 'async create_injection_scope(scope_name: str, parent_scope: str | None) -> str', 'async dispose_injection_scope(scope_id: str) -> int', 'async get_injection_context(context_id: str) -> ProtocolInjectionContext | None'], signature_hash='7814da6993a59b3f', line_count=25, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=224, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for service registry operations.\\n\\n    Provides dependency injection service registration and management.\\n    Supports the complete service lifecycle including registration, resolution, injection, and disposal.\\n\\n    Advanced Features:\\n        - **Lifecycle Management**: Support for singleton, transient, scoped, pooled patterns\\n        - **Dependency Injection**: Constructor, property, and method injection patterns\\n        - **Circular Dependency Detection**: Automatic detection and prevention\\n        - **Health Monitoring**: Service health tracking and validation\\n        - **Performance Metrics**: Resolution time tracking and optimization\\n        - **Scoped Injection**: Request, session, thread-based scoping\\n        - **Service Validation**: Registration and runtime validation\\n        - **Instance Pooling**: Object pooling for performance optimization\\n\\n    Service Registration Patterns:\\n        - **Interface-based registration**: Register by interface type\\n        - **Named registration**: Register multiple implementations with names\\n        - **Generic registration**: Support for generic service types\\n        - **Conditional registration**: Register based on runtime conditions\\n        - **Decorator-based registration**: Use decorators for automatic registration\\n    ')",
        "ProtocolInfo(name='ProtocolContainerService', file_path='src/omnibase_spi/protocols/container/protocol_container_service.py', module_path='omnibase_spi.protocols.container.protocol_container_service', methods=[\"async create_container_from_contract(contract_metadata: 'ProtocolMetadata', node_id: str, node_ref: object | None) -> 'ProtocolContainerResult'\", \"async create_service_from_dependency(dependency_spec: 'ProtocolDependencySpec') -> 'ProtocolContainerServiceInstance | None'\", \"async validate_container_dependencies(container: 'ProtocolContainer') -> bool\", \"async get_registry_wrapper(container: 'ProtocolContainer', node_ref: object | None) -> 'ProtocolRegistryWrapper'\", \"async update_container_lifecycle(registry: 'ProtocolRegistryWrapper', node_ref: object) -> None\"], signature_hash='c56988c0332dfa8a', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainer', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainerResult', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolContainerServiceInstance', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolDependencySpec', 'omnibase_spi.protocols.types.protocol_container_types.ProtocolRegistryWrapper', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolMetadata'], line_number=22, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for container service operations.\\n\\n    Provides dependency injection container management, service registration,\\n    and registry lifecycle operations for ONEX-compliant systems.\\n\\n    Key Features:\\n        - Container creation from contract specifications\\n        - Service instantiation from dependency specifications\\n        - Container dependency validation\\n        - Registry wrapper management\\n        - Container lifecycle management\\n        - Node reference integration\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class ContainerServiceImpl:\\n            async def create_container_from_contract(self, metadata, node_id, node_ref=None):\\n                container = self._create_empty_container()\\n\\n                # Register dependencies from contract\\n                for dep_spec in metadata.dependencies:\\n                    service = self.create_service_from_dependency(dep_spec)\\n                    if service:\\n                        container.register(dep_spec.service_key, service)\\n\\n                return ContainerResult(container, registry_wrapper)\\n\\n        # Usage in application code\\n        container_service: \"ProtocolContainerService\" = ContainerServiceImpl()\\n\\n        result = container_service.create_container_from_contract(\\n            metadata=contract_metadata,\\n            node_id=\"my_node\",\\n            node_ref=node_instance\\n        )\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolArtifactContainer', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=['async get_status() -> ProtocolArtifactContainerStatus', \"get_artifacts() -> list['ProtocolArtifactInfo']\", \"get_artifacts_by_type(artifact_type: LiteralContainerArtifactType) -> list['ProtocolArtifactInfo']\", \"get_artifact_by_name(name: str, artifact_type: 'LiteralContainerArtifactType | None') -> ProtocolArtifactInfo\", \"has_artifact(name: str, artifact_type: 'LiteralContainerArtifactType | None') -> bool\"], signature_hash='ce61ccba7b3d70a5', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=56, is_runtime_checkable=True, domain='container', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Cross-cutting artifact container protocol.\\n\\n    Provides an interface for artifact container operations that can be implemented\\n    by different container backends (artifact loader node, mock containers, etc.)\\n    without exposing implementation-specific details.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkQueue', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_work_queue.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_work_queue', methods=['async connect_to_work_system() -> bool', 'async fetch_pending_tickets(limit: int | None) -> list[Any]', 'async subscribe_to_ticket_updates() -> AsyncIterator[Any]', 'async assign_ticket_to_agent(ticket_id: str, agent_id: str) -> Any', 'async update_ticket_status(ticket_id: str, status: str, message: str | None) -> bool', 'async update_ticket_progress(ticket_id: str, progress_percent: float) -> bool', \"async complete_ticket(ticket_id: str, result_data: dict[str, 'ContextValue']) -> bool\", 'async fail_ticket(ticket_id: str, error_message: str) -> bool', 'async get_ticket_by_id(ticket_id: str) -> Any | None', 'async get_tickets_by_priority(priority: LiteralWorkQueuePriority) -> list[Any]', 'async get_tickets_by_agent(agent_id: str) -> list[Any]', \"async get_available_tickets(agent_capabilities: list[str] | None, max_priority: 'LiteralWorkQueuePriority | None') -> list[Any]\", 'async reserve_ticket(ticket_id: str, agent_id: str, duration_minutes: int) -> bool', 'async release_ticket_reservation(ticket_id: str, agent_id: str) -> bool', 'async get_queue_statistics() -> dict[str, int]', 'async get_ticket_dependencies(ticket_id: str) -> list[str]', 'async add_ticket_dependency(ticket_id: str, dependency_ticket_id: str) -> bool', 'async remove_ticket_dependency(ticket_id: str, dependency_ticket_id: str) -> bool', 'async get_blocked_tickets() -> list[Any]', 'async get_ready_tickets() -> list[Any]', 'async set_assignment_strategy(strategy: LiteralAssignmentStrategy) -> bool', \"async get_assignment_strategy() -> 'LiteralAssignmentStrategy'\", 'async requeue_ticket(ticket_id: str, reason: str) -> bool', 'async estimate_completion_time(ticket_id: str) -> Any', 'async get_ticket_metrics(ticket_id: str) -> dict[str, float]', \"async create_ticket_checkpoint(ticket_id: str, checkpoint_data: dict[str, 'ContextValue']) -> str\", 'async restore_ticket_checkpoint(ticket_id: str, checkpoint_id: str) -> bool'], signature_hash='589cca7d0a7c412d', line_count=27, imports=['collections.abc.AsyncIterator', 'typing.Any', 'typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=28, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for work queue integration and ticket management.')",
        "ProtocolInfo(name='ProtocolWorkflowEventMessage', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=['async ack() -> None', 'async get_workflow_event() -> ProtocolWorkflowEvent'], signature_hash='9c600e9aa8cdc88f', line_count=14, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=21, is_runtime_checkable=True, domain='workflow', properties=['topic: str', 'key: bytes | None', 'value: bytes', 'headers: dict[str, Any]', 'offset: str | None', 'partition: int | None', 'workflow_type: str', 'instance_id: UUID', 'correlation_id: UUID', 'sequence_number: int', 'event_type: LiteralWorkflowEventType', 'idempotency_key: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific event messages.\\n\\n    Extends the base event message with workflow orchestration metadata\\n    for proper event sourcing and workflow coordination.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowEventHandler', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=[\"async __call__(event: 'ProtocolWorkflowEvent', context: dict[str, Any]) -> None\"], signature_hash='bacef0fb035e29a1', line_count=1, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=50, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow event handler functions.\\n\\n    Event handlers process workflow events and update workflow state\\n    according to event sourcing patterns.\\n    ')",
        "ProtocolInfo(name='ProtocolLiteralWorkflowStateProjection', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=[\"async apply_event(event: 'ProtocolWorkflowEvent', current_state: dict[str, Any]) -> dict[str, Any]\", 'async get_state(workflow_type: str, instance_id: UUID) -> dict[str, Any]'], signature_hash='89b2da8e62f1707a', line_count=3, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=72, is_runtime_checkable=True, domain='workflow', properties=['projection_name: str'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow state projection handlers.\\n\\n    Projections maintain derived state from workflow events\\n    for query optimization and real-time monitoring.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowEventBus', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus', methods=['base_event_bus() -> ProtocolEventBus'], signature_hash='0088fe9c82e778c3', line_count=1, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=112, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific event bus operations.\\n\\n    Extends the base event bus with workflow orchestration patterns:\\n    - Event sourcing with sequence numbers\\n    - Workflow instance isolation\\n    - Task coordination messaging\\n    - State projection updates\\n    - Recovery and replay support\\n\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowNodeRegistry', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=['base_registry() -> ProtocolNodeRegistry', \"async discover_nodes_for_task(task_config: 'ProtocolTaskConfiguration', scheduling_criteria: 'ProtocolTaskSchedulingCriteria') -> ProtocolNodeSchedulingResult\", \"async discover_nodes_by_capability(capability_name: str, capability_version: str | None, min_availability: float | None) -> list['ProtocolWorkflowNodeInfo']\", \"async discover_nodes_for_workflow_type(workflow_type: str, required_node_types: list[LiteralNodeType] | None) -> list['ProtocolWorkflowNodeInfo']\", 'async get_workflow_node_info(node_id: str) -> ProtocolWorkflowNodeInfo | None', \"async register_workflow_capability(node_id: str, capability: 'ProtocolWorkflowNodeCapability') -> bool\", 'async unregister_workflow_capability(node_id: str, capability_id: str) -> bool', \"async get_node_capabilities(node_id: str) -> list['ProtocolWorkflowNodeCapability']\", 'async update_node_workload(node_id: str, task_id: UUID, workload_change: str) -> None', 'async get_node_workload(node_id: str) -> dict[str, Any]', 'async get_resource_utilization(node_id: str) -> dict[str, float]', \"async calculate_scheduling_score(node_info: 'ProtocolWorkflowNodeInfo', task_config: 'ProtocolTaskConfiguration', criteria: 'ProtocolTaskSchedulingCriteria') -> float\", 'async reserve_resources(node_id: str, task_id: UUID, resource_requirements: dict[str, Any], timeout_seconds: int) -> bool', 'async release_resources(node_id: str, task_id: UUID) -> bool', 'async record_task_execution_metrics(node_id: str, task_id: UUID, execution_metrics: dict[str, Any]) -> None', \"async get_node_performance_history(node_id: str, task_type: 'LiteralTaskType | None', time_window_seconds: int) -> dict[str, Any]\", 'async update_node_availability(node_id: str, availability_status: str, metadata: dict[str, Any] | None) -> bool', 'async get_cluster_health_summary(workflow_type: str | None, node_group: str | None) -> dict[str, Any]'], signature_hash='978e29e5bdbc4e6f', line_count=18, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=111, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow-specific node discovery and management.\\n\\n    Extends the base node registry with workflow orchestration features:\\n    - Capability-based node discovery\\n    - Task scheduling and load balancing\\n    - Workflow-aware node selection\\n    - Resource utilization tracking\\n    - Performance-based routing\\n\\n    ')",
        "ProtocolInfo(name='ProtocolEventStoreTransaction', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=['async commit() -> bool', 'async rollback() -> None'], signature_hash='2bddc29a0d3a4945', line_count=4, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=21, is_runtime_checkable=True, domain='workflow', properties=['transaction_id: UUID', 'is_active: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for event store transaction objects.\\n\\n    Provides ACID transaction support for event store operations\\n    with rollback capabilities and consistency guarantees.\\n    ')",
        "ProtocolInfo(name='ProtocolEventStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async append_events(events: list['ProtocolWorkflowEvent'], expected_sequence: int | None, transaction: 'ProtocolEventStoreTransaction | None') -> ProtocolEventStoreResult\", \"async read_events(query_options: 'ProtocolEventQueryOptions', transaction: 'ProtocolEventStoreTransaction | None') -> list['ProtocolWorkflowEvent']\", \"async get_event_stream(workflow_type: str, instance_id: UUID, from_sequence: int, to_sequence: int | None) -> list['ProtocolWorkflowEvent']\", 'async get_last_sequence_number(workflow_type: str, instance_id: UUID) -> int', 'async begin_transaction() -> ProtocolEventStoreTransaction', 'async delete_event_stream(workflow_type: str, instance_id: UUID) -> ProtocolEventStoreResult', \"async archive_old_events(before_timestamp: 'ProtocolDateTime', batch_size: int) -> ProtocolEventStoreResult\"], signature_hash='e8db8e39a71226f2', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=80, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow event store operations.\\n\\n    Provides event sourcing capabilities with:\\n    - Append-only event storage\\n    - Sequence number guarantees\\n    - Transactional consistency\\n    - Event stream reading\\n    - Optimistic concurrency control\\n\\n    ')",
        "ProtocolInfo(name='ProtocolSnapshotStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async save_snapshot(snapshot: 'ProtocolWorkflowSnapshot', transaction: 'ProtocolEventStoreTransaction | None') -> bool\", 'async load_snapshot(workflow_type: str, instance_id: UUID, sequence_number: int | None) -> ProtocolWorkflowSnapshot | None', 'async list_snapshots(workflow_type: str, instance_id: UUID, limit: int) -> list[dict[str, Any]]', 'async delete_snapshot(workflow_type: str, instance_id: UUID, sequence_number: int) -> bool', 'async cleanup_old_snapshots(workflow_type: str, instance_id: UUID, keep_count: int) -> int'], signature_hash='15917e06aab7ea71', line_count=5, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=206, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow snapshot store operations.\\n\\n    Provides state snapshot capabilities for:\\n    - Point-in-time state capture\\n    - Fast state reconstruction\\n    - Recovery and replay optimization\\n    - State validation checkpoints\\n\\n    ')",
        "ProtocolInfo(name='ProtocolLiteralWorkflowStateStore', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[\"async save_workflow_instance(workflow_instance: 'ProtocolWorkflowSnapshot') -> bool\", 'async load_workflow_instance(workflow_type: str, instance_id: UUID) -> ProtocolWorkflowSnapshot | None', \"async query_workflow_instances(workflow_type: str | None, state: 'LiteralWorkflowState | None', correlation_id: UUID | None, limit: int, offset: int) -> list['ProtocolWorkflowSnapshot']\", 'async delete_workflow_instance(workflow_type: str, instance_id: UUID) -> bool', 'async lock_workflow_instance(workflow_type: str, instance_id: UUID, lock_owner: str, timeout_seconds: int) -> bool', 'async unlock_workflow_instance(workflow_type: str, instance_id: UUID, lock_owner: str) -> bool'], signature_hash='8f08c2837f1e0b80', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=301, is_runtime_checkable=True, domain='workflow', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for workflow state store operations.\\n\\n    Provides current state management for:\\n    - Active workflow instance storage\\n    - Fast state queries and updates\\n    - Locking and concurrency control\\n    - State validation and consistency\\n    ')",
        "ProtocolInfo(name='ProtocolValidationError', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['__str__() -> str'], signature_hash='5d52ab5889fc6ea7', line_count=5, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=13, is_runtime_checkable=True, domain='validation', properties=['error_type: str', 'message: str', 'context: Dict[str, Any]', 'severity: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation error objects.')",
        "ProtocolInfo(name='ProtocolValidationResult', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['add_error(error_type: str, message: str, context: Dict[str, Any] | None, severity: str) -> None', 'add_warning(error_type: str, message: str, context: Dict[str, Any] | None) -> None', 'async get_summary() -> str'], signature_hash='05abcf029156b534', line_count=8, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=27, is_runtime_checkable=True, domain='validation', properties=['is_valid: bool', 'protocol_name: str', 'implementation_name: str', 'errors: List[ProtocolValidationError]', 'warnings: List[ProtocolValidationError]'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation result objects.')",
        "ProtocolInfo(name='ProtocolValidator', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['async validate_implementation(implementation: Any, protocol: Any) -> ProtocolValidationResult'], signature_hash='6e043c1882118e6a', line_count=2, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=58, is_runtime_checkable=True, domain='validation', properties=['strict_mode: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for protocol validation functionality.')",
        "ProtocolInfo(name='ProtocolValidationDecorator', file_path='src/omnibase_spi/protocols/validation/protocol_validation.py', module_path='omnibase_spi.protocols.validation.protocol_validation', methods=['async validate_protocol_implementation(implementation: Any, protocol: Any, strict: bool) -> ProtocolValidationResult', 'validation_decorator(protocol: Any) -> Any'], signature_hash='4334214bfe7c3b97', line_count=2, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable'], line_number=80, is_runtime_checkable=True, domain='validation', properties=[], base_protocols=[], protocol_type='functional', docstring='Protocol for validation decorator functionality.')",
        "ProtocolInfo(name='ProtocolQualityMetrics', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_complexity_rating() -> str', 'async get_maintainability_rating() -> str'], signature_hash='1fc729aea162162b', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['cyclomatic_complexity: int', 'maintainability_index: float', 'lines_of_code: int', 'code_duplication_percentage: float', 'test_coverage_percentage: float', 'technical_debt_score: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for code quality metrics.')",
        "ProtocolInfo(name='ProtocolQualityIssue', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_issue_summary() -> str', 'is_fixable() -> bool'], signature_hash='cc0086122bcd5ed4', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=35, is_runtime_checkable=True, domain='validation', properties=['issue_type: str', 'severity: str', 'file_path: str', 'line_number: int', 'column_number: int', 'message: str', 'rule_id: str', 'suggested_fix: str | None'], base_protocols=[], protocol_type='functional', docstring='Protocol for quality issue representation.')",
        "ProtocolInfo(name='ProtocolQualityStandards', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async check_complexity_compliance(complexity: int) -> bool', 'async check_maintainability_compliance(score: float) -> bool'], signature_hash='965031f0df777cf4', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=57, is_runtime_checkable=True, domain='validation', properties=['max_complexity: int', 'min_maintainability_score: float', 'max_line_length: int', 'max_function_length: int', 'max_class_length: int', 'naming_conventions: List[str]', 'required_patterns: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for quality standards configuration.')",
        "ProtocolInfo(name='ProtocolQualityReport', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async get_critical_issues() -> List[ProtocolQualityIssue]', 'async get_fix_suggestions() -> List[str]'], signature_hash='1f377aca51222c5e', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=78, is_runtime_checkable=True, domain='validation', properties=['file_path: str', \"metrics: 'ProtocolQualityMetrics'\", 'issues: List[ProtocolQualityIssue]', 'standards_compliance: bool', 'overall_score: float', 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive quality assessment report.')",
        "ProtocolInfo(name='ProtocolQualityValidator', file_path='src/omnibase_spi/protocols/validation/protocol_quality_validator.py', module_path='omnibase_spi.protocols.validation.protocol_quality_validator', methods=['async validate_file_quality(file_path: str, content: str | None) -> ProtocolQualityReport', 'async validate_directory_quality(directory_path: str, file_patterns: List[str] | None) -> List[ProtocolQualityReport]', 'calculate_quality_metrics(file_path: str, content: str | None) -> ProtocolQualityMetrics', 'detect_code_smells(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async check_naming_conventions(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async analyze_complexity(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'async validate_documentation(file_path: str, content: str | None) -> List[ProtocolQualityIssue]', 'suggest_refactoring(file_path: str, content: str | None) -> List[str]', \"configure_standards(standards: 'ProtocolQualityStandards') -> None\", 'async get_validation_summary(reports: List[ProtocolQualityReport]) -> ProtocolValidationResult'], signature_hash='34b88dc46ae01719', line_count=14, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=98, is_runtime_checkable=True, domain='validation', properties=[\"standards: 'ProtocolQualityStandards'\", 'enable_complexity_analysis: bool', 'enable_duplication_detection: bool', 'enable_style_checking: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for code quality validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeQualityValidatorEffect nodes\\n    that assess code quality, complexity metrics, maintainability, and\\n    compliance with coding standards.\\n    ')",
        "ProtocolInfo(name='ProtocolValidationScope', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async should_validate_file(file_path: str) -> bool', 'async get_repository_name() -> str'], signature_hash='a0de12aa507a8e7f', line_count=7, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['repository_path: str', 'validation_types: List[str]', 'file_patterns: List[str]', 'exclusion_patterns: List[str]', 'validation_depth: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for defining validation scope.')",
        "ProtocolInfo(name='ProtocolValidationWorkflow', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_execution_order() -> List[str]', 'is_step_ready(step: str, completed_steps: List[str]) -> bool'], signature_hash='5dffbf8e11c33f6a', line_count=8, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=34, is_runtime_checkable=True, domain='validation', properties=['workflow_id: str', 'workflow_name: str', 'validation_steps: List[str]', 'dependencies: List[str]', 'parallel_execution: bool', 'timeout_seconds: int'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation workflow definition.')",
        "ProtocolInfo(name='ProtocolValidationMetrics', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_performance_summary() -> str'], signature_hash='61e5391d11f94186', line_count=6, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=54, is_runtime_checkable=True, domain='validation', properties=['total_files_processed: int', 'validation_duration_seconds: float', 'memory_usage_mb: float', 'parallel_executions: int', 'cache_hit_rate: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation execution metrics.')",
        "ProtocolInfo(name='ProtocolValidationSummary', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_overall_status() -> str'], signature_hash='4f04f6107aef7287', line_count=7, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=69, is_runtime_checkable=True, domain='validation', properties=['total_validations: int', 'passed_validations: int', 'failed_validations: int', 'warning_count: int', 'critical_issues: int', 'success_rate: float'], base_protocols=[], protocol_type='functional', docstring='Protocol for validation result summary.')",
        "ProtocolInfo(name='ProtocolValidationReport', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=['async get_critical_issues() -> List[ProtocolValidationResult]', 'generate_markdown_report() -> str'], signature_hash='dea7d51ed20bc9db', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=85, is_runtime_checkable=True, domain='validation', properties=['validation_id: str', 'repository_name: str', \"scope: 'ProtocolValidationScope'\", \"workflow: 'ProtocolValidationWorkflow'\", 'results: List[ProtocolValidationResult]', \"summary: 'ProtocolValidationSummary'\", \"metrics: 'ProtocolValidationMetrics'\", 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive validation reports.')",
        "ProtocolInfo(name='ProtocolValidationOrchestrator', file_path='src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py', module_path='omnibase_spi.protocols.validation.protocol_validation_orchestrator', methods=[\"orchestrate_validation(scope: 'ProtocolValidationScope', workflow: 'ProtocolValidationWorkflow | None') -> ProtocolValidationReport\", \"async validate_imports(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", \"async validate_quality(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", \"async validate_compliance(scope: 'ProtocolValidationScope') -> List[ProtocolValidationResult]\", 'async create_validation_workflow(workflow_name: str, validation_steps: List[str], dependencies: List[str], parallel_execution: bool) -> ProtocolValidationWorkflow', 'async create_validation_scope(repository_path: str, validation_types: List[str] | None, file_patterns: List[str] | None, exclusion_patterns: List[str] | None) -> ProtocolValidationScope', 'async get_orchestration_metrics() -> ProtocolValidationMetrics', 'async reset_orchestration_state() -> None'], signature_hash='ad3d509a6ca6bead', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=107, is_runtime_checkable=True, domain='validation', properties=['orchestration_id: str', \"default_scope: 'ProtocolValidationScope'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for validation orchestration in ONEX systems.\\n\\n    This protocol defines the interface for NodeValidationOrchestratorOrchestrator\\n    nodes that coordinate validation workflows across multiple validation nodes\\n    including import, quality, compliance, and security validation.\\n    ')",
        "ProtocolInfo(name='ProtocolComplianceRule', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async check_compliance(content: str, context: str) -> bool', 'async get_fix_suggestion() -> str'], signature_hash='7eb68c776c18a868', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['rule_id: str', 'rule_name: str', 'category: str', 'severity: str', 'description: str', 'required_pattern: str', 'violation_message: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for compliance rule definition.')",
        "ProtocolInfo(name='ProtocolComplianceViolation', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async get_violation_summary() -> str', 'async get_compliance_impact() -> str'], signature_hash='32fab2152ea5a8d2', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=36, is_runtime_checkable=True, domain='validation', properties=[\"rule: 'ProtocolComplianceRule'\", 'file_path: str', 'line_number: int', 'violation_text: str', 'severity: str', 'fix_suggestion: str', 'auto_fixable: bool'], base_protocols=[], protocol_type='functional', docstring='Protocol for compliance violation representation.')",
        "ProtocolInfo(name='ProtocolONEXStandards', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async validate_enum_naming(name: str) -> bool', 'async validate_model_naming(name: str) -> bool', 'async validate_protocol_naming(name: str) -> bool', 'async validate_node_naming(name: str) -> bool'], signature_hash='4c27469d5699458b', line_count=10, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=57, is_runtime_checkable=True, domain='validation', properties=['enum_naming_pattern: str', 'model_naming_pattern: str', 'protocol_naming_pattern: str', 'node_naming_pattern: str', 'required_directories: List[str]', 'forbidden_patterns: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for ONEX ecosystem standards.')",
        "ProtocolInfo(name='ProtocolArchitectureCompliance', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async check_dependency_compliance(imports: List[str]) -> List[str]', 'async validate_layer_separation(file_path: str, imports: List[str]) -> List[str]'], signature_hash='122a624bf125e65c', line_count=6, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=85, is_runtime_checkable=True, domain='validation', properties=['allowed_dependencies: List[str]', 'forbidden_dependencies: List[str]', 'required_patterns: List[str]', 'layer_violations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for architectural compliance checking.')",
        "ProtocolInfo(name='ProtocolComplianceReport', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async get_compliance_summary() -> str', 'async get_priority_fixes() -> List[ProtocolComplianceViolation]'], signature_hash='6b3b42760b139a94', line_count=9, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=105, is_runtime_checkable=True, domain='validation', properties=['file_path: str', 'violations: List[ProtocolComplianceViolation]', 'onex_compliance_score: float', 'architecture_compliance_score: float', 'overall_compliance: bool', 'critical_violations: int', 'recommendations: List[str]'], base_protocols=[], protocol_type='functional', docstring='Protocol for comprehensive compliance report.')",
        "ProtocolInfo(name='ProtocolComplianceValidator', file_path='src/omnibase_spi/protocols/validation/protocol_compliance_validator.py', module_path='omnibase_spi.protocols.validation.protocol_compliance_validator', methods=['async validate_file_compliance(file_path: str, content: str | None) -> ProtocolComplianceReport', 'async validate_repository_compliance(repository_path: str, file_patterns: List[str] | None) -> List[ProtocolComplianceReport]', 'async validate_onex_naming(file_path: str, content: str | None) -> List[ProtocolComplianceViolation]', 'async validate_architecture_compliance(file_path: str, content: str | None) -> List[ProtocolComplianceViolation]', 'async validate_directory_structure(repository_path: str) -> List[ProtocolComplianceViolation]', 'async validate_dependency_compliance(file_path: str, imports: List[str]) -> List[ProtocolComplianceViolation]', 'aggregate_compliance_results(reports: List[ProtocolComplianceReport]) -> ProtocolValidationResult', \"add_custom_rule(rule: 'ProtocolComplianceRule') -> None\", \"configure_onex_standards(standards: 'ProtocolONEXStandards') -> None\", 'async get_compliance_summary(reports: List[ProtocolComplianceReport]) -> str'], signature_hash='c277ac10d0be6d25', line_count=14, imports=['typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=126, is_runtime_checkable=True, domain='validation', properties=[\"onex_standards: 'ProtocolONEXStandards'\", \"architecture_rules: 'ProtocolArchitectureCompliance'\", 'custom_rules: List[ProtocolComplianceRule]', 'strict_mode: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for compliance validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeComplianceValidatorReducer nodes\\n    that validate compliance with ONEX standards, architectural patterns,\\n    and ecosystem requirements.\\n    ')",
        "ProtocolInfo(name='ProtocolImportValidationConfig', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async is_import_allowed(import_path: str) -> bool', 'async is_import_item_allowed(import_item: str) -> bool'], signature_hash='6a48b53840588c28', line_count=6, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=15, is_runtime_checkable=True, domain='validation', properties=['allowed_imports: set[str]', 'allowed_import_items: set[str]', 'repository_type: str', 'validation_mode: str'], base_protocols=[], protocol_type='functional', docstring='Protocol for import validation configuration.')",
        "ProtocolInfo(name='ProtocolImportAnalysis', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async get_risk_summary() -> str', 'async get_recommendations() -> List[str]'], signature_hash='8f68cadf72e493d8', line_count=8, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=33, is_runtime_checkable=True, domain='validation', properties=['import_path: str', 'import_items: List[str]', 'is_valid: bool', 'security_risk: str', 'dependency_level: int', 'analysis_details: Dict[str, Any]'], base_protocols=[], protocol_type='functional', docstring='Protocol for import analysis results.')",
        "ProtocolInfo(name='ProtocolImportValidator', file_path='src/omnibase_spi/protocols/validation/protocol_import_validator.py', module_path='omnibase_spi.protocols.validation.protocol_import_validator', methods=['async validate_import(import_path: str, description: str, context: Dict[str, Any] | None) -> ProtocolValidationResult', 'async validate_from_import(from_path: str, import_items: str, description: str, context: Dict[str, Any] | None) -> ProtocolValidationResult', 'async validate_import_security(import_path: str, context: Dict[str, Any] | None) -> ProtocolImportAnalysis', 'async validate_dependency_chain(import_path: str, max_depth: int) -> List[ProtocolImportAnalysis]', 'async validate_repository_imports(repository_path: str, patterns: List[str] | None) -> List[ProtocolValidationResult]', 'async get_validation_summary() -> Dict[str, Any]', \"configure_validation(config: 'ProtocolImportValidationConfig') -> None\", 'async reset_validation_state() -> None'], signature_hash='2a11b28321ac33c6', line_count=11, imports=['typing.Any', 'typing.Dict', 'typing.List', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_validation.ProtocolValidationResult'], line_number=53, is_runtime_checkable=True, domain='validation', properties=[\"validation_config: 'ProtocolImportValidationConfig'\", 'security_scanning_enabled: bool', 'dependency_analysis_enabled: bool'], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol interface for import validation in ONEX systems.\\n\\n    This protocol defines the interface for NodeImportValidatorCompute nodes\\n    that validate import statements, dependencies, and security implications\\n    across ONEX repositories.\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusContextManager', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_context_manager.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_context_manager', methods=[\"async __aenter__() -> 'ProtocolEventBus'\", 'async __aexit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: object) -> None'], signature_hash='149d74468f689065', line_count=2, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.TypeVar', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBus'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for async context managers that yield a ProtocolEventBus-compatible object.\\n\\n    Provides lifecycle management for event bus resources with proper cleanup.\\n    Implementations must support async context management and return a ProtocolEventBus on enter.\\n\\n    Key Features:\\n        - Async context manager support (__aenter__, __aexit__)\\n        - Configuration-based initialization\\n        - Resource lifecycle management\\n        - Proper cleanup and error handling\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class KafkaEventBusContextManager:\\n            async def __aenter__(self) -> KafkaEventBus:\\n                # Implementation creates and connects event bus\\n                event_bus = KafkaEventBus(self.config)\\n                await event_bus.connect()\\n                return event_bus\\n\\n            async def __aexit__(self, exc_type, exc_val, exc_tb):\\n                # Implementation cleans up resources\\n                if hasattr(self, \\'_event_bus\\'):\\n                    await self._event_bus.close()\\n\\n        # Usage in application code\\n        async with context_manager_impl as event_bus:\\n            await event_bus.publish(topic=\"test\", key=None, value=b\"data\", headers={...})\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusBase', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"async publish(event: 'ProtocolEventMessage') -> None\"], signature_hash='08df32bab936af7a', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=18, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Base protocol for event bus operations.\\n\\n    Defines common event publishing interface that both synchronous\\n    and asynchronous event buses must implement. Provides unified\\n    event publishing capabilities across different execution patterns.\\n\\n    Key Features:\\n        - Unified event publishing interface\\n        - Support for both sync and async implementations\\n        - Compatible with dependency injection patterns\\n    ')",
        "ProtocolInfo(name='ProtocolRegistryWithBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=['validate_registry_bus() -> bool', 'has_bus_access() -> bool'], signature_hash='397f305f3ca16ce0', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=94, is_runtime_checkable=True, domain='events', properties=[\"event_bus: 'ProtocolEventBusBase | None'\"], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for registry that provides event bus access.\\n\\n    Defines interface for service registries that provide\\n    access to event bus instances for dependency injection.\\n\\n    Key Features:\\n        - Event bus dependency injection\\n        - Registry-based service location\\n        - Support for both sync and async event buses\\n    ')",
        "ProtocolInfo(name='ProtocolLogEmitter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"emit_log_event(level: 'LiteralLogLevel', message: str, data: dict[str, str | int | float | bool]) -> None\"], signature_hash='e2b3ec1f139e3f0d', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=119, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for structured log emission.\\n\\n    Defines interface for components that can emit structured\\n    log events with typed data and log levels.\\n\\n    Key Features:\\n        - Structured logging support\\n        - Log level management\\n        - Typed log data\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusInMemory', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_in_memory.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_in_memory', methods=[\"async get_event_history() -> list['ProtocolEventMessage']\", 'clear_event_history() -> None', 'async get_subscriber_count() -> int'], signature_hash='d1276beb45ca2c3d', line_count=3, imports=['typing.TYPE_CHECKING', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for in-memory event bus implementations.\\n\\n    Extends basic event bus functionality with in-memory specific\\n    features for testing, debugging, and development environments.\\n\\n    Key Features:\\n        - Event history tracking for debugging\\n        - Subscriber count monitoring\\n        - Memory-based event storage\\n        - Synchronous event processing\\n        - Development and testing support\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class InMemoryEventBusImpl:\\n            async def get_event_history(self) -> list:\\n                # Implementation returns copy of stored history\\n                return self._event_history.copy()\\n\\n            def clear_event_history(self) -> None:\\n                # Implementation clears stored events\\n                self._event_history.clear()\\n\\n            async def get_subscriber_count(self) -> int:\\n                # Implementation returns active subscriber count\\n                return len(self._subscribers)\\n\\n        # Usage in application code\\n        in_memory_bus: \"ProtocolEventBusInMemory\" = InMemoryEventBusImpl()\\n\\n        # Check event processing history\\n        history = in_memory_bus.get_event_history()\\n        print(f\"Processed {len(history)} events\")\\n\\n        # Monitor active subscribers\\n        subscriber_count = in_memory_bus.get_subscriber_count()\\n        print(f\"Active subscribers: {subscriber_count}\")\\n\\n        # Clear history for testing\\n        in_memory_bus.clear_event_history()\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusHeaders', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=['content_type() -> str', 'correlation_id() -> UUID', 'message_id() -> UUID', 'timestamp() -> ProtocolDateTime', 'source() -> str', 'event_type() -> str', 'schema_version() -> ProtocolSemVer', 'destination() -> str | None', 'trace_id() -> str | None', 'span_id() -> str | None', 'parent_span_id() -> str | None', 'operation_name() -> str | None', \"priority() -> Literal['low', 'normal', 'high', 'critical'] | None\", 'routing_key() -> str | None', 'partition_key() -> str | None', 'retry_count() -> int | None', 'max_retries() -> int | None', 'ttl_seconds() -> int | None'], signature_hash='13f8b867e43acdd5', line_count=18, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=20, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for standardized headers for ONEX event bus messages.\\n\\n    Enforces strict interoperability across all agents and prevents\\n    integration failures from header naming inconsistencies.\\n    Based on ONEX messaging patterns and distributed tracing requirements.\\n\\n    ID Format Specifications:\\n    - UUID format: \"550e8400-e29b-41d4-a716-446655440000\" (32 hex digits with hyphens)\\n    - OpenTelemetry Trace ID: \"4bf92f3577b34da6a3ce929d0e0e4736\" (32 hex digits, no hyphens)\\n    - OpenTelemetry Span ID: \"00f067aa0ba902b7\" (16 hex digits, no hyphens)\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaEventBusAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=[\"async publish(topic: str, key: bytes | None, value: bytes, headers: 'ProtocolEventBusHeaders') -> None\", 'async subscribe(topic: str, group_id: str, on_message: Callable[[ProtocolEventMessage], Awaitable[None]]) -> Callable[[], Awaitable[None]]', 'async close() -> None'], signature_hash='e84382a94184d294', line_count=3, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=126, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for Event Bus Adapters supporting pluggable Kafka/Redpanda backends.\\n\\n    Implements the ONEX Messaging Design v0.3 Event Bus Adapter interface\\n    enabling drop-in support for both Kafka and Redpanda without code changes.\\n\\n    Environment isolation and node group mini-meshes are supported through\\n    topic naming conventions and group isolation patterns.\\n\\n    Usage Example:\\n        ```python\\n        # Implementation example (not part of SPI)\\n        class KafkaAdapter:\\n            async def publish(self, topic: str, key: Optional[bytes],\\n                            value: bytes, headers: \"ProtocolEventBusHeaders\") -> None:\\n                # Kafka-specific publishing logic\\n                producer = self._get_producer()\\n                await producer.send(topic, key=key, value=value, headers=headers)\\n\\n            async def subscribe(self, topic: str, group_id: str,\\n                              on_message: Callable) -> Callable:\\n                # Kafka-specific subscription logic\\n                consumer = self._create_consumer(group_id)\\n                consumer.subscribe([topic])\\n                # Return unsubscribe function\\n                return lambda: consumer.unsubscribe()\\n\\n        # Usage in application code\\n        adapter: \"ProtocolKafkaEventBusAdapter\" = KafkaAdapter()\\n\\n        # Publishing events\\n        await adapter.publish(\\n            topic=\"user-events\",\\n            key=b\"user-123\",\\n            value=json.dumps({\"event\": \"user_created\"}).encode(),\\n            headers={\\n                \"content_type\": \"application/json\",\\n                \"correlation_id\": uuid.uuid4(),\\n                \"message_id\": uuid.uuid4(),\\n                \"timestamp\": datetime.now(),\\n                \"source\": \"example-service\",\\n                \"event_type\": \"user.created\",\\n                \"schema_version\": SemVerImplementation(1, 0, 0)  # Implementation example\\n            }\\n        )\\n\\n        # Subscribing to events\\n        async def handle_message(msg: \"ProtocolEventMessage\") -> None:\\n            data = json.loads(msg.value.decode())\\n            print(f\"Received: {data}\")\\n            await msg.ack()\\n\\n        unsubscribe = await adapter.subscribe(\\n            topic=\"user-events\",\\n            group_id=\"user-service\",\\n            on_message=handle_message\\n        )\\n\\n        # Later cleanup\\n        await unsubscribe()\\n        await adapter.close()\\n        ```\\n\\n    Topic Naming Conventions:\\n        - Environment isolation: `{env}-{topic}` (e.g., \"prod-user-events\")\\n        - Node group isolation: `{group}-{topic}` (e.g., \"auth-user-events\")\\n        - Combined: `{env}-{group}-{topic}` (e.g., \"prod-auth-user-events\")\\n    ')",
        "ProtocolInfo(name='ProtocolEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus', methods=['adapter() -> ProtocolKafkaEventBusAdapter', 'environment() -> str', 'group() -> str', \"async publish(topic: str, key: bytes | None, value: bytes, headers: 'ProtocolEventBusHeaders | None') -> None\", 'async subscribe(topic: str, group_id: str, on_message: Callable[[ProtocolEventMessage], Awaitable[None]]) -> Callable[[], Awaitable[None]]', 'async broadcast_to_environment(command: str, payload: dict[str, Any], target_environment: str | None) -> None', 'async send_to_group(command: str, payload: dict[str, Any], target_group: str) -> None', 'async close() -> None'], signature_hash='63c88c8ff0271917', line_count=8, imports=['typing.Any', 'typing.Awaitable', 'typing.Callable', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=239, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    ONEX event bus protocol for distributed messaging infrastructure.\\n\\n    Implements the ONEX Messaging Design v0.3:\\n    - Environment isolation (dev, staging, prod)\\n    - Node group mini-meshes\\n    - Kafka/Redpanda adapter pattern\\n    - Standardized topic naming and headers\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusService', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_service', methods=[\"async get_event_bus() -> 'ProtocolEventMessage'\", 'shutdown() -> None', 'is_running() -> bool', 'async get_node_count() -> int', 'async list_nodes() -> list[str]'], signature_hash='998d3d681e65cf36', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol defining the required interface for event bus service implementations.\\n\\n    All event bus service classes must implement these methods to ensure:\\n    - Consistent lifecycle management\\n    - Proper shutdown handling\\n    - Standard event bus access\\n    - Service status monitoring\\n\\n    This protocol prevents runtime errors like missing shutdown() methods.\\n    ')",
        "ProtocolInfo(name='ProtocolHttpEventBusAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_service', methods=[\"async publish(event: 'ProtocolEventMessage') -> bool\", \"async subscribe(handler: Callable[['ProtocolEventMessage'], bool]) -> bool\", \"async unsubscribe(handler: Callable[['ProtocolEventMessage'], bool]) -> bool\", 'is_healthy() -> bool', 'close() -> None'], signature_hash='e461719d49f2c6cb', line_count=5, imports=['typing.TYPE_CHECKING', 'typing.Callable', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=76, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Protocol for event bus adapters that wrap HTTP/network event bus services.\\n\\n    This is for lightweight adapters that connect to external event bus services.\\n    ')",
        "ProtocolInfo(name='ProtocolEventBusCredentials', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_types', methods=['validate_credentials() -> bool', 'is_secure() -> bool'], signature_hash='039938e21c790fe5', line_count=9, imports=['typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ContextValue', 'omnibase_spi.protocols.types.ProtocolEvent'], line_number=7, is_runtime_checkable=True, domain='events', properties=['token: str | None', 'username: str | None', 'password: str | None', 'cert: str | None', 'key: str | None', 'ca: str | None', \"extra: dict[str, 'ContextValue'] | None\"], base_protocols=[], protocol_type='functional', docstring='\\n    Canonical credentials protocol for event bus authentication/authorization.\\n    Supports token, username/password, and TLS certs for future event bus support.\\n    ')",
        "ProtocolInfo(name='ProtocolEventPubSub', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_types', methods=['credentials() -> ProtocolEventBusCredentials | None', \"async publish(event: 'ProtocolEvent') -> None\", \"async publish_async(event: 'ProtocolEvent') -> None\", 'async subscribe(callback: Callable[[ProtocolEvent], None]) -> None', 'async subscribe_async(callback: Callable[[ProtocolEvent], None]) -> None', 'unsubscribe(callback: Callable[[ProtocolEvent], None]) -> None', 'async unsubscribe_async(callback: Callable[[ProtocolEvent], None]) -> None', 'clear() -> None', 'bus_id() -> str'], signature_hash='ef55c01aa0ec0eb7', line_count=9, imports=['typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.ContextValue', 'omnibase_spi.protocols.types.ProtocolEvent'], line_number=31, is_runtime_checkable=True, domain='events', properties=[], base_protocols=[], protocol_type='functional', docstring='\\n    Canonical protocol for simple event pub/sub operations.\\n    Defines basic publish/subscribe interface for event emission and handling.\\n    Provides a simpler alternative to the full distributed ProtocolEventBus.\\n    Supports both synchronous and asynchronous methods for maximum flexibility.\\n    Implementations may provide either or both, as appropriate.\\n    Optionally supports clear() for test/lifecycle management.\\n    All event bus implementations must expose a unique, stable bus_id (str) for diagnostics, registry, and introspection.\\n    ')"
      ],
      "property_only": [
        "ProtocolInfo(name='ProtocolStampOptions', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=[], signature_hash='dfe48240f02973a1', line_count=3, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=18, is_runtime_checkable=True, domain='file_handling', properties=['force: bool', 'backup: bool', 'dry_run: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for stamping operation options.')",
        "ProtocolInfo(name='ProtocolValidationOptions', file_path='src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py', module_path='omnibase_spi.protocols.file_handling.protocol_file_type_handler', methods=[], signature_hash='6d8d3f94e2047c7e', line_count=3, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolNodeMetadata', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolCanHandleResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolExtractedBlock', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolOnexResult', 'omnibase_spi.protocols.types.protocol_file_handling_types.ProtocolSerializedBlock'], line_number=27, is_runtime_checkable=True, domain='file_handling', properties=['strict: bool', 'verbose: bool', 'check_syntax: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for validation operation options.')",
        "ProtocolInfo(name='ProtocolContextStringValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='849d56803e0c596f', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=82, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string-based context values (text data, identifiers, messages).')",
        "ProtocolInfo(name='ProtocolContextNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='f89fcc3cfbe329af', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=89, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for numeric context values (identifiers, counts, measurements, scores).')",
        "ProtocolInfo(name='ProtocolContextBooleanValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='cb088428d962237a', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=96, is_runtime_checkable=True, domain='types', properties=['value: bool'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for boolean context values (flags, status indicators).')",
        "ProtocolInfo(name='ProtocolContextStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='a291abcb24786518', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=103, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string list context values (identifiers, tags, categories).')",
        "ProtocolInfo(name='ProtocolContextStringDictValue', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='2c654b3c5a930766', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=110, is_runtime_checkable=True, domain='types', properties=['value: dict[str, str]'], base_protocols=['ProtocolContextValue'], protocol_type='property_only', docstring='Protocol for string dictionary context values (key-value mappings, structured data).')",
        "ProtocolInfo(name='ProtocolNodeInfoLike', file_path='src/omnibase_spi/protocols/types/protocol_core_types.py', module_path='omnibase_spi.protocols.types.protocol_core_types', methods=[], signature_hash='d5989275e9c8cfce', line_count=1, imports=['datetime.datetime', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID'], line_number=908, is_runtime_checkable=True, domain='types', properties=['__omnibase_node_info_marker__: Literal[True]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for objects that can provide ONEX node information.\\n\\n    This marker protocol defines the minimal interface that objects\\n    must implement to be compatible with node metadata processing\\n    and discovery systems. Objects implementing this protocol can be\\n    safely converted to ModelNodeMetadataInfo instances.\\n\\n    Key Features:\\n        - Marker interface for node information compatibility\\n        - Runtime type checking with sentinel attribute\\n        - Safe conversion to node metadata structures\\n        - Compatibility with node discovery and registry systems\\n\\n    Usage:\\n        def process_node_info(info: \"ProtocolNodeInfoLike\"):\\n            if isinstance(info, ProtocolNodeInfoLike):\\n                metadata = convert_to_node_metadata(info)\\n                register_node(metadata)\\n\\n    This is a marker interface with a sentinel attribute for runtime checks.\\n    ')",
        "ProtocolInfo(name='ProtocolStringFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='d48ec186b880a7f3', line_count=1, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=39, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolFileContent'], protocol_type='property_only', docstring='Protocol for string-based file content (text files).')",
        "ProtocolInfo(name='ProtocolBinaryFileContent', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='933dbdd6f8a0690f', line_count=1, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=46, is_runtime_checkable=True, domain='types', properties=['value: bytes'], base_protocols=['ProtocolFileContent'], protocol_type='property_only', docstring='Protocol for binary file content (binary files).')",
        "ProtocolInfo(name='ProtocolFileMetadata', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='1386e3589dd98a83', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=56, is_runtime_checkable=True, domain='types', properties=['size: int', 'mime_type: str', 'encoding: str | None', 'created_at: float', 'modified_at: float'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file metadata - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolFileInfo', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='1d2b137c5c4ad9cc', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=67, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'file_size: int', 'file_type: str', 'mime_type: str', 'last_modified: float', 'status: LiteralFileStatus'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file information objects.')",
        "ProtocolInfo(name='ProtocolFileContentObject', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='aaa61a009ae95ffc', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=79, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'content: FileContent', 'encoding: str | None', 'content_hash: str', 'is_binary: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file content objects.')",
        "ProtocolInfo(name='ProtocolProcessingResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='5ef9fc17d9046c1c', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=90, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'operation: LiteralFileOperation', 'status: ProcessingStatus', 'processing_time: float', 'error_message: str | None', \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for file processing results.')",
        "ProtocolInfo(name='ProtocolFileFilter', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='9440bb39f7e39995', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=102, is_runtime_checkable=True, domain='types', properties=['include_extensions: list[str]', 'exclude_extensions: list[str]', 'min_size: int | None', 'max_size: int | None', 'modified_after: float | None', 'modified_before: float | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file filtering criteria.')",
        "ProtocolInfo(name='ProtocolFileTypeResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='c70a1bc55236d023', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=114, is_runtime_checkable=True, domain='types', properties=['file_path: str', 'detected_type: str', 'confidence: float', 'mime_type: str', 'is_supported: bool', 'error_message: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for file type detection results.')",
        "ProtocolInfo(name='ProtocolHandlerMatch', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='3505eb9894143073', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=126, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'node_name: str', 'match_confidence: float', 'can_handle: bool', 'required_capabilities: list[str]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node matching results.')",
        "ProtocolInfo(name='ProtocolCanHandleResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='505ca7a6523b5787', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=137, is_runtime_checkable=True, domain='types', properties=['can_handle: bool', 'confidence: float', 'reason: str', \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for can handle determination results.')",
        "ProtocolInfo(name='ProtocolHandlerMetadata', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='15d5b4dbccf23ec9', line_count=8, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=147, is_runtime_checkable=True, domain='types', properties=['name: str', \"version: 'ProtocolSemVer'\", 'author: str', 'description: str', 'supported_extensions: list[str]', 'supported_filenames: list[str]', 'priority: int', 'requires_content_analysis: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node metadata.')",
        "ProtocolInfo(name='ProtocolExtractedBlock', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='8111b64e4c7627a4', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=161, is_runtime_checkable=True, domain='types', properties=['content: str', \"file_metadata: 'ProtocolFileMetadata'\", 'block_type: str', 'start_line: int | None', 'end_line: int | None', 'path: str'], base_protocols=[], protocol_type='property_only', docstring='Protocol for extracted block data.')",
        "ProtocolInfo(name='ProtocolSerializedBlock', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='513ac8a7aa3f7e25', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=173, is_runtime_checkable=True, domain='types', properties=['serialized_data: str', 'format: str', \"version: 'ProtocolSemVer'\", \"file_metadata: 'ProtocolFileMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for serialized block data.')",
        "ProtocolInfo(name='ProtocolResultData', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='14bdc784ff71a3f1', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=183, is_runtime_checkable=True, domain='types', properties=['output_path: str | None', 'processed_files: list[str]', 'metrics: dict[str, float]', 'warnings: list[str]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for operation result data - attribute-based for data compatibility.')",
        "ProtocolInfo(name='ProtocolOnexResult', file_path='src/omnibase_spi/protocols/types/protocol_file_handling_types.py', module_path='omnibase_spi.protocols.types.protocol_file_handling_types', methods=[], signature_hash='0509105a0b315a66', line_count=5, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=193, is_runtime_checkable=True, domain='types', properties=['success: bool', 'message: str', \"result_data: 'ProtocolResultData | None'\", 'error_code: str | None', \"timestamp: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for ONEX operation results.')",
        "ProtocolInfo(name='ProtocolDependencySpec', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='3195e6b9e7bf37c8', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['service_key: str', 'module_path: str', 'class_name: str', 'lifecycle: LiteralServiceLifecycle', 'scope: LiteralDependencyScope', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency specification objects.')",
        "ProtocolInfo(name='ProtocolContainerResult', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='4bb61c3e67e30d67', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=94, is_runtime_checkable=True, domain='types', properties=[\"container: 'ProtocolContainer'\", \"registry: 'ProtocolRegistryWrapper'\", 'status: LiteralContainerStatus', 'error_message: str | None', 'services_registered: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for container creation results.')",
        "ProtocolInfo(name='ProtocolContainerConfiguration', file_path='src/omnibase_spi/protocols/types/protocol_container_types.py', module_path='omnibase_spi.protocols.types.protocol_container_types', methods=[], signature_hash='e621ac1de983f2a9', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=155, is_runtime_checkable=True, domain='types', properties=['auto_registration: bool', 'lazy_loading: bool', 'validation_enabled: bool', 'cache_services: bool', \"configuration_overrides: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for container configuration objects.')",
        "ProtocolInfo(name='ProtocolEventStringData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='25c2bb16e4c3b685', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string-based event data.')",
        "ProtocolInfo(name='ProtocolEventStringListData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='09a65ef82fdc01e5', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string list event data.')",
        "ProtocolInfo(name='ProtocolEventStringDictData', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='5c565bc2260a5009', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=54, is_runtime_checkable=True, domain='types', properties=[\"value: dict[str, 'ContextValue']\"], base_protocols=['ProtocolEventData'], protocol_type='property_only', docstring='Protocol for string dictionary event data.')",
        "ProtocolInfo(name='ProtocolEventBusConnectionCredentials', file_path='src/omnibase_spi/protocols/types/protocol_event_bus_types.py', module_path='omnibase_spi.protocols.types.protocol_event_bus_types', methods=[], signature_hash='885c82e8d507f54a', line_count=7, imports=['typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.event_bus.protocol_event_bus.ProtocolEventBusHeaders', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralBaseStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=158, is_runtime_checkable=True, domain='types', properties=['username: str', 'password: str', 'host: str', 'port: int', 'virtual_host: str | None', 'connection_timeout: int', 'heartbeat: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for event bus connection credential models with connection parameters.')",
        "ProtocolInfo(name='ProtocolCapabilityStringValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='c6b84a9b85a93955', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='types', properties=['value: str'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for string-based capability values (names, descriptions, IDs).')",
        "ProtocolInfo(name='ProtocolCapabilityNumericValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='e4a8a368d64912e6', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=47, is_runtime_checkable=True, domain='types', properties=['value: int | float'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for numeric capability values (counts, measurements, scores).')",
        "ProtocolInfo(name='ProtocolCapabilityBooleanValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='c14c2e6d820cb529', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=54, is_runtime_checkable=True, domain='types', properties=['value: bool'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for boolean capability values (flags, enabled/disabled).')",
        "ProtocolInfo(name='ProtocolCapabilityStringListValue', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='54fa72aabd9bd7ce', line_count=1, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=61, is_runtime_checkable=True, domain='types', properties=['value: list[str]'], base_protocols=['ProtocolCapabilityValue'], protocol_type='property_only', docstring='Protocol for string list capability values (tags, categories, identifiers).')",
        "ProtocolInfo(name='ProtocolHandlerCapability', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='50104c43c7094989', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=73, is_runtime_checkable=True, domain='types', properties=['capability_name: str', 'capability_value: CapabilityValue', 'is_required: bool', \"version: 'ProtocolSemVer'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for node capability objects.')",
        "ProtocolInfo(name='ProtocolDiscoveryNodeInfo', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='5a4555469d01eb80', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=83, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'node_name: str', 'node_type: str', 'status: LiteralHandlerStatus', 'capabilities: list[str]', 'metadata: dict[str, CapabilityValue]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery node information objects with handler status.')",
        "ProtocolInfo(name='ProtocolDiscoveryQuery', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='7f110fa56adaeb96', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=95, is_runtime_checkable=True, domain='types', properties=['query_id: UUID', 'target_type: str', 'required_capabilities: list[str]', \"filters: dict[str, 'ContextValue']\", 'timeout_seconds: float'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery query objects.')",
        "ProtocolInfo(name='ProtocolDiscoveryResult', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='2b5dcd7ef927ab51', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=106, is_runtime_checkable=True, domain='types', properties=['query_id: UUID', 'status: LiteralDiscoveryStatus', 'nodes_found: int', 'discovery_time: float', 'error_message: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for discovery result objects.')",
        "ProtocolInfo(name='ProtocolHandlerRegistration', file_path='src/omnibase_spi/protocols/types/protocol_discovery_types.py', module_path='omnibase_spi.protocols.types.protocol_discovery_types', methods=[], signature_hash='7a56cae8338755f4', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=118, is_runtime_checkable=True, domain='types', properties=['node_id: UUID', 'registration_data: dict[str, CapabilityValue]', 'registration_time: float', 'expires_at: float | None', 'is_active: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node registration objects.')",
        "ProtocolInfo(name='ProtocolHttpResponse', file_path='src/omnibase_spi/protocols/core/protocol_http_client.py', module_path='omnibase_spi.protocols.core.protocol_http_client', methods=[], signature_hash='42dea24884283805', line_count=4, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['status_code: int', \"headers: dict[str, 'ContextValue']\", 'body: str | bytes | dict[str, str | int | float | bool]', 'url: str'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol representing an HTTP response.\\n\\n    Provides structured response data with status, headers, and body content.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaMessage', file_path='src/omnibase_spi/protocols/core/protocol_kafka_extended.py', module_path='omnibase_spi.protocols.core.protocol_kafka_extended', methods=[], signature_hash='25363255614bfa84', line_count=7, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['key: bytes | None', 'value: bytes', 'topic: str', 'partition: int | None', 'offset: int | None', 'timestamp: int | None', 'headers: dict[str, bytes]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka message data.\\n\\n    Represents a single message with key, value, headers, and metadata\\n    for comprehensive message handling across producers and consumers.\\n    ')",
        "ProtocolInfo(name='ProtocolWatchHandle', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='7723358402e554bd', line_count=2, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=33, is_runtime_checkable=True, domain='core', properties=['watch_id: str', 'is_active: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for watch handle objects.')",
        "ProtocolInfo(name='ProtocolNodeRegistryConfig', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='e1593fa9819aee74', line_count=5, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=41, is_runtime_checkable=True, domain='core', properties=['consul_host: str', 'consul_port: int', 'consul_token: str | None', 'health_check_interval: int', 'retry_attempts: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node registry configuration.')",
        "ProtocolInfo(name='ProtocolNodeInfo', file_path='src/omnibase_spi/protocols/core/protocol_node_registry.py', module_path='omnibase_spi.protocols.core.protocol_node_registry', methods=[], signature_hash='1651be277fe5637d', line_count=11, imports=['__future__.annotations', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=52, is_runtime_checkable=True, domain='core', properties=['node_id: str', 'node_type: LiteralNodeType', 'node_name: str', 'environment: str', 'group: str', \"version: 'ProtocolSemVer'\", \"health_status: 'LiteralHealthStatus'\", 'endpoint: str', \"metadata: dict[str, 'ContextValue']\", \"registered_at: 'ProtocolDateTime'\", \"last_heartbeat: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for node information objects.')",
        "ProtocolInfo(name='ProtocolHttpClientConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='95a6fcfc83f1473a', line_count=19, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=14, is_runtime_checkable=True, domain='core', properties=['base_url: str', 'timeout_seconds: int', 'connect_timeout_seconds: int', 'read_timeout_seconds: int', 'max_retries: int', 'retry_delay_seconds: int', 'connection_pool_size: int', 'max_connections_per_host: int', 'ssl_verify: bool', 'ssl_cert_path: str | None', 'ssl_key_path: str | None', 'user_agent: str', \"default_headers: dict[str, 'ContextValue']\", 'proxy_url: str | None', 'proxy_auth: str | None', 'follow_redirects: bool', 'max_redirects: int', 'cookie_jar_enabled: bool', 'compression_enabled: bool'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for HTTP client configuration parameters.\\n\\n    Defines typed configuration structure for HTTP clients with\\n    connection pooling, security, retry logic, and performance settings.\\n\\n    Example:\\n        ```python\\n        config: \"ProtocolHttpClientConfig\" = get_http_config()\\n\\n        print(f\"Base URL: {config.base_url}\")\\n        print(f\"Timeout: {config.timeout_seconds}s\")\\n        print(f\"Pool size: {config.connection_pool_size}\")\\n        print(f\"SSL verify: {config.ssl_verify}\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolHttpAuthConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='dcaea53f62a77f28', line_count=12, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=54, is_runtime_checkable=True, domain='core', properties=['auth_type: str', 'bearer_token: str | None', 'basic_username: str | None', 'basic_password: str | None', 'api_key_header: str | None', 'api_key_value: str | None', 'oauth2_client_id: str | None', 'oauth2_client_secret: str | None', 'oauth2_token_url: str | None', 'oauth2_scope: str | None', 'refresh_token_automatically: bool', 'token_expiry_buffer_seconds: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for HTTP authentication configuration.\\n\\n    Defines typed authentication settings for HTTP clients including\\n    various authentication schemes and credential management.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaClientConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='8082bcf4cec48d35', line_count=16, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=77, is_runtime_checkable=True, domain='core', properties=['bootstrap_servers: list[str]', 'client_id: str', 'security_protocol: str', 'ssl_ca_location: str | None', 'ssl_certificate_location: str | None', 'ssl_key_location: str | None', 'ssl_key_password: str | None', 'sasl_mechanism: str | None', 'sasl_username: str | None', 'sasl_password: str | None', 'request_timeout_ms: int', 'retry_backoff_ms: int', 'max_retry_attempts: int', 'session_timeout_ms: int', 'heartbeat_interval_ms: int', 'max_poll_interval_ms: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka client configuration parameters.\\n\\n    Defines typed configuration structure for Kafka clients with\\n    connection settings, security, performance tuning, and reliability.\\n\\n    Example:\\n        ```python\\n        config: \"ProtocolKafkaClientConfig\" = get_kafka_config()\\n\\n        print(f\"Brokers: {config.bootstrap_servers}\")\\n        print(f\"Security: {config.security_protocol}\")\\n        print(f\"Batch size: {config.batch_size}\")\\n        print(f\"Compression: {config.compression_type}\")\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaProducerConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='948e6c5ecfebe02c', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=114, is_runtime_checkable=True, domain='core', properties=['acks: str', 'batch_size: int', 'linger_ms: int', 'buffer_memory: int', 'compression_type: str', 'max_in_flight_requests_per_connection: int', 'retries: int', 'delivery_timeout_ms: int', 'enable_idempotence: bool', 'transactional_id: str | None', 'max_request_size: int', 'send_buffer_bytes: int', 'receive_buffer_bytes: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka producer-specific configuration parameters.\\n\\n    Defines typed configuration for producer performance, reliability,\\n    and delivery semantics including batching and compression settings.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConsumerConfig', file_path='src/omnibase_spi/protocols/core/protocol_client_config.py', module_path='omnibase_spi.protocols.core.protocol_client_config', methods=[], signature_hash='c3493df7713c65db', line_count=13, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue'], line_number=138, is_runtime_checkable=True, domain='core', properties=['group_id: str', 'auto_offset_reset: str', 'enable_auto_commit: bool', 'auto_commit_interval_ms: int', 'max_poll_records: int', 'fetch_min_bytes: int', 'fetch_max_wait_ms: int', 'max_partition_fetch_bytes: int', 'check_crcs: bool', 'isolation_level: str', 'exclude_internal_topics: bool', 'partition_assignment_strategy: str', 'allow_auto_create_topics: bool'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for Kafka consumer-specific configuration parameters.\\n\\n    Defines typed configuration for consumer group management, offset handling,\\n    and message consumption patterns including auto-commit and fetch settings.\\n    ')",
        "ProtocolInfo(name='ProtocolOnexContractData', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='d8bae3b6f89e54aa', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=19, is_runtime_checkable=True, domain='core', properties=[\"contract_version: 'ProtocolSemVer'\", 'node_name: str', 'node_type: str', 'input_model: str', 'output_model: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX contract data structure protocol.')",
        "ProtocolInfo(name='ProtocolOnexSecurityContext', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='1a51f13da224bc53', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=30, is_runtime_checkable=True, domain='core', properties=['user_id: str', 'session_id: str', 'authentication_token: str', 'security_profile: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX security context data protocol.')",
        "ProtocolInfo(name='ProtocolOnexMetadata', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='39f114c870bbe4e9', line_count=4, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=40, is_runtime_checkable=True, domain='core', properties=['tool_name: str', \"tool_version: 'ProtocolSemVer'\", \"timestamp: 'ProtocolDateTime'\", 'environment: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX metadata structure protocol.')",
        "ProtocolInfo(name='ProtocolOnexSchema', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='bceb39ff06615e07', line_count=3, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=50, is_runtime_checkable=True, domain='core', properties=['schema_type: str', \"version: 'ProtocolSemVer'\", \"properties: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='ONEX schema definition protocol.')",
        "ProtocolInfo(name='ProtocolOnexValidationReport', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='0b96d723615ed498', line_count=5, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=59, is_runtime_checkable=True, domain='core', properties=['total_validations: int', 'passed_validations: int', 'failed_validations: int', 'overall_status: str', 'summary: str'], base_protocols=[], protocol_type='property_only', docstring='ONEX validation report protocol.')",
        "ProtocolInfo(name='ProtocolOnexValidationResult', file_path='src/omnibase_spi/protocols/core/protocol_onex_validation.py', module_path='omnibase_spi.protocols.core.protocol_onex_validation', methods=[], signature_hash='5c8bbc5313a21449', line_count=6, imports=['typing.Literal', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=86, is_runtime_checkable=True, domain='core', properties=['is_valid: bool', 'compliance_level: LiteralOnexComplianceLevel', 'validation_type: LiteralValidationType', 'errors: list[str]', 'warnings: list[str]', \"metadata: 'ProtocolOnexMetadata'\"], base_protocols=[], protocol_type='property_only', docstring='Result of Onex validation protocol.')",
        "ProtocolInfo(name='ProtocolMemoryStoreResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='659e548162a57a30', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=59, is_runtime_checkable=True, domain='memory', properties=['memory_id: UUID | None', 'storage_location: str | None'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory storage responses.')",
        "ProtocolInfo(name='ProtocolMemoryListResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='c692aeea3907b229', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=79, is_runtime_checkable=True, domain='memory', properties=[\"memories: list['ProtocolMemoryRecord']\", \"pagination: 'ProtocolPaginationResponse'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for paginated memory list responses.')",
        "ProtocolInfo(name='ProtocolBatchMemoryRetrieveResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='06c1dfe5de69e8c4', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=118, is_runtime_checkable=True, domain='memory', properties=[\"results: list['ProtocolBatchOperationResult']\", \"memories: list['ProtocolMemoryRecord']\", 'missing_ids: list[UUID]', 'batch_execution_time_ms: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for batch memory retrieval responses.')",
        "ProtocolInfo(name='ProtocolEmbeddingResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='6c262ef0dd712c8d', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=155, is_runtime_checkable=True, domain='memory', properties=['embedding: list[float]', 'algorithm_used: str', 'dimensions: int'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for embedding generation responses.')",
        "ProtocolInfo(name='ProtocolConsolidationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='8e6d9034c86bd486', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=164, is_runtime_checkable=True, domain='memory', properties=['consolidated_memory_id: UUID', 'source_memory_ids: list[UUID]'], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory consolidation responses.')",
        "ProtocolInfo(name='ProtocolAggregationResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='6332c80f2d979087', line_count=2, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=172, is_runtime_checkable=True, domain='memory', properties=[\"aggregated_data: 'ProtocolAggregatedData'\", \"aggregation_metadata: 'ProtocolMemoryMetadata'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for memory aggregation responses.')",
        "ProtocolInfo(name='ProtocolMemoryMetricsResponse', file_path='src/omnibase_spi/protocols/memory/protocol_memory_responses.py', module_path='omnibase_spi.protocols.memory.protocol_memory_responses', methods=[], signature_hash='e17c7551df9d0c64', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.AsyncIterator', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'protocol_memory_errors.ProtocolMemoryError', 'datetime.datetime', 'protocol_memory_base.ProtocolAgentResponseMap', 'protocol_memory_base.ProtocolAgentStatusMap', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationSummary', 'protocol_memory_base.ProtocolAnalysisResults', 'protocol_memory_base.ProtocolCustomMetrics', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolMemoryRecord', 'protocol_memory_base.ProtocolPageInfo', 'protocol_memory_base.ProtocolSearchResult'], line_number=247, is_runtime_checkable=True, domain='memory', properties=[\"metrics: list['ProtocolMemoryMetrics']\", \"aggregation_summary: 'ProtocolAggregationSummary'\", \"collection_timestamp: 'datetime'\"], base_protocols=['ProtocolMemoryResponse'], protocol_type='property_only', docstring='Protocol for metrics collection responses.')",
        "ProtocolInfo(name='ProtocolEmbeddingRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='e631c61ebf6335ce', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=162, is_runtime_checkable=True, domain='memory', properties=['text: str', 'algorithm: str | None', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for embedding generation requests.')",
        "ProtocolInfo(name='ProtocolConsolidationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='3856778abfd4669a', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=171, is_runtime_checkable=True, domain='memory', properties=['memory_ids: list[UUID]', 'consolidation_strategy: str', 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for memory consolidation requests.')",
        "ProtocolInfo(name='ProtocolAggregationRequest', file_path='src/omnibase_spi/protocols/memory/protocol_memory_requests.py', module_path='omnibase_spi.protocols.memory.protocol_memory_requests', methods=[], signature_hash='5615f81b28fdab9c', line_count=4, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime', 'protocol_memory_base.LiteralAnalysisType', 'protocol_memory_base.ProtocolAggregatedData', 'protocol_memory_base.ProtocolAggregationCriteria', 'protocol_memory_base.ProtocolAnalysisParameters', 'protocol_memory_base.ProtocolCoordinationMetadata', 'protocol_memory_base.ProtocolMemoryMetadata', 'protocol_memory_base.ProtocolSearchFilters', 'protocol_memory_base.ProtocolWorkflowConfiguration'], line_number=180, is_runtime_checkable=True, domain='memory', properties=[\"aggregation_criteria: 'ProtocolAggregationCriteria'\", \"time_window_start: 'datetime | None'\", \"time_window_end: 'datetime | None'\", 'timeout_seconds: float | None'], base_protocols=['ProtocolMemoryRequest'], protocol_type='property_only', docstring='Protocol for memory aggregation requests.')",
        "ProtocolInfo(name='ProtocolHandlerInfo', file_path='src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py', module_path='omnibase_spi.protocols.discovery.protocol_handler_discovery', methods=[], signature_hash='45dd6de0a6b57b0b', line_count=7, imports=['typing.Any', 'typing.Protocol', 'typing.Type', 'typing.runtime_checkable', 'omnibase_spi.protocols.file_handling.protocol_file_type_handler.ProtocolFileTypeHandler'], line_number=40, is_runtime_checkable=True, domain='unknown', properties=['node_class: Type[ProtocolFileTypeHandler]', 'name: str', 'source: str', 'priority: int', 'extensions: list[str]', 'special_files: list[str]', 'metadata: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for node information objects.')",
        "ProtocolInfo(name='ProtocolMCPSubsystemConfig', file_path='src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py', module_path='omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client', methods=[], signature_hash='b98f324e44c32083', line_count=10, imports=['typing.Any', 'typing.Callable', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPConnectionStatus', 'omnibase_spi.protocols.types.protocol_mcp_types.LiteralMCPLifecycleState', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPHealthCheck', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemMetadata', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPSubsystemRegistration', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolDefinition', 'omnibase_spi.protocols.types.protocol_mcp_types.ProtocolMCPToolExecution', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=29, is_runtime_checkable=True, domain='mcp', properties=[\"subsystem_metadata: 'ProtocolMCPSubsystemMetadata'\", 'registry_url: str', 'api_key: str', 'heartbeat_interval: int', \"tool_definitions: list['ProtocolMCPToolDefinition']\", 'auto_register: bool', 'retry_count: int', 'timeout_seconds: int', 'health_check_endpoint: str', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for MCP subsystem configuration.')",
        "ProtocolInfo(name='ProtocolServiceRegistrationMetadata', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='7dc90595ac59cd74', line_count=10, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=42, is_runtime_checkable=True, domain='container', properties=['service_id: str', 'service_name: str', 'service_interface: str', 'service_implementation: str', \"version: 'ProtocolSemVer'\", 'description: str | None', 'tags: list[str]', \"configuration: dict[str, 'ContextValue']\", \"created_at: 'ProtocolDateTime'\", \"last_modified_at: 'ProtocolDateTime | None'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registration metadata objects in service registry.')",
        "ProtocolInfo(name='ProtocolDependencyGraph', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='250ccf3db7b6a05e', line_count=7, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=132, is_runtime_checkable=True, domain='container', properties=['service_id: str', 'dependencies: list[str]', 'dependents: list[str]', 'depth_level: int', 'circular_references: list[str]', 'resolution_order: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency graph information.')",
        "ProtocolInfo(name='ProtocolInjectionContext', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='e2e823b93332d0fc', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=145, is_runtime_checkable=True, domain='container', properties=['context_id: str', 'target_service_id: str', 'scope: LiteralInjectionScope', 'resolved_dependencies: dict[str, Any]', \"injection_time: 'ProtocolDateTime'\", 'resolution_status: LiteralServiceResolutionStatus', 'error_details: str | None', 'resolution_path: list[str]', \"metadata: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for dependency injection context.')",
        "ProtocolInfo(name='ProtocolServiceRegistryStatus', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='ffc6a70b17d4f624', line_count=13, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=160, is_runtime_checkable=True, domain='container', properties=['registry_id: str', 'status: LiteralOperationStatus', 'message: str', 'total_registrations: int', 'active_instances: int', 'failed_registrations: int', 'circular_dependencies: int', 'lifecycle_distribution: dict[LiteralServiceLifecycle, int]', 'scope_distribution: dict[LiteralInjectionScope, int]', 'health_summary: dict[ServiceHealthStatus, int]', 'memory_usage_bytes: int | None', 'average_resolution_time_ms: float | None', \"last_updated: 'ProtocolDateTime'\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registry status information.')",
        "ProtocolInfo(name='ProtocolServiceRegistryConfig', file_path='src/omnibase_spi/protocols/container/protocol_service_registry.py', module_path='omnibase_spi.protocols.container.protocol_service_registry', methods=[], signature_hash='f51dfab880261669', line_count=9, imports=['typing.Any', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.Type', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralOperationStatus', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer', 'omnibase_spi.protocols.validation.protocol_validation.ProtocolValidationResult'], line_number=209, is_runtime_checkable=True, domain='container', properties=['registry_name: str', 'auto_wire_enabled: bool', 'lazy_loading_enabled: bool', 'circular_dependency_detection: bool', 'max_resolution_depth: int', 'instance_pooling_enabled: bool', 'health_monitoring_enabled: bool', 'performance_monitoring_enabled: bool', \"configuration: dict[str, 'ContextValue']\"], base_protocols=[], protocol_type='property_only', docstring='Protocol for service registry configuration.')",
        "ProtocolInfo(name='ProtocolArtifactMetadata', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='57d18e323bec65bb', line_count=4, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=21, is_runtime_checkable=True, domain='container', properties=['description: str | None', 'author: str | None', 'created_at: str | None', 'last_modified_at: str | None'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact metadata.')",
        "ProtocolInfo(name='ProtocolArtifactInfo', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='45096fd7177cc52d', line_count=6, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=31, is_runtime_checkable=True, domain='container', properties=['name: str', \"version: 'ProtocolSemVer'\", 'artifact_type: LiteralContainerArtifactType', 'path: str', \"metadata: 'ProtocolArtifactMetadata'\", 'is_wip: bool'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact information.')",
        "ProtocolInfo(name='ProtocolArtifactContainerStatus', file_path='src/omnibase_spi/protocols/container/protocol_artifact_container.py', module_path='omnibase_spi.protocols.container.protocol_artifact_container', methods=[], signature_hash='7c6586e421910e38', line_count=7, imports=['typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolSemVer'], line_number=43, is_runtime_checkable=True, domain='container', properties=['status: LiteralOnexStatus', 'message: str', 'artifact_count: int', 'valid_artifact_count: int', 'invalid_artifact_count: int', 'wip_artifact_count: int', 'artifact_types_found: list[LiteralContainerArtifactType]'], base_protocols=[], protocol_type='property_only', docstring='Protocol for artifact container status information.')",
        "ProtocolInfo(name='ProtocolWorkflowNodeCapability', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='9950155a195d9b96', line_count=9, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=24, is_runtime_checkable=True, domain='workflow', properties=['capability_id: str', 'capability_name: str', 'capability_version: str', 'supported_task_types: list[LiteralTaskType]', 'supported_node_types: list[LiteralNodeType]', 'resource_requirements: dict[str, Any]', 'configuration_schema: dict[str, Any]', 'performance_characteristics: dict[str, float]', 'availability_constraints: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for workflow-specific node capabilities.\\n\\n    Extends basic node capabilities with workflow orchestration\\n    features, task type support, and resource management.\\n    ')",
        "ProtocolInfo(name='ProtocolWorkflowNodeInfo', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='61d5853d991037dc', line_count=17, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=44, is_runtime_checkable=True, domain='workflow', properties=['node_id: str', 'node_type: LiteralNodeType', 'node_name: str', 'environment: str', 'group: str', 'version: str', \"health_status: 'LiteralHealthStatus'\", 'endpoint: str', 'metadata: dict[str, Any]', \"workflow_capabilities: list['ProtocolWorkflowNodeCapability']\", 'current_workload: dict[str, Any]', 'max_concurrent_tasks: int', 'current_task_count: int', 'supported_workflow_types: list[str]', 'task_execution_history: dict[str, Any]', 'resource_utilization: dict[str, float]', 'scheduling_preferences: dict[str, Any]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for workflow-specific node information.\\n\\n    Extends base node info with workflow orchestration capabilities,\\n    current workload, and task execution metrics.\\n    ')",
        "ProtocolInfo(name='ProtocolTaskSchedulingCriteria', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='f0b2f4dd0d59453f', line_count=10, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=72, is_runtime_checkable=True, domain='workflow', properties=['task_type: LiteralTaskType', 'node_type: LiteralNodeType', 'required_capabilities: list[str]', 'preferred_capabilities: list[str]', 'resource_requirements: dict[str, Any]', 'affinity_rules: dict[str, Any]', 'anti_affinity_rules: dict[str, Any]', 'geographic_constraints: dict[str, Any] | None', 'priority: LiteralTaskPriority', 'timeout_tolerance: int'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for task scheduling criteria.\\n\\n    Defines the requirements and preferences for scheduling tasks\\n    on workflow nodes based on capabilities and constraints.\\n    ')",
        "ProtocolInfo(name='ProtocolNodeSchedulingResult', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry', methods=[], signature_hash='cc871e78c1ea703c', line_count=7, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.core.protocol_node_registry.ProtocolNodeRegistry', 'omnibase_spi.protocols.types.protocol_core_types.LiteralHealthStatus', 'omnibase_spi.protocols.types.protocol_core_types.LiteralNodeType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskPriority', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralTaskType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolTaskConfiguration'], line_number=93, is_runtime_checkable=True, domain='workflow', properties=[\"selected_nodes: list['ProtocolWorkflowNodeInfo']\", 'scheduling_score: float', 'scheduling_rationale: str', \"fallback_nodes: list['ProtocolWorkflowNodeInfo']\", 'resource_allocation: dict[str, Any]', 'estimated_completion_time: float | None', 'constraints_satisfied: dict[str, bool]'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for node scheduling results.\\n\\n    Contains the results of task scheduling decisions including\\n    selected nodes, scheduling rationale, and fallback options.\\n    ')",
        "ProtocolInfo(name='ProtocolEventQueryOptions', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[], signature_hash='a4c75963ead27a89', line_count=10, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=42, is_runtime_checkable=True, domain='workflow', properties=['workflow_type: str | None', 'instance_id: UUID | None', 'event_types: list[LiteralWorkflowEventType] | None', 'from_sequence: int | None', 'to_sequence: int | None', \"from_timestamp: 'ProtocolDateTime | None'\", \"to_timestamp: 'ProtocolDateTime | None'\", 'limit: int | None', 'offset: int | None', 'order_by: str | None'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for event query options.\\n\\n    Defines filtering, ordering, and pagination options\\n    for event store queries.\\n    ')",
        "ProtocolInfo(name='ProtocolEventStoreResult', file_path='src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py', module_path='omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence', methods=[], signature_hash='8ee255c2a6df00e7', line_count=6, imports=['typing.Any', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolDateTime', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowEventType', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.LiteralWorkflowState', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowEvent', 'omnibase_spi.protocols.types.protocol_workflow_orchestration_types.ProtocolWorkflowSnapshot'], line_number=63, is_runtime_checkable=True, domain='workflow', properties=['success: bool', 'events_processed: int', 'sequence_numbers: list[int]', 'error_message: str | None', 'operation_time_ms: float', 'storage_size_bytes: int | None'], base_protocols=[], protocol_type='property_only', docstring='\\n    Protocol for event store operation results.\\n\\n    Provides operation outcome information with error details\\n    and performance metrics.\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaConfig', file_path='src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_kafka_adapter', methods=[], signature_hash='80679eab771af945', line_count=9, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_event_bus.ProtocolKafkaEventBusAdapter'], line_number=14, is_runtime_checkable=True, domain='events', properties=['security_protocol: str', 'sasl_mechanism: str', 'sasl_username: str | None', 'sasl_password: str | None', 'ssl_cafile: str | None', 'auto_offset_reset: str', 'enable_auto_commit: bool', 'session_timeout_ms: int', 'request_timeout_ms: int'], base_protocols=[], protocol_type='property_only', docstring='Protocol for Kafka configuration parameters.')"
      ],
      "mixin": [
        "ProtocolInfo(name='ProtocolCacheService', file_path='src/omnibase_spi/protocols/core/protocol_cache_service.py', module_path='omnibase_spi.protocols.core.protocol_cache_service', methods=['async get(key: str) -> T | None', 'async set(key: str, value: T, ttl_seconds: int | None) -> bool', 'async delete(key: str) -> bool', 'async clear(pattern: str | None) -> int', 'async exists(key: str) -> bool', \"async get_stats() -> 'ProtocolCacheStatistics'\"], signature_hash='15a008944dbc67c1', line_count=6, imports=['typing.TYPE_CHECKING', 'typing.Generic', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCacheStatistics'], line_number=25, is_runtime_checkable=True, domain='core', properties=[], base_protocols=['Generic[T]'], protocol_type='mixin', docstring='\\n    Protocol for cache service operations.\\n\\n    Generic cache service supporting any serializable value type.\\n    Implementations can use in-memory, Redis, or other cache backends.\\n\\n    Example:\\n        ```python\\n        # String cache\\n        cache: \"ProtocolCacheService\"[str] = get_string_cache()\\n        await cache.set(\"user:123\", \"john_doe\", ttl_seconds=3600)\\n        username = await cache.get(\"user:123\")  # Returns Optional[str]\\n\\n        # Dict cache for complex data\\n        cache: \"ProtocolCacheService\"[dict[str, Any]] = get_dict_cache()\\n        user_data = {\"id\": 123, \"name\": \"John\", \"active\": True}\\n        await cache.set(\"user:123:profile\", user_data, ttl_seconds=1800)\\n\\n        # Cache operations\\n        exists = await cache.exists(\"user:123\")\\n        await cache.delete(\"user:123\")\\n        await cache.clear()  # Clear all cached data\\n        ```\\n    ')",
        "ProtocolInfo(name='ProtocolCacheServiceProvider', file_path='src/omnibase_spi/protocols/core/protocol_cache_service.py', module_path='omnibase_spi.protocols.core.protocol_cache_service', methods=['async create_cache_service() -> ProtocolCacheService[T]', \"get_cache_configuration() -> dict[str, 'ContextValue']\"], signature_hash='566fbe05ed4e4253', line_count=2, imports=['typing.TYPE_CHECKING', 'typing.Generic', 'typing.Optional', 'typing.Protocol', 'typing.TypeVar', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'omnibase_spi.protocols.types.protocol_core_types.ProtocolCacheStatistics'], line_number=124, is_runtime_checkable=True, domain='core', properties=[], base_protocols=['Generic[T]'], protocol_type='mixin', docstring='Protocol for cache service provider.')",
        "ProtocolInfo(name='ProtocolMemoryMetadata', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['metadata_keys() -> list[str]', 'async get_metadata_value(key: str) -> str | None', 'has_metadata_key(key: str) -> bool'], signature_hash='c165197fe0febe6e', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=62, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for memory metadata structures.')",
        "ProtocolInfo(name='ProtocolWorkflowConfiguration', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['configuration_keys() -> list[str]', 'async get_configuration_value(key: str) -> str | None', 'async validate_configuration() -> bool'], signature_hash='d329a2c876121d67', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=80, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for workflow configuration structures.')",
        "ProtocolInfo(name='ProtocolAnalysisParameters', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['parameter_keys() -> list[str]', 'async get_parameter_value(key: str) -> str | None', 'async validate_parameters() -> bool'], signature_hash='84ad372195bdc6ed', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=98, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for analysis parameter structures.')",
        "ProtocolInfo(name='ProtocolAggregationCriteria', file_path='src/omnibase_spi/protocols/memory/protocol_memory_base.py', module_path='omnibase_spi.protocols.memory.protocol_memory_base', methods=['criteria_keys() -> list[str]', 'async get_criteria_value(key: str) -> str | None', 'async validate_criteria() -> bool'], signature_hash='d67aa240be4bc351', line_count=3, imports=['__future__.annotations', 'typing.TYPE_CHECKING', 'typing.Literal', 'typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'uuid.UUID', 'datetime.datetime'], line_number=116, is_runtime_checkable=True, domain='memory', properties=[], base_protocols=['ProtocolKeyValueStore'], protocol_type='mixin', docstring='Protocol for aggregation criteria structures.')",
        "ProtocolInfo(name='ProtocolRedpandaAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_redpanda_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_redpanda_adapter', methods=[\"redpanda_optimized_defaults() -> dict[str, 'ContextValue']\"], signature_hash='fcf5d912416c9152', line_count=1, imports=['typing.Protocol', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.ContextValue', 'protocol_kafka_adapter.ProtocolKafkaAdapter'], line_number=17, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolKafkaAdapter'], protocol_type='mixin', docstring='\\n    Protocol for Redpanda event bus adapter implementations.\\n\\n    Extends ProtocolKafkaAdapter since Redpanda uses Kafka protocol\\n    but with Redpanda-optimized defaults and configurations.\\n    ')",
        "ProtocolInfo(name='ProtocolSyncEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"publish_sync(event: 'ProtocolEventMessage') -> None\"], signature_hash='17ecadcd4d5eac60', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=36, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolEventBusBase'], protocol_type='mixin', docstring='\\n    Protocol for synchronous event bus operations.\\n\\n    Defines synchronous event publishing interface for\\n    event bus implementations that operate synchronously.\\n    Inherits from ProtocolEventBusBase for unified interface.\\n\\n    Key Features:\\n        - Synchronous event publishing\\n        - Basic publish interface\\n        - Compatible with sync event processing\\n    ')",
        "ProtocolInfo(name='ProtocolAsyncEventBus', file_path='src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py', module_path='omnibase_spi.protocols.event_bus.protocol_event_bus_mixin', methods=[\"async publish_async(event: 'ProtocolEventMessage') -> None\"], signature_hash='d0d96aa9d5c81abd', line_count=1, imports=['typing.TYPE_CHECKING', 'typing.Optional', 'typing.Protocol', 'typing.Union', 'typing.runtime_checkable', 'omnibase_spi.protocols.types.protocol_core_types.LiteralLogLevel', 'omnibase_spi.protocols.types.protocol_event_bus_types.ProtocolEventMessage'], line_number=65, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolEventBusBase'], protocol_type='mixin', docstring='\\n    Protocol for asynchronous event bus operations.\\n\\n    Defines asynchronous event publishing interface for\\n    event bus implementations that operate asynchronously.\\n    Inherits from ProtocolEventBusBase for unified interface.\\n\\n    Key Features:\\n        - Asynchronous event publishing\\n        - Async/await compatibility\\n        - Non-blocking event processing\\n    ')",
        "ProtocolInfo(name='ProtocolKafkaAdapter', file_path='src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py', module_path='omnibase_spi.protocols.event_bus.protocol_kafka_adapter', methods=['bootstrap_servers() -> str', 'environment() -> str', 'group() -> str', 'config() -> ProtocolKafkaConfig | None', 'kafka_config() -> ProtocolKafkaConfig', 'build_topic_name(topic: str) -> str'], signature_hash='a80fc83843ab57d1', line_count=6, imports=['typing.Optional', 'typing.Protocol', 'typing.runtime_checkable', 'protocol_event_bus.ProtocolKafkaEventBusAdapter'], line_number=29, is_runtime_checkable=True, domain='events', properties=[], base_protocols=['ProtocolKafkaEventBusAdapter'], protocol_type='mixin', docstring='\\n    Protocol for Kafka event bus adapter implementations.\\n\\n    Extends ProtocolKafkaEventBusAdapter with Kafka-specific configuration\\n    and connection management protocols.\\n    ')"
      ]
    },
    "quality_metrics": {
      "empty_protocols": 0,
      "property_only_protocols": 82,
      "functional_protocols": 338,
      "missing_docstrings": 0,
      "docstring_coverage": 1.0,
      "avg_properties_per_protocol": 3.361904761904762,
      "avg_methods_per_protocol": 3.380952380952381
    }
  },
  "protocols": [
    {
      "name": "ProtocolFileReader",
      "file_path": "src/omnibase_spi/protocols/file_handling/protocol_file_reader.py",
      "module_path": "omnibase_spi.protocols.file_handling.protocol_file_reader",
      "signature_hash": "1d2eb7ed112b2022",
      "domain": "file_handling",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStampOptions",
      "file_path": "src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py",
      "module_path": "omnibase_spi.protocols.file_handling.protocol_file_type_handler",
      "signature_hash": "dfe48240f02973a1",
      "domain": "file_handling",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationOptions",
      "file_path": "src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py",
      "module_path": "omnibase_spi.protocols.file_handling.protocol_file_type_handler",
      "signature_hash": "6d8d3f94e2047c7e",
      "domain": "file_handling",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileTypeHandler",
      "file_path": "src/omnibase_spi/protocols/file_handling/protocol_file_type_handler.py",
      "module_path": "omnibase_spi.protocols.file_handling.protocol_file_type_handler",
      "signature_hash": "6a3eb9d463b5522b",
      "domain": "file_handling",
      "method_count": 17,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "c4b3bc95f22f76cb",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowStringValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "c4a42f1002217fbb",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowStringListValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "84e779c9ee10ed41",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowStringDictValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "7ae62284b213aff8",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowNumericValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "7983be3306b397b2",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowStructuredValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "9e2728b3c18fd043",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTypedWorkflowData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "82fb853101ff2c45",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "5ce24225c795cb57",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryConfiguration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "a4a11450acb7c879",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTimeoutConfiguration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "bbf6d0a83382de76",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTaskDependency",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "00c25e5cfedd29c5",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowContext",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "bbb01ee9c1aaeb81",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTaskConfiguration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "b3b881ef5fbd80ba",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowEvent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "0d6d6652329cbbb9",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowSnapshot",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "a5d5c4124e3b1302",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTaskResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "cabe5d5ca139f1ba",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCompensationAction",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "a022da442c9efbf9",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowDefinition",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "391c89c69066c78e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeCapability",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "c4bddf7c3983665e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowServiceInstance",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "a8ecd65a95f2b5c5",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRecoveryPoint",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "455ffeb61ad39ec7",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolReplayStrategy",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "e50a68b5275cc63c",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStream",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "809e8fbe551f11ca",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventProjection",
      "file_path": "src/omnibase_spi/protocols/types/protocol_workflow_orchestration_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_workflow_orchestration_types",
      "signature_hash": "7f08a3e32620b07b",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSemVer",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "cc48dac04fbba2e2",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "6b1f8bd6d2df4d1a",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextStringValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "849d56803e0c596f",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextNumericValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "f89fcc3cfbe329af",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextBooleanValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "cb088428d962237a",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextStringListValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "a291abcb24786518",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContextStringDictValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "2c654b3c5a930766",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSupportedMetadataType",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "28773c15fb1950dd",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConfigValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "8bc54144e93051ca",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLogContext",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "048198a88f2f3bf7",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLogEntry",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "feb28e942088e7f9",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSerializationResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "8a4f553033958959",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "495b508622cf3cd0",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCacheStatistics",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "2f5e903e3ce6e823",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "245034e1e7cc70b8",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMetadataOperations",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "82b986211bb98771",
      "domain": "types",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolActionPayload",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "cb730f6304cd7ba4",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAction",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "832a76a2dd18acc1",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolState",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "0279e1f59cf90550",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeMetadataBlock",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "77307ca8a8909125",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSchemaObject",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "31995d0b18265d88",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorInfo",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "680155ab21f6d6c1",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSystemEvent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "b752fe1c319e9dea",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "a62b9df48dec3712",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "b1aee76ad9021d1c",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceInstance",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "73baf0b1e58c6c4a",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceHealthStatus",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "42b56f0e9021ed60",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCheckpointData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "7223da7f1490789d",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageCredentials",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "51b10e3d705e58a8",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageConfiguration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "7d97bead057300b5",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "6c3fdcd9705c8c1e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageListResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "44dc4baf79fa61e8",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageHealthStatus",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "0f17075a95e52338",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorContext",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "fc1a9aeb45cd278f",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRecoveryAction",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "b4dd10f32844736f",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "f43b00e5185a7d46",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolVersionInfo",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "782e1803abae123e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCompatibilityCheck",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "28b79d0845287353",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeInfoLike",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "d5989275e9c8cfce",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSupportedPropertyValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "f90b560449c5709f",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHealthMetrics",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "65d6c20642b0b242",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHealthCheck",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "8b43a942cb928a1d",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHealthMonitoring",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "61110f258afbd769",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMetricsPoint",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "729bb73a03d389d3",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTraceSpan",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "bc372986e988c520",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAuditEvent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "eefbfe460bf98aab",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSerializable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "2194795f8f448463",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolIdentifiable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "4ade353d3e18ab35",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNameable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "d09ed77d70c89dfa",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConfigurable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "e5ad392e3eda865c",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolExecutable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "ad183ce51a769d3c",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMetadataProvider",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "09e352a679bc8db7",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryConfig",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "83505052f95cfc1f",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryPolicy",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "ee495f9df144b7bf",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryAttempt",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "373a45903ee26931",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "df2341715f633f5e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTimeBased",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "da50e80e208aaa84",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTimeout",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "4722c52e37708b1b",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDuration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "860389bc949e5ae4",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalyticsMetric",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "0f4df50ca3878e9b",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalyticsProvider",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "261c94c68e2d6f26",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalyticsSummary",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "a69462ab685daa89",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPerformanceMetric",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "a46f75708493b11f",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPerformanceMetrics",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "d9eedd7e0fa176f0",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConnectionConfig",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "6483622eaad6a92f",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConnectionStatus",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "6ba7394d00462afc",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidatable",
      "file_path": "src/omnibase_spi/protocols/types/protocol_core_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_core_types",
      "signature_hash": "c1b954e7dcd3b2dc",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileContent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "7f2329c2fed359c2",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStringFileContent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "d48ec186b880a7f3",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBinaryFileContent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "933dbdd6f8a0690f",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "1386e3589dd98a83",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileInfo",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "1d2b137c5c4ad9cc",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileContentObject",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "aaa61a009ae95ffc",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolProcessingResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "5ef9fc17d9046c1c",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileFilter",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "9440bb39f7e39995",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileTypeResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "c70a1bc55236d023",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerMatch",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "3505eb9894143073",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCanHandleResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "505ca7a6523b5787",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "15d5b4dbccf23ec9",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolExtractedBlock",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "8111b64e4c7627a4",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSerializedBlock",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "513ac8a7aa3f7e25",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolResultData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "14bdc784ff71a3f1",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "0509105a0b315a66",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolFileMetadataOperations",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "eec733a0b369c2e4",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolResultOperations",
      "file_path": "src/omnibase_spi/protocols/types/protocol_file_handling_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_file_handling_types",
      "signature_hash": "3cefd1ede740f3b8",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainer",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "f53b72d6a9e7fef6",
      "domain": "types",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDependencySpec",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "3195e6b9e7bf37c8",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerServiceInstance",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "43bdde0bfbbebbfb",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRegistryWrapper",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "d9bf89630dc42783",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "4bb61c3e67e30d67",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerToolInstance",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "9d79cf2677f705f7",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerFactory",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "3124664c5a8a4eb0",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerServiceFactory",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "f1b3666a303a4196",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerConfiguration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_container_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_container_types",
      "signature_hash": "e621ac1de983f2a9",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "80e8597bc3304a1a",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStringData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "25c2bb16e4c3b685",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStringListData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "09a65ef82fdc01e5",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStringDictData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "5c565bc2260a5009",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEvent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "4ac8fbcb6e22c7d0",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "b414cd82a3bdd8ab",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSecurityContext",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "b589855d2da23fef",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventSubscription",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "669b50dad05ec621",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexEvent",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "6ed608742f7bba97",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusConnectionCredentials",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "885c82e8d507f54a",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventHeaders",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "2ca7bb15f053696c",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventMessage",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "2b90dec2a599d7b5",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCompletionData",
      "file_path": "src/omnibase_spi/protocols/types/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_event_bus_types",
      "signature_hash": "f5258530ffbadf95",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCapabilityValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "a077087a2f380033",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCapabilityStringValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "c6b84a9b85a93955",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCapabilityNumericValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "e4a8a368d64912e6",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCapabilityBooleanValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "c14c2e6d820cb529",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCapabilityStringListValue",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "54fa72aabd9bd7ce",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerCapability",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "50104c43c7094989",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDiscoveryNodeInfo",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "5a4555469d01eb80",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDiscoveryQuery",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "7f110fa56adaeb96",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDiscoveryResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "2b5dcd7ef927ab51",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerRegistration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_discovery_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_discovery_types",
      "signature_hash": "7a56cae8338755f4",
      "domain": "types",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolParameter",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "afe6844a9d8627e8",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolDefinition",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "cf455d00c4634ecf",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPSubsystemMetadata",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "0814cae989ff0c68",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPSubsystemRegistration",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "df3249a25e7496d6",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolExecution",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "a0b268b4eed20527",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistryMetrics",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "4ff5226298b7b8b9",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistryStatus",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "7f1f877ff09b8bde",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistryConfig",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "0df4d8d83e718181",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPHealthCheck",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "b2bea3b70834c4b6",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPDiscoveryInfo",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "3685610f0465bd06",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPValidationError",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "dabe39b02ff7c59e",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPValidationResult",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "9144ee698272fdaa",
      "domain": "types",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolToolClass",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "a35747994ffec9a9",
      "domain": "types",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolToolInstance",
      "file_path": "src/omnibase_spi/protocols/types/protocol_mcp_types.py",
      "module_path": "omnibase_spi.protocols.types.protocol_mcp_types",
      "signature_hash": "7602719b3f2b89ce",
      "domain": "types",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpRequestBuilder",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_extended",
      "signature_hash": "927b916221876cef",
      "domain": "core",
      "method_count": 13,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpStreamingResponse",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_extended",
      "signature_hash": "9d4549d3a6e7ce49",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpExtendedClient",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_extended",
      "signature_hash": "21632795b22e5df5",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalyticsDataProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_analytics_provider.py",
      "module_path": "omnibase_spi.protocols.core.protocol_analytics_provider",
      "signature_hash": "5f681bcacc13fc6b",
      "domain": "core",
      "method_count": 18,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMetricsCollector",
      "file_path": "src/omnibase_spi/protocols/core/protocol_observability.py",
      "module_path": "omnibase_spi.protocols.core.protocol_observability",
      "signature_hash": "36ae202f85df3dea",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDistributedTracing",
      "file_path": "src/omnibase_spi/protocols/core/protocol_observability.py",
      "module_path": "omnibase_spi.protocols.core.protocol_observability",
      "signature_hash": "8f82cb690ddd02bf",
      "domain": "core",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAuditLogger",
      "file_path": "src/omnibase_spi/protocols/core/protocol_observability.py",
      "module_path": "omnibase_spi.protocols.core.protocol_observability",
      "signature_hash": "e1e1edef990a15fd",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaClient",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_client.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_client",
      "signature_hash": "bae797905510773b",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaClientProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_client.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_client",
      "signature_hash": "1db909234119f467",
      "domain": "core",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolUtilsNodeConfiguration",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_configuration_utils.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_configuration_utils",
      "signature_hash": "6685bf56ab0aff23",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexEnvelope",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_envelope.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_envelope",
      "signature_hash": "1bc06b9eaa0c2231",
      "domain": "core",
      "method_count": 11,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHealthDetails",
      "file_path": "src/omnibase_spi/protocols/core/protocol_health_details.py",
      "module_path": "omnibase_spi.protocols.core.protocol_health_details",
      "signature_hash": "f15bbd4281cd96f9",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexReply",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_reply.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_reply",
      "signature_hash": "64b9fd0903fed960",
      "domain": "core",
      "method_count": 17,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPerformanceMetricsCollector",
      "file_path": "src/omnibase_spi/protocols/core/protocol_performance_metrics.py",
      "module_path": "omnibase_spi.protocols.core.protocol_performance_metrics",
      "signature_hash": "e0f6ec9343e79215",
      "domain": "core",
      "method_count": 20,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConnectionManageable",
      "file_path": "src/omnibase_spi/protocols/core/protocol_connection_manageable.py",
      "module_path": "omnibase_spi.protocols.core.protocol_connection_manageable",
      "signature_hash": "756d4309409bed83",
      "domain": "core",
      "method_count": 27,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpResponse",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_client.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_client",
      "signature_hash": "42dea24884283805",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpClient",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_client.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_client",
      "signature_hash": "9169b86eeb023c10",
      "domain": "core",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpClientProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_http_client.py",
      "module_path": "omnibase_spi.protocols.core.protocol_http_client",
      "signature_hash": "6502dea088020590",
      "domain": "core",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolVersionManager",
      "file_path": "src/omnibase_spi/protocols/core/protocol_version_manager.py",
      "module_path": "omnibase_spi.protocols.core.protocol_version_manager",
      "signature_hash": "cb230c0c71b8b776",
      "domain": "core",
      "method_count": 11,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaMessage",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_extended",
      "signature_hash": "25363255614bfa84",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaConsumer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_extended",
      "signature_hash": "413a99eb591b19ed",
      "domain": "core",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaBatchProducer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_extended",
      "signature_hash": "f7bb3ba11f25ba86",
      "domain": "core",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaTransactionalProducer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_extended",
      "signature_hash": "3b2a4b2c94193dd7",
      "domain": "core",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaExtendedClient",
      "file_path": "src/omnibase_spi/protocols/core/protocol_kafka_extended.py",
      "module_path": "omnibase_spi.protocols.core.protocol_kafka_extended",
      "signature_hash": "58d1354be27c472f",
      "domain": "core",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHealthMonitor",
      "file_path": "src/omnibase_spi/protocols/core/protocol_health_monitor.py",
      "module_path": "omnibase_spi.protocols.core.protocol_health_monitor",
      "signature_hash": "7ea3d28222eace2f",
      "domain": "core",
      "method_count": 14,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLogger",
      "file_path": "src/omnibase_spi/protocols/core/protocol_logger.py",
      "module_path": "omnibase_spi.protocols.core.protocol_logger",
      "signature_hash": "cf37fc77af098248",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageBackend",
      "file_path": "src/omnibase_spi/protocols/core/protocol_storage_backend.py",
      "module_path": "omnibase_spi.protocols.core.protocol_storage_backend",
      "signature_hash": "48bdc22baba35ea4",
      "domain": "core",
      "method_count": 11,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStorageBackendFactory",
      "file_path": "src/omnibase_spi/protocols/core/protocol_storage_backend.py",
      "module_path": "omnibase_spi.protocols.core.protocol_storage_backend",
      "signature_hash": "a43cb57926f6d92c",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolInputValidator",
      "file_path": "src/omnibase_spi/protocols/core/protocol_input_validator.py",
      "module_path": "omnibase_spi.protocols.core.protocol_input_validator",
      "signature_hash": "24935cfe97bee435",
      "domain": "core",
      "method_count": 13,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSchemaLoader",
      "file_path": "src/omnibase_spi/protocols/core/protocol_schema_loader.py",
      "module_path": "omnibase_spi.protocols.core.protocol_schema_loader",
      "signature_hash": "8cd734eeec177e48",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConfigurationManager",
      "file_path": "src/omnibase_spi/protocols/core/protocol_configuration_manager.py",
      "module_path": "omnibase_spi.protocols.core.protocol_configuration_manager",
      "signature_hash": "e0517860c99ce865",
      "domain": "core",
      "method_count": 16,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConfigurationManagerFactory",
      "file_path": "src/omnibase_spi/protocols/core/protocol_configuration_manager.py",
      "module_path": "omnibase_spi.protocols.core.protocol_configuration_manager",
      "signature_hash": "746a49fc4c2d26af",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTimeBasedOperations",
      "file_path": "src/omnibase_spi/protocols/core/protocol_time_based.py",
      "module_path": "omnibase_spi.protocols.core.protocol_time_based",
      "signature_hash": "20f89dde0c530281",
      "domain": "core",
      "method_count": 18,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflow",
      "file_path": "src/omnibase_spi/protocols/core/protocol_workflow_reducer.py",
      "module_path": "omnibase_spi.protocols.core.protocol_workflow_reducer",
      "signature_hash": "c351b423870fb688",
      "domain": "core",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowReducer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_workflow_reducer.py",
      "module_path": "omnibase_spi.protocols.core.protocol_workflow_reducer",
      "signature_hash": "6e4486f082db472e",
      "domain": "core",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationRule",
      "file_path": "src/omnibase_spi/protocols/core/protocol_validation_provider.py",
      "module_path": "omnibase_spi.protocols.core.protocol_validation_provider",
      "signature_hash": "74be7864c32d7f2e",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationRuleSet",
      "file_path": "src/omnibase_spi/protocols/core/protocol_validation_provider.py",
      "module_path": "omnibase_spi.protocols.core.protocol_validation_provider",
      "signature_hash": "856e336f1cc7461b",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationSession",
      "file_path": "src/omnibase_spi/protocols/core/protocol_validation_provider.py",
      "module_path": "omnibase_spi.protocols.core.protocol_validation_provider",
      "signature_hash": "8ef319560a8c7cca",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_validation_provider.py",
      "module_path": "omnibase_spi.protocols.core.protocol_validation_provider",
      "signature_hash": "cbcbb52d9085ce35",
      "domain": "core",
      "method_count": 21,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRetryable",
      "file_path": "src/omnibase_spi/protocols/core/protocol_retryable.py",
      "module_path": "omnibase_spi.protocols.core.protocol_retryable",
      "signature_hash": "4c8020f2e03012f7",
      "domain": "core",
      "method_count": 12,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeConfiguration",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_configuration.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_configuration",
      "signature_hash": "7077782ae4c79847",
      "domain": "core",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeConfigurationProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_configuration.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_configuration",
      "signature_hash": "5e3442f0c0d2ad2e",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConfigurationError",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_configuration.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_configuration",
      "signature_hash": "fea8191f0efacad5",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCacheService",
      "file_path": "src/omnibase_spi/protocols/core/protocol_cache_service.py",
      "module_path": "omnibase_spi.protocols.core.protocol_cache_service",
      "signature_hash": "15a008944dbc67c1",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCacheServiceProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_cache_service.py",
      "module_path": "omnibase_spi.protocols.core.protocol_cache_service",
      "signature_hash": "566fbe05ed4e4253",
      "domain": "core",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeChangeCallback",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_registry.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_registry",
      "signature_hash": "17af6ac61c672534",
      "domain": "core",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWatchHandle",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_registry.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_registry",
      "signature_hash": "7723358402e554bd",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeRegistryConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_registry.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_registry",
      "signature_hash": "e1593fa9819aee74",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeInfo",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_registry.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_registry",
      "signature_hash": "1651be277fe5637d",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeRegistry",
      "file_path": "src/omnibase_spi/protocols/core/protocol_node_registry.py",
      "module_path": "omnibase_spi.protocols.core.protocol_node_registry",
      "signature_hash": "3958da80247eb054",
      "domain": "core",
      "method_count": 13,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorHandler",
      "file_path": "src/omnibase_spi/protocols/core/protocol_error_handler.py",
      "module_path": "omnibase_spi.protocols.core.protocol_error_handler",
      "signature_hash": "111929d89f0c0180",
      "domain": "core",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceDiscovery",
      "file_path": "src/omnibase_spi/protocols/core/protocol_service_discovery.py",
      "module_path": "omnibase_spi.protocols.core.protocol_service_discovery",
      "signature_hash": "fb74c40ac07fe611",
      "domain": "core",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexNode",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_node.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_node",
      "signature_hash": "94540a976d94afb8",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContractService",
      "file_path": "src/omnibase_spi/protocols/core/protocol_contract_service.py",
      "module_path": "omnibase_spi.protocols.core.protocol_contract_service",
      "signature_hash": "10682b829966dc3e",
      "domain": "core",
      "method_count": 12,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorSanitizer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_error_sanitizer.py",
      "module_path": "omnibase_spi.protocols.core.protocol_error_sanitizer",
      "signature_hash": "a7a3fecd3c225449",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorSanitizerFactory",
      "file_path": "src/omnibase_spi/protocols/core/protocol_error_sanitizer.py",
      "module_path": "omnibase_spi.protocols.core.protocol_error_sanitizer",
      "signature_hash": "fc5b155f4d4c8c12",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCircuitBreakerConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_circuit_breaker.py",
      "module_path": "omnibase_spi.protocols.core.protocol_circuit_breaker",
      "signature_hash": "d76f76c058088f1a",
      "domain": "core",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCircuitBreakerMetrics",
      "file_path": "src/omnibase_spi/protocols/core/protocol_circuit_breaker.py",
      "module_path": "omnibase_spi.protocols.core.protocol_circuit_breaker",
      "signature_hash": "af388124a55536e5",
      "domain": "core",
      "method_count": 19,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCircuitBreaker",
      "file_path": "src/omnibase_spi/protocols/core/protocol_circuit_breaker.py",
      "module_path": "omnibase_spi.protocols.core.protocol_circuit_breaker",
      "signature_hash": "260273100ac1c20a",
      "domain": "core",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCircuitBreakerFactory",
      "file_path": "src/omnibase_spi/protocols/core/protocol_circuit_breaker.py",
      "module_path": "omnibase_spi.protocols.core.protocol_circuit_breaker",
      "signature_hash": "c73c2de64a7fbb00",
      "domain": "core",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpClientConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "95a6fcfc83f1473a",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpAuthConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "dcaea53f62a77f28",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaClientConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "8082bcf4cec48d35",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaProducerConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "948e6c5ecfebe02c",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaConsumerConfig",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "c3493df7713c65db",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolClientConfigProvider",
      "file_path": "src/omnibase_spi/protocols/core/protocol_client_config.py",
      "module_path": "omnibase_spi.protocols.core.protocol_client_config",
      "signature_hash": "06697e3181df5285",
      "domain": "core",
      "method_count": 8,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCanonicalSerializer",
      "file_path": "src/omnibase_spi/protocols/core/protocol_canonical_serializer.py",
      "module_path": "omnibase_spi.protocols.core.protocol_canonical_serializer",
      "signature_hash": "68958e2b7797b8df",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowManageable",
      "file_path": "src/omnibase_spi/protocols/core/protocol_workflow_manageable.py",
      "module_path": "omnibase_spi.protocols.core.protocol_workflow_manageable",
      "signature_hash": "41515d0e03025a5e",
      "domain": "core",
      "method_count": 19,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexContractData",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "d8bae3b6f89e54aa",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexSecurityContext",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "1a51f13da224bc53",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexMetadata",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "39f114c870bbe4e9",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexSchema",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "bceb39ff06615e07",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexValidationReport",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "0b96d723615ed498",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexValidationResult",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "5c8bbc5313a21449",
      "domain": "core",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOnexValidation",
      "file_path": "src/omnibase_spi/protocols/core/protocol_onex_validation.py",
      "module_path": "omnibase_spi.protocols.core.protocol_onex_validation",
      "signature_hash": "0f1d573f6cf6f3d7",
      "domain": "core",
      "method_count": 14,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "599905a66343b975",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryStoreResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "659e548162a57a30",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryRetrieveResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "23a60770d9a3c1f3",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryListResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "c692aeea3907b229",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchOperationResult",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "7015a3ae0035dc6a",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchMemoryStoreResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "1506c0dbd32ccb3a",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchMemoryRetrieveResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "06c1dfe5de69e8c4",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSemanticSearchResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "47a7415708d3b6bd",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPatternAnalysisResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "b9aef8dcc783f286",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEmbeddingResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "6c262ef0dd712c8d",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConsolidationResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "8e6d9034c86bd486",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAggregationResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "6332c80f2d979087",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowExecutionResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "f1eaa662fe533e24",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAgentCoordinationResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "1aae9ac4c21ec107",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPaginationResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "c0c5189e2eb4250d",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryMetrics",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "e4fee6766ba520a7",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryMetricsResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "e17c7551df9d0c64",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingMemoryResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "ec8c1b6faa676117",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingRetrieveResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_responses.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_responses",
      "signature_hash": "09f26d5797860c26",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKeyValueStore",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "ac1b1a6e880a7f1f",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryMetadata",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "c165197fe0febe6e",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowConfiguration",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "d329a2c876121d67",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalysisParameters",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "84ad372195bdc6ed",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAggregationCriteria",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "d67aa240be4bc351",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCoordinationMetadata",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "49fe1ed42efa7947",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAnalysisResults",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "250df27571aff957",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAggregatedData",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "0346848e77855909",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryErrorContext",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "b3f4da92cfd5cfa3",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPageInfo",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "67c607fecb7047d1",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCustomMetrics",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "bc0f2052ebede274",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAggregationSummary",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "612ac2f3a9369af5",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryRecord",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "e1ccef920653da8f",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSearchResult",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "b1d90daf0ba048ef",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSearchFilters",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "9df61c28ab89700d",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAgentStatusMap",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "9397aa791b6dc543",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAgentResponseMap",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "77579e967fda063a",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorCategoryMap",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_base.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_base",
      "signature_hash": "99b3c714fee57796",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowManager",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "6b909b2ff4348696",
      "domain": "memory",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAgentCoordinator",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "f16072fe301c0566",
      "domain": "memory",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolClusterCoordinator",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "17f282a5212e4f95",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLifecycleManager",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "9b9866f31c5a3800",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryOrchestrator",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "73e2ffc28de7cf0e",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolComputeNodeComposite",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_composable.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_composable",
      "signature_hash": "d16e85c559c27180",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "00530f390437b78f",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryStoreRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "4e2023dde9aee1f3",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryRetrieveRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "b0a03098fdbd50aa",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryListRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "bdea28e77b495260",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchMemoryStoreRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "8e6446af0573ecc5",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchMemoryRetrieveRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "4935f4f8a409577b",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSemanticSearchRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "e84a3075135c054d",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPatternAnalysisRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "c851cce0aa698593",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEmbeddingRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "e631c61ebf6335ce",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolConsolidationRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "3856778abfd4669a",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAggregationRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "5615f81b28fdab9c",
      "domain": "memory",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowExecutionRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "c30c0d5affbb8144",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAgentCoordinationRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "67a9c21068b8d46a",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPaginationRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "b5511d52f55c9235",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryMetricsRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "c2e40d3bed8bf607",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingMemoryRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "2b2a141de9a04f6c",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingRetrieveRequest",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_requests.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_requests",
      "signature_hash": "7cf2b5b8869627f7",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryEffectNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_operations.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_operations",
      "signature_hash": "13fe2e2d1e420133",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryComputeNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_operations.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_operations",
      "signature_hash": "cc5e7cecf45b38b4",
      "domain": "memory",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryReducerNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_operations.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_operations",
      "signature_hash": "b489809eb2b56e76",
      "domain": "memory",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryOrchestratorNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_operations.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_operations",
      "signature_hash": "bb418eb2a4f7bc41",
      "domain": "memory",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryHealthNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_operations.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_operations",
      "signature_hash": "9a9ecf5b60282761",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "d2e8036e9c6eb99f",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryErrorResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "0609454bef4723f1",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryValidationError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "57ff53c7110c5d62",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryAuthorizationError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "8aa7b11c77575821",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryNotFoundError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "a03d69802b284022",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryTimeoutError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "d343b40cc4db24ef",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryCapacityError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "250c31a2214ffeb6",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryCorruptionError",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "eea1c9a64d9bf361",
      "domain": "memory",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorRecoveryStrategy",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "d2b263fc86ec6dea",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryErrorRecoveryResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "fe991153c7c51868",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchErrorSummary",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "c40c5e4fd40f838b",
      "domain": "memory",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolBatchErrorResponse",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_errors.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_errors",
      "signature_hash": "00e5b4036f3019fb",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolErrorCategory",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "f29ebce5442f398e",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryRetryPolicy",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "0f7d1d87feeaab84",
      "domain": "memory",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryCompensationAction",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "46b4f75906cb7421",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolOperationContext",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "679ac57ecd4f62b8",
      "domain": "memory",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryErrorHandler",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "3c35d243e71f85ea",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryHealthMonitor",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_error_handling.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_error_handling",
      "signature_hash": "a0b3323d0e28ed0f",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingChunk",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "031655173c749925",
      "domain": "memory",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingConfig",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "c1cf4cb1c49f29b5",
      "domain": "memory",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolCursorPagination",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "76a9f813254e884d",
      "domain": "memory",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolStreamingMemoryNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "7a831da04d1dcf44",
      "domain": "memory",
      "method_count": 8,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryCache",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "4cb9fa04a3f33eec",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolPerformanceOptimization",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_streaming.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_streaming",
      "signature_hash": "ed0495936f8ca04d",
      "domain": "memory",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemorySecurityContext",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "253a5b9586d4a221",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAuditTrail",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "1bd648fbd30404ff",
      "domain": "memory",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRateLimitConfig",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "602b66cd6e896d8a",
      "domain": "memory",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolInputValidation",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "4760b757c2040e8a",
      "domain": "memory",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemorySecurityNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "6291fe47d6c99db9",
      "domain": "memory",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMemoryComplianceNode",
      "file_path": "src/omnibase_spi/protocols/memory/protocol_memory_security.py",
      "module_path": "omnibase_spi.protocols.memory.protocol_memory_security",
      "signature_hash": "ae24bd135574581b",
      "domain": "memory",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerInfo",
      "file_path": "src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py",
      "module_path": "omnibase_spi.protocols.discovery.protocol_handler_discovery",
      "signature_hash": "45dd6de0a6b57b0b",
      "domain": "unknown",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHandlerDiscovery",
      "file_path": "src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py",
      "module_path": "omnibase_spi.protocols.discovery.protocol_handler_discovery",
      "signature_hash": "9536b27500805286",
      "domain": "file_handling",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeDiscoveryRegistry",
      "file_path": "src/omnibase_spi/protocols/discovery/protocol_handler_discovery.py",
      "module_path": "omnibase_spi.protocols.discovery.protocol_handler_discovery",
      "signature_hash": "70adf825b6dbfa40",
      "domain": "core",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolRouter",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy",
      "signature_hash": "3c9fecc2c0b5ba6a",
      "domain": "mcp",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolExecutor",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy",
      "signature_hash": "f20a5ff7272f53bf",
      "domain": "mcp",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolProxy",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_tool_proxy.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_tool_proxy",
      "signature_hash": "9c253e41b435b24b",
      "domain": "mcp",
      "method_count": 13,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistry",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_registry",
      "signature_hash": "4617f20bcacdc26c",
      "domain": "mcp",
      "method_count": 21,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistryAdmin",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_registry",
      "signature_hash": "3982cb436f41c70d",
      "domain": "mcp",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPRegistryMetricsOperations",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_registry.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_registry",
      "signature_hash": "b11a172bf2c49b9f",
      "domain": "mcp",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPHealthMonitor",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_monitor",
      "signature_hash": "84c98ec30d7dc313",
      "domain": "mcp",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPMonitor",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_monitor.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_monitor",
      "signature_hash": "89a38814ec662176",
      "domain": "mcp",
      "method_count": 12,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPSubsystemConfig",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client",
      "signature_hash": "b98f324e44c32083",
      "domain": "mcp",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPSubsystemClient",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_subsystem_client.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_subsystem_client",
      "signature_hash": "b03ffff027a793e1",
      "domain": "mcp",
      "method_count": 22,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPServiceDiscovery",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_discovery",
      "signature_hash": "d6d98e508ca6e6f5",
      "domain": "mcp",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPDiscovery",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_discovery.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_discovery",
      "signature_hash": "d6eb496561939ced",
      "domain": "mcp",
      "method_count": 12,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPToolValidator",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_validator",
      "signature_hash": "ba5b53d8b4897860",
      "domain": "mcp",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolMCPValidator",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_mcp_validator.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_mcp_validator",
      "signature_hash": "9d60a58069452c27",
      "domain": "mcp",
      "method_count": 12,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolToolDiscoveryService",
      "file_path": "src/omnibase_spi/protocols/mcp/protocol_tool_discovery_service.py",
      "module_path": "omnibase_spi.protocols.mcp.protocol_tool_discovery_service",
      "signature_hash": "fc6fae4cbb14f090",
      "domain": "mcp",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceRegistrationMetadata",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "7dc90595ac59cd74",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceDependency",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "7c8393268f554d42",
      "domain": "container",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceRegistration",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "870f2a3a23690d98",
      "domain": "container",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRegistryServiceInstance",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "6756e40ec4e49a67",
      "domain": "container",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolDependencyGraph",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "250ccf3db7b6a05e",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolInjectionContext",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "e2e823b93332d0fc",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceRegistryStatus",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "ffc6a70b17d4f624",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceValidator",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "8146cb0d189702de",
      "domain": "container",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceFactory",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "0c36b9b016a8b47f",
      "domain": "container",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceRegistryConfig",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "f51dfab880261669",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolServiceRegistry",
      "file_path": "src/omnibase_spi/protocols/container/protocol_service_registry.py",
      "module_path": "omnibase_spi.protocols.container.protocol_service_registry",
      "signature_hash": "7814da6993a59b3f",
      "domain": "container",
      "method_count": 25,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolContainerService",
      "file_path": "src/omnibase_spi/protocols/container/protocol_container_service.py",
      "module_path": "omnibase_spi.protocols.container.protocol_container_service",
      "signature_hash": "c56988c0332dfa8a",
      "domain": "container",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolArtifactMetadata",
      "file_path": "src/omnibase_spi/protocols/container/protocol_artifact_container.py",
      "module_path": "omnibase_spi.protocols.container.protocol_artifact_container",
      "signature_hash": "57d18e323bec65bb",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolArtifactInfo",
      "file_path": "src/omnibase_spi/protocols/container/protocol_artifact_container.py",
      "module_path": "omnibase_spi.protocols.container.protocol_artifact_container",
      "signature_hash": "45096fd7177cc52d",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolArtifactContainerStatus",
      "file_path": "src/omnibase_spi/protocols/container/protocol_artifact_container.py",
      "module_path": "omnibase_spi.protocols.container.protocol_artifact_container",
      "signature_hash": "7c6586e421910e38",
      "domain": "container",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolArtifactContainer",
      "file_path": "src/omnibase_spi/protocols/container/protocol_artifact_container.py",
      "module_path": "omnibase_spi.protocols.container.protocol_artifact_container",
      "signature_hash": "ce61ccba7b3d70a5",
      "domain": "container",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkQueue",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_work_queue.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_work_queue",
      "signature_hash": "589cca7d0a7c412d",
      "domain": "workflow",
      "method_count": 27,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowEventMessage",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus",
      "signature_hash": "9c600e9aa8cdc88f",
      "domain": "workflow",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowEventHandler",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus",
      "signature_hash": "bacef0fb035e29a1",
      "domain": "workflow",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLiteralWorkflowStateProjection",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus",
      "signature_hash": "89b2da8e62f1707a",
      "domain": "workflow",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowEventBus",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_event_bus.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_event_bus",
      "signature_hash": "0088fe9c82e778c3",
      "domain": "workflow",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowNodeCapability",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry",
      "signature_hash": "9950155a195d9b96",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowNodeInfo",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry",
      "signature_hash": "61d5853d991037dc",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolTaskSchedulingCriteria",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry",
      "signature_hash": "f0b2f4dd0d59453f",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolNodeSchedulingResult",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry",
      "signature_hash": "cc871e78c1ea703c",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolWorkflowNodeRegistry",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_node_registry.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_node_registry",
      "signature_hash": "978e29e5bdbc4e6f",
      "domain": "workflow",
      "method_count": 18,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStoreTransaction",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "2bddc29a0d3a4945",
      "domain": "workflow",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventQueryOptions",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "a4c75963ead27a89",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStoreResult",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "8ee255c2a6df00e7",
      "domain": "workflow",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventStore",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "e8db8e39a71226f2",
      "domain": "workflow",
      "method_count": 7,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSnapshotStore",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "15917e06aab7ea71",
      "domain": "workflow",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLiteralWorkflowStateStore",
      "file_path": "src/omnibase_spi/protocols/workflow_orchestration/protocol_workflow_persistence.py",
      "module_path": "omnibase_spi.protocols.workflow_orchestration.protocol_workflow_persistence",
      "signature_hash": "8f08c2837f1e0b80",
      "domain": "workflow",
      "method_count": 6,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationError",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation",
      "signature_hash": "5d52ab5889fc6ea7",
      "domain": "validation",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationResult",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation",
      "signature_hash": "05abcf029156b534",
      "domain": "validation",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation",
      "signature_hash": "6e043c1882118e6a",
      "domain": "validation",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationDecorator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation",
      "signature_hash": "4334214bfe7c3b97",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolQualityMetrics",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_quality_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_quality_validator",
      "signature_hash": "1fc729aea162162b",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolQualityIssue",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_quality_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_quality_validator",
      "signature_hash": "cc0086122bcd5ed4",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolQualityStandards",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_quality_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_quality_validator",
      "signature_hash": "965031f0df777cf4",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolQualityReport",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_quality_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_quality_validator",
      "signature_hash": "1f377aca51222c5e",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolQualityValidator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_quality_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_quality_validator",
      "signature_hash": "34b88dc46ae01719",
      "domain": "validation",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationScope",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "a0de12aa507a8e7f",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationWorkflow",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "5dffbf8e11c33f6a",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationMetrics",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "61e5391d11f94186",
      "domain": "validation",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationSummary",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "4f04f6107aef7287",
      "domain": "validation",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationReport",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "dea7d51ed20bc9db",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolValidationOrchestrator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_validation_orchestrator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_validation_orchestrator",
      "signature_hash": "ad3d509a6ca6bead",
      "domain": "validation",
      "method_count": 8,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolComplianceRule",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "7eb68c776c18a868",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolComplianceViolation",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "32fab2152ea5a8d2",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolONEXStandards",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "4c27469d5699458b",
      "domain": "validation",
      "method_count": 4,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolArchitectureCompliance",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "122a624bf125e65c",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolComplianceReport",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "6b3b42760b139a94",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolComplianceValidator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_compliance_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_compliance_validator",
      "signature_hash": "c277ac10d0be6d25",
      "domain": "validation",
      "method_count": 10,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolImportValidationConfig",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_import_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_import_validator",
      "signature_hash": "6a48b53840588c28",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolImportAnalysis",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_import_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_import_validator",
      "signature_hash": "8f68cadf72e493d8",
      "domain": "validation",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolImportValidator",
      "file_path": "src/omnibase_spi/protocols/validation/protocol_import_validator.py",
      "module_path": "omnibase_spi.protocols.validation.protocol_import_validator",
      "signature_hash": "2a11b28321ac33c6",
      "domain": "validation",
      "method_count": 8,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusContextManager",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_context_manager.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_context_manager",
      "signature_hash": "149d74468f689065",
      "domain": "events",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRedpandaAdapter",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_redpanda_adapter.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_redpanda_adapter",
      "signature_hash": "fcf5d912416c9152",
      "domain": "events",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusBase",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_mixin",
      "signature_hash": "08df32bab936af7a",
      "domain": "events",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolSyncEventBus",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_mixin",
      "signature_hash": "17ecadcd4d5eac60",
      "domain": "events",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolAsyncEventBus",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_mixin",
      "signature_hash": "d0d96aa9d5c81abd",
      "domain": "events",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolRegistryWithBus",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_mixin",
      "signature_hash": "397f305f3ca16ce0",
      "domain": "events",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolLogEmitter",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_mixin.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_mixin",
      "signature_hash": "e2b3ec1f139e3f0d",
      "domain": "events",
      "method_count": 1,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusInMemory",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_in_memory.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_in_memory",
      "signature_hash": "d1276beb45ca2c3d",
      "domain": "events",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusHeaders",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus",
      "signature_hash": "13f8b867e43acdd5",
      "domain": "events",
      "method_count": 18,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaEventBusAdapter",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus",
      "signature_hash": "e84382a94184d294",
      "domain": "events",
      "method_count": 3,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBus",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus",
      "signature_hash": "63c88c8ff0271917",
      "domain": "events",
      "method_count": 8,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusService",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_service",
      "signature_hash": "998d3d681e65cf36",
      "domain": "events",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolHttpEventBusAdapter",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_service.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_service",
      "signature_hash": "e461719d49f2c6cb",
      "domain": "events",
      "method_count": 5,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventBusCredentials",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_types",
      "signature_hash": "039938e21c790fe5",
      "domain": "events",
      "method_count": 2,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolEventPubSub",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_event_bus_types.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_event_bus_types",
      "signature_hash": "ef55c01aa0ec0eb7",
      "domain": "events",
      "method_count": 9,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaConfig",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_kafka_adapter",
      "signature_hash": "80679eab771af945",
      "domain": "events",
      "method_count": 0,
      "is_runtime_checkable": true
    },
    {
      "name": "ProtocolKafkaAdapter",
      "file_path": "src/omnibase_spi/protocols/event_bus/protocol_kafka_adapter.py",
      "module_path": "omnibase_spi.protocols.event_bus.protocol_kafka_adapter",
      "signature_hash": "a80fc83843ab57d1",
      "domain": "events",
      "method_count": 6,
      "is_runtime_checkable": true
    }
  ]
}
